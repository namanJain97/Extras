Could you write all the test cases for below java class to cover all the scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8:

package com.rbs.tntr.business.taggingService.df;

import com.google.common.base.Stopwatch;
import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.domain.persistence.request.QueryParams;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.nwm.tntr.commons.repository.regreporting.trade.TradeReportDocumentRepository;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Class to persist payload/fpml in DF
 *
 */
public class DfTradePersistManager {

    TradeReportDocumentRepository tradeReportDocumentRepository;
    int dfPersistBatchSize;
    private static final Logger logger = LoggerFactory.getLogger(DfTradePersistManager.class);

    /**
     * Constructor for DfPersistManager
     * @param tradeReportDocumentRepository - new DF api trade data
     */
    public DfTradePersistManager(TradeReportDocumentRepository tradeReportDocumentRepository, int dfPersistBatchSize){
        this.tradeReportDocumentRepository = tradeReportDocumentRepository;
        this.dfPersistBatchSize = dfPersistBatchSize;
    }


    public List<TradeReportDocument> getAllRecords(QueryParams queryParams) throws TaggingServiceRunTimeException {
        try {
            return tradeReportDocumentRepository.findAllByQuery(queryParams);
        } catch (Exception e) {
            logger.error("Error occured while reading records from df. ", e);
            throw new TaggingServiceRunTimeException("Error occured while reading records from df. ", e);
        }
    }

    public List<WriteResult<TradeReport>> saveAllRecords(List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions) throws TaggingServiceRunTimeException {
        try {
            List<WriteResult<TradeReport>> writeResults = new ArrayList<>();
            List<List<Pair<TradeReport, Long>>> smallerLists = Lists.partition(reportsWithExpectedBaseVersions, dfPersistBatchSize);
            Stopwatch stopwatchPersist = Stopwatch.createStarted();
            for(List<Pair<TradeReport, Long>> reports : smallerLists) {
                writeResults.addAll(tradeReportDocumentRepository.compareAndUpdateAll(reports));
            }
            logger.info("Time taken in inserting [{}] records = [{}]ms.",writeResults.size(), stopwatchPersist.elapsed(TimeUnit.MILLISECONDS));
            logger.info("Total Trade record : [{}], Succesfully updated : [{}], Failed to update in df : [{}] ", writeResults.size(),
                    writeResults.stream().filter(result -> result.isSuccess()).count(), writeResults.stream().filter(result -> result.isFailure()).count());

            logErrorReasonForInsertion(writeResults);
            return writeResults;
        } catch (Exception e) {
            logger.error("Error occured while writing records to df. ", e);
            throw new TaggingServiceRunTimeException("Error occured while reading records to df. ", e);
        }
    }

    private void logErrorReasonForInsertion(List<WriteResult<TradeReport>> writeResults) {
        writeResults.stream().forEach(result -> {
            if (!result.isSuccess()) {
                String error = result.getErrorDetail().getCause() != null
                        ? result.getErrorDetail().getDescription() + ". " + result.getErrorDetail().getCause().getMessage()
                        : result.getErrorDetail().getDescription();
                logger.error("Error occured in persisting Trade  : [{}]", error);
            }

        });
    }
}

Existing test class:

package com.rbs.tntr.business.taggingService.df;

import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.*;
import com.nwm.tntr.commons.domain.persistence.entity.*;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportId;
import com.nwm.tntr.commons.domain.persistence.request.QueryParams;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.nwm.tntr.commons.repository.regreporting.trade.TradeReportDocumentRepository;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import junit.framework.TestCase;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.apache.commons.lang3.tuple.Pair;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;

public class DfTradePersistManagerTest {

    TradeReportDocumentRepository tradeReportDocumentRepository;
    DfTradePersistManager dfTradePersistManager;
    int dfPersistBatchSize = 500;

    @Before
    public void setUp() {
        tradeReportDocumentRepository = Mockito.mock(TradeReportDocumentRepository.class);
        dfTradePersistManager = new DfTradePersistManager(tradeReportDocumentRepository, dfPersistBatchSize);
    }

    @Test
    public void testGetAllRecords() {
        QueryParams queryParams = QueryParams.newBuilder()
                .withQueryWhere("documentLifetime.validFrom >= '2023-01-01T00:00:00.000Z'")
                .withOrderBy("documentLifetime.validFrom")
                .build();
        // Mock the repository response
        List<TradeReportDocument> expectedDocuments = Lists.newArrayList(getTradeReportDocument());
        Mockito.when(tradeReportDocumentRepository.findAllByQuery(queryParams)).thenReturn(expectedDocuments);

        // Call the method under test
        List<TradeReportDocument> actualDocuments = dfTradePersistManager.getAllRecords(queryParams);

        // Verify the results
        TestCase.assertNotNull(actualDocuments);
        TestCase.assertEquals(expectedDocuments.size(), actualDocuments.size());
        TestCase.assertEquals(expectedDocuments.get(0).getDocumentId(), actualDocuments.get(0).getDocumentId());
    }

    // test case for catch block
    @Test
    public void testGetAllRecordsException() {
        QueryParams queryParams = QueryParams.newBuilder()
                .withQueryWhere("documentLifetime.validFrom >= '2023-01-01T00:00:00.000Z'")
                .withOrderBy("documentLifetime.validFrom")
                .build();
        // Mock the repository to throw an exception
        Mockito.when(tradeReportDocumentRepository.findAllByQuery(queryParams))
                .thenThrow(new RuntimeException("Test exception"));

        try {
            // Call the method under test
            dfTradePersistManager.getAllRecords(queryParams);
            TestCase.fail("Expected TaggingServiceRunTimeException was not thrown");
        } catch (TaggingServiceRunTimeException e) {
            // Verify the exception message
            TestCase.assertTrue(e.getMessage().contains("Error occured while reading records from df"));
            TestCase.assertNotNull(e.getCause());
        }
    }

    //write test cases for save method and use the same imports as DF trade persist manager at package com.rbs.tntr.business.taggingService.df;
    @Test
    public void testSaveAllRecords() throws TaggingServiceRunTimeException {
        // Setup test data
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = Lists.newArrayList(
                Pair.of(getTradeReportDocument().getTradeReport(), 1L)
        );

        // Mock the repository response
        List<WriteResult<TradeReport>> expectedResults = getWriteResults();
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.anyList())).thenReturn(expectedResults);

        // Call the method under test
        List<WriteResult<TradeReport>> actualResults = dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);

        // Verify the results
        TestCase.assertNotNull(actualResults);
        TestCase.assertEquals(expectedResults.size(), actualResults.size());
        TestCase.assertEquals(expectedResults.get(0).getDocumentId(), actualResults.get(0).getDocumentId());

        // Verify the repository method was called
        Mockito.verify(tradeReportDocumentRepository).compareAndUpdateAll(reportsWithExpectedBaseVersions);
    }

    @Test
    public void testSaveAllRecordsWithBatching() throws TaggingServiceRunTimeException {
        // Create a list with more items than the batch size
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
        for (int i = 0; i < dfPersistBatchSize + 50; i++) {
            reportsWithExpectedBaseVersions.add(Pair.of(getTradeReportDocument().getTradeReport(), 1L));
        }

        // Mock the repository response
        List<WriteResult<TradeReport>> expectedResults = getWriteResults();
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.any())).thenReturn(expectedResults);

        // Call the method under test
        List<WriteResult<TradeReport>> actualResults = dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);

        // Verify the repository method was called twice (once for each batch)
        Mockito.verify(tradeReportDocumentRepository, Mockito.times(2)).compareAndUpdateAll(Mockito.anyList());
    }

    @Test
    public void testSaveAllRecordsException() {
        // Setup test data
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = Lists.newArrayList(
                Pair.of(getTradeReportDocument().getTradeReport(), 1L)
        );

        // Mock the repository to throw an exception
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.anyList()))
                .thenThrow(new RuntimeException("Test exception"));

        try {
            // Call the method under test
            dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);
            TestCase.fail("Expected TaggingServiceRunTimeException was not thrown");
        } catch (TaggingServiceRunTimeException e) {
            // Verify the exception message
            TestCase.assertTrue(e.getMessage().contains("Error occured while reading records to df"));
            TestCase.assertNotNull(e.getCause());
        }
    }

    private TradeReportDocument getTradeReportDocument() {
        DocumentId documentId = DocumentId.from("TradeReportId_123", 1L);
        DocumentLifetime documentLifetime = DocumentLifetime.from(ZonedDateTime.now(ZoneOffset.UTC),
                ZonedDateTime.now(ZoneOffset.UTC));
        TradeReport tradeReport = TradeReport.newBuilder()
                .withTradeReportId(TradeReportId.newBuilder().withTradeSourceSystemTransactionId("TradeReportId_123")
                        .withTradeSourceSystemId(SourceSystemId.ANVIL_GBLO_LDN).withTradeDocumentVersion(1)
                        .withReportingRegime(ReportingRegime.SECURITIES_FINANCING_TRANSACTION_REGULATION_SELF_REPORTING)
                        .withReportingRegulatoryAuthority(
                                ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION)
                        .withRegimeImpactType(RegimeImpactType.TRANSACTION_REPORTING)
                        .withReportTriggerType(ReportTriggerType.TRANSACTION_LIFECYCLE)
                        .withReportSubmissionType(ReportSubmissionType.SNAPSHOT).build())
                .withTransactionReportingStatus(TransactionReportingStatus.newBuilder()
                        .withSourceSystemId(SourceSystemId.TN_TR)
                        .withStateTransitionDateTime(ZonedDateTime.now(ZoneOffset.UTC))
                        .withStateTransitionEffectiveDateTime(ZonedDateTime.now(ZoneOffset.UTC))
                        .withTransactionStateValue(TransactionStateValue.SUBMITTED)
                        .withReportSubmissionRepository(SourceSystemId.DTCC).withCommentary("Test TradeReport").build())
                .withExceptionManagement(ExceptionManagement.newBuilder().withApprovedBy("PERSON_1")
                        .withAssignedTo("matbina")
                        .withExceptionStatus(com.nwm.tntr.commons.domain.persistence.constant.ExceptionStatus.OPEN)
                        .withApprovalStatus(ApprovalStatus.OPEN_REQUESTED)
                        .withIssueIds(Lists.newArrayList("TNTR-1234", "TNTR-9875"))
                        .withIssueType(IssueType.MIS_REPORTING).withLastAction("Replay Edit")
                        .withLastActionDateTime(ZonedDateTime.now(ZoneOffset.UTC)).withLastActionUser("USER_1")
                        .withLatestVersion(false).withReportingDeadline(ZonedDateTime.now(ZoneOffset.UTC).plusDays(2))
                        .withUserComment("COMMENT 1").build())
                .withNonReportableData(NonReportableData.newBuilder().withLatestVersion(true).build()).build();
        TradeReportDocument tradeReportDocument = TradeReportDocument.from(documentId, documentLifetime, tradeReport);

        return tradeReportDocument;
    }

    private List<WriteResult<TradeReport>> getWriteResults() {
        return Lists.newArrayList(WriteResult.forSuccess(DocumentId.from("TradeReportId_123", 1L),
                getTradeReportDocument().getTradeReport()));
    }
}
