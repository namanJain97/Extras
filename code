package com.rbs.tntr.business.blotter.services;

import static org.junit.Assert.*;
import java.io.IOException;
import java.util.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.domain.*;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.springframework.test.util.ReflectionTestUtils;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.nwm.tntr.domain.email.EmailContent;
import com.nwm.tntr.services.email.EmailService;
import com.rbs.datafabric.api.PagedScanResult;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.tntr.business.blotter.repository.DataFabricExportRepository;
import com.rbs.tntr.business.blotter.search.querybuilder.DfExportScan;
import com.rbs.tntr.business.blotter.search.querybuilder.DfScanParameters;
import com.rbs.tntr.business.blotter.services.common.StringConstants;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeServiceImpl;
import com.rbs.tntr.business.blotter.services.jobs.DfExportJob;
import com.rbs.tntr.business.blotter.utility.BlotterUtil;
import com.rbs.tntr.business.blotter.utility.CsvWriterImpl;
import com.rbs.tntr.business.blotter.utility.DataFabricExportUtility;
import com.rbs.tntr.business.blotter.utility.ExcelWriterImpl;
import com.rbs.tntr.domain.blotter.exceptions.ValidationException;
import org.joda.time.DateTime;

/**
 * Description : Test class for Service
 *
 * @author agrakit
 * 
 *         Created By: Niket Agrawal
 * 
 *         Created On 01-09-2021
 * 
 */
public class DataFabricExportServiceTest {

    DataFabricExportServiceImpl dataFabricExportServiceImpl;
    DataFabricExportUtility dataFabricExportUtil;
    DataFabricExportRepository exportRepo;
    CsvWriterImpl csvWriter;
    ExcelWriterImpl excelWriter;
    DataFabricExportService service;
    String userName;
    List<Map<String, String>> parsedRecordsList;
    DateTimeService dateTimeService;
    DfConnectionManager dfConnectionManager;
    DataFabricClient client;
    EmailService emailService;

    @SuppressWarnings("unchecked")
    @Before
    public void setup() throws Exception {
        userName = "agrakit";
        dataFabricExportUtil = Mockito.mock(DataFabricExportUtility.class);
        exportRepo = Mockito.mock(DataFabricExportRepository.class);
        csvWriter = Mockito.mock(CsvWriterImpl.class);
        excelWriter = Mockito.mock(ExcelWriterImpl.class);
        dfConnectionManager = Mockito.mock(DfConnectionManager.class);
        client = Mockito.mock(DataFabricClient.class);
        emailService = Mockito.mock(EmailService.class);
        Mockito.when(emailService.sendHtmlEmail(Mockito.any())).thenReturn(true);
        Mockito.when(emailService.sendEmailWithAttachment(Mockito.any())).thenReturn(true);
        ScanRequestBuilder scanRequestBuilder = getScanRequestBuilder();
        Mockito.when(dataFabricExportUtil.getScanRequestBuilder(Mockito.any(DfScanParameters.class)))
                .thenReturn(scanRequestBuilder);
        Mockito.when(dataFabricExportUtil.getDataFabricClient()).thenReturn(client);
        PagedScanResult pagedScan = getPagedScan(false);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class))).thenReturn(pagedScan);
        PagedScanResult finalPage = getPagedScan(true);
        Mockito.when(dataFabricExportUtil.getNextPage(Mockito.anyString(), Mockito.anyInt())).thenReturn(finalPage);
        dateTimeService = new DateTimeServiceImpl();

        service = new DataFabricExportServiceImpl(exportRepo, dataFabricExportUtil, csvWriter, excelWriter,
                dateTimeService, emailService);
        dataFabricExportServiceImpl = new DataFabricExportServiceImpl(exportRepo, dataFabricExportUtil, csvWriter, excelWriter,
                dateTimeService, emailService);
        ReflectionTestUtils.setField(service, "outputFilePath", "c://Export");
        ReflectionTestUtils.setField(service, "exportThresholdCount", 100000);
        ReflectionTestUtils.setField(service, "exportThresholdCountFeature", false);
        ReflectionTestUtils.setField(service, "exportPageCount", 10000);
        ReflectionTestUtils.setField(service, "emailNotificationFeature", true);
        ReflectionTestUtils.setField(service, "zippedExportFeature", true);
        ReflectionTestUtils.setField(service, "miReceiverEmail", "username@natwestmarkets.com");
        ReflectionTestUtils.setField(service, "emailFrom", "blotterservice@notifications.com");
        ReflectionTestUtils.setField(service, "smtpHost", "smtp.host@server.in");
        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(createHeaders());

        Map<String, String> dataMap = new HashMap<>();
        dataMap.put("header1", "value1");
        parsedRecordsList = Lists.newArrayList();
        parsedRecordsList.add(dataMap);
        Mockito.when(excelWriter.exportExcel((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class))).thenReturn(true);
    }

    @Test
    public void fetchAndExportRecords_Exception() {
        boolean result = service.fetchAndExportRecords(createParam("Transaction"), userName, false, new DfExportScan());
        assertTrue(result);
    }

    @Test
    public void validateRequest_Exception() {
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan("agrakit_blotter_123123", "Transaction,Valuation", "agrakit"));
        boolean result = service.fetchAndExportRecordsMultiCollection(Lists.newArrayList(createParam("")), userName,
                false,
                new DfExportScan(), service.generateExportFileName("blotterName", userName), false);
        assertFalse(result);
    }

    @Test(expected = ValidationException.class)
    public void validateRequest_scanId_Exception() {
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan("agrakit_blotter_123123", "Transaction", "agrakit"));
        boolean result = service.fetchScanByIdAndGenerateExport("", "userName");
        assertFalse(result);
    }

    @Test(expected = ValidationException.class)
    public void validateUpdateDfScan_Exception() {
        service.updateDfScan(Lists.newArrayList(createScan("", "Transaction", "agrakit")));
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchAndExportRecords_MultiCollection_emptyHeader() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(parsedRecordsList);
        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(new TreeSet<>());
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(true);
        boolean result = service.fetchAndExportRecords(createParam("Transaction,Valuation"), userName, false,
                new DfExportScan());
        assertTrue(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchAndExportRecords_Success() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(parsedRecordsList);
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(true);
        boolean result = service.fetchAndExportRecords(createParam("Transaction"), userName, false, createExcelScan());
        assertTrue(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchAndExportRecords_MultiCollection_Success() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(parsedRecordsList);
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(true);
        boolean result = service.fetchAndExportRecords(createParam("Transaction,Valuation"), userName, true,
                createExcelScan());
        assertTrue(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchScanByIdAndGenerateExport_singleCollection_Success() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(parsedRecordsList);
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(true);
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan("agrakit_blotter_123123", "Transaction", "agrakit"));
        boolean result = service.fetchScanByIdAndGenerateExport("scanId", "userName");
        assertTrue(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchScanByIdAndGenerateExport_multiCollection_Success() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(new ArrayList<Map<String, String>>());
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(true);
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan("agrakit_blotter_123123", "Transaction,Valuation", "agrakit"));
        boolean result = service.fetchScanByIdAndGenerateExport("scanId", "userName");
        assertTrue(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchAndExportRecords_Failure() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(parsedRecordsList);
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(false);
        Mockito.when(excelWriter.exportExcel((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(false);
        boolean result = service.fetchAndExportRecords(createParam("Transaction"), userName, false, createExcelScan());
        assertTrue(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchAndExportRecordsMultiCollection_Failure() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(parsedRecordsList);
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(false);
        Mockito.when(excelWriter.exportExcel((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(false);
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan("agrakit_blotter_123123", "Transaction,Valuation", "agrakit"));
        boolean result = service.fetchAndExportRecordsMultiCollection(Lists.newArrayList(createParam("Transaction")),
                userName, false, createExcelScan(), service.generateExportFileName("blotterName", userName), false);
        assertFalse(result);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void fetchAndExportRecordsMultiCollection_Success() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(fetchRecordList());
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                Mockito.any(String.class)))
                .thenReturn(true);
        boolean result = service.fetchAndExportRecordsMultiCollection(Lists.newArrayList(createParam("Transaction")),
                userName, false, createExcelScan(), service.generateExportFileName("blotterName", userName), false);
        assertTrue(result);
    }

    @Test
    public void fetchAndExportRecordsMultiCollection_Recon_Success() throws Exception {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(fetchRecordList());
        Mockito.when(csvWriter.generateCsvFile((List<String[]>) Mockito.any(List.class), Mockito.any(String.class),
                        Mockito.any(String.class)))
                .thenReturn(true);
        String recon_select_result = "{  \"reconciliationBusinessDateTime\": \"2025-03-26T00:00:00.000Z\",  \"identifier\": \"EmirDelegationFx\"}";
        PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(recon_select_result)), false, "scanId", 1);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
                .thenThrow(new ScanException("df error"))
                .thenReturn(getPagedScan(false))
                .thenThrow(new ScanException("df error"))
                .thenReturn(pagedScan);
        DfExportScan scan = new DfExportScan();
        scan.setCollectionName("Reconciliation");
        boolean result = service.fetchAndExportRecordsMultiCollection(Lists.newArrayList(createParam("Reconciliation")),
                userName, false, scan, service.generateExportFileName("blotterName", userName), false);
        assertTrue(result);
    }

    @Test
    public void testScanInsert_success() {
        DfExportScan scan = createScan("", "collectionName", "agrakit");
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        RecordId recordId = service.insertDfScan(scan);
        assertEquals(recordId.getCollectionName(), "collectionName");
    }

    @Test
    public void testScheduledScanInsert_success() {
        DfExportScan scan = createScan("", "collectionName", "agrakit");
        scan.setScheduled(true);
        scan.setScheduledTime("8:30 AM");
        scan.setScheduleFrequency("DAILY");
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        RecordId recordId = service.insertDfScan(scan);
        assertEquals(recordId.getCollectionName(), "collectionName");
    }

    @Test
    public void testScheduledScanUpdate_success() {
        DfExportScan scan = createScan("", "collectionName", "agrakit");
        scan.setScanId("scanId");
        scan.setScheduled(true);
        scan.setScheduledTime("8:30 AM");
        scan.setScheduleFrequency("DAILY");
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        List<RecordId> recordId = service.updateDfScan(Lists.newArrayList(scan));
        assertEquals(recordId.get(0).getCollectionName(), "collectionName");
    }

    @Test
    public void testScheduledScanInsertTwo_success() {
        DfExportScan scan = createScan("", "collectionName", "agrakit");
        scan.setScheduled(true);
        scan.setScheduledTime("8:30 PM");
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        RecordId recordId = service.insertDfScan(scan);
        assertEquals(recordId.getCollectionName(), "collectionName");
    }

    @Test
    public void testFetchDfScan_success() {
        DfExportScan scan = createScan("", "collectionName", "agrakit");
        scan.setLastExecutionDateTime("27-11-2090 08:40:27");
        Mockito.when(exportRepo.fetchDfScansForUser(Mockito.anyString())).thenReturn(Lists.newArrayList(scan));
        List<DfExportScan> scanList = service.fetchDfScansForUser("userName");
        assertEquals(1, scanList.size());
    }

    @Test
    public void testFetchDfScan_filterSuccess() {
        DfExportScan scan = createScan("", "collectionName", "agrakit");
        scan.setLastExecutionDateTime("27-11-2090 08:40:27");
        DfExportScan scan1 = createScan("", "collectionName", "agrakit");
        scan1.setLastExecutionDateTime("27-11-2021 08:40:27");
        Mockito.when(exportRepo.fetchDfScansForUser(Mockito.anyString())).thenReturn(Lists.newArrayList(scan, scan1));
        List<DfExportScan> scanList = service.fetchDfScansForUser("userName");
        assertEquals(1, scanList.size());
    }

    @Test
    public void testFilterLatestScanList_success() {
        List<String> creationDateList = Lists.newArrayList("27-05-2090 08:40:27", "27-11-2090 08:40:27", null, "27-10-2022 08:40:27", "27-10-2022 08:40:27");
        List<String> lastExecutionDateTimeList = Lists.newArrayList("27-11-2090 08:40:27", null, "27-10-2022 08:40:27", "27-10-2022 08:40:27", "");
        DfExportScan scan = new DfExportScan();
        scan.setCreationDate(creationDateList.get(0));
        scan.setLastExecutionDateTime(lastExecutionDateTimeList.get(0));
        assertTrue(dataFabricExportServiceImpl.filterLatestScanList(scan));
        scan.setCreationDate(creationDateList.get(1));
        scan.setLastExecutionDateTime(lastExecutionDateTimeList.get(1));
        assertTrue(dataFabricExportServiceImpl.filterLatestScanList(scan));
        scan.setCreationDate(creationDateList.get(2));
        scan.setLastExecutionDateTime(lastExecutionDateTimeList.get(2));
        assertFalse(dataFabricExportServiceImpl.filterLatestScanList(scan));
        scan.setCreationDate(creationDateList.get(3));
        scan.setLastExecutionDateTime(lastExecutionDateTimeList.get(3));
        assertFalse(dataFabricExportServiceImpl.filterLatestScanList(scan));
        scan.setCreationDate(creationDateList.get(4));
        scan.setLastExecutionDateTime(lastExecutionDateTimeList.get(4));
        assertFalse(dataFabricExportServiceImpl.filterLatestScanList(scan));
    }

    @SuppressWarnings("unchecked")
    @Test
    public void testDeleteDfScan_success() {
        List<String> scanIds = Lists.newArrayList("scanId1", "scanId2");
        Mockito.when(exportRepo.deleteExportScans(Mockito.anyList())).thenReturn(Long.valueOf(scanIds.size()));
        assertEquals(scanIds.size(), service.deleteExportScans(scanIds));
    }

    @Test
    public void testFetchScanById() {
        String scanId = "agrakit_blotter_123123";
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan(scanId, "Transaction", "agrakit"));
        assertEquals(scanId, service.fetchDfExportScanById(scanId).getScanId());
    }

    @Test(expected = ValidationException.class)
    public void testScanByDfScanId_exception() {
        service.fetchDfExportScanById(StringConstants.EMPTY);
    }

    @Test(expected = ValidationException.class)
    public void testDeleteDfScan_exception() {
        List<String> scanIds = Lists.newArrayList();
        service.deleteExportScans(scanIds);
    }

    @Test
    public void testScheduledDfExports() {
        List<DfExportScan> scanList = Lists.newArrayList();
        DfExportScan scan = createScan("scanId", "Transaction", "agrawmq");
        scan.setScheduled(true);
        scan.setScheduledTime("8:30 AM");
        scan.setAsOf("2025-04-04T23:59:59.000Z");
        scan.setWhere("(nonReportableData.tntrReceivedTimestamp >= {T-3} AND subjectIdentifier.regulatoryRegimeIdentifier.name IN ('Canada Rule 91-507'))");
        scanList.add(scan);

        Mockito.when(exportRepo.fetchScheduledScans()).thenReturn(scanList);
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));

        service.scheduledDfExports();

        Mockito.verify(exportRepo, Mockito.times(1)).fetchScheduledScans();
        Mockito.verify(exportRepo, Mockito.atLeastOnce()).upsertDfScan(Mockito.any(DfExportScan.class));
    }

    @Test
    public void testGetMiFolderPath() {
        String folderPath = service.getMiFolderPath();
        assertNotNull(folderPath);
    }

    @Test
    public void testGenerateForcedExport() {
        Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
                .thenReturn(createScan("agrakit_blotter_123123", "Transaction,Valuation", "agrakit"));

        service.generateForcedExport("scanId", "username");

        Mockito.verify(exportRepo, Mockito.atLeastOnce()).fetchDfScanById(Mockito.anyString());
    }

    @Test
    public void testGenerateWeeklyKnownMiExport() throws Exception {
        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(createHeaders());
        ScanResult scanResult = getMockScanResult(getMockRecords(getJsonRecords()));
        Mockito.when(client.scan(Mockito.any())).thenReturn(scanResult);
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(fetchRecordList());
        Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any()))
                .thenReturn(true);

        boolean result = service.generateWeeklyKnownMiExport(Lists.newArrayList(createParam("Transaction")),
                createScan("scanId", "Transaction", "MIEXTRACT"), "fileName");

        assertTrue(result);

        Mockito.verify(dataFabricExportUtil, Mockito.atLeastOnce()).getAllHeaders();
    }

    @Test
    public void testGenerateWeeklyKnownMiExport_With_NoRecords() throws Exception {
        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(createHeaders());
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(fetchRecordList());

        boolean result = service.generateWeeklyKnownMiExport(Lists.newArrayList(createParam("Transaction")),
                createScan("scanId", "Transaction", "MIEXTRACT"), "fileName");

        assertTrue(result);
    }

    @Test
    public void testGenerateWeeklyKnownMiExport_With_Error() throws Exception {
        ScanResult scanResult = getMockScanResult(getMockRecords(getJsonRecords()));
        Mockito.when(client.scan(Mockito.any())).thenReturn(scanResult);
        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(createHeaders());

        List<Map<String, String>> recordList = fetchRecordList();
        recordList.forEach(record -> record.remove("Asset Class Final"));
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(List.class), Mockito.anyString(), Mockito.any(DfExportScan.class)))
                .thenReturn(recordList);

        boolean result = service.generateWeeklyKnownMiExport(Lists.newArrayList(createParam("Transaction")),
                createScan("scanId", "Transaction", "MIEXTRACT"), "fileName");

        assertTrue(result);
    }

    @Test
    public void testgenerateMiSnapShot() throws IOException, ScanException {
        String trade_snapshot = "{  \"_id\": {    \"subjectIdentifier.assetClass\": \"ForeignExchange\"  },  \"Flow\": \"Transaction\",  \"Jurisdiction\": \"European Markets Infrastructure Regulation\",  \"assetClass\": \"ForeignExchange\",  \"Accurate\": 955,  \"CAT\": 955,  \"Complete\": 955,  \"failedToSubmitKnown\": 0,  \"failedToSubmitUnKnown\": 1338,  \"ignoredKnown\": 0,  \"ignoredUnKnown\": 0,  \"inProcessUnKnown\": 0,  \"inProcessKnown\": 0,  \"lateReportedKnown\": 0,  \"lateReportedUnKnown\": 0,  \"misReportedKnown\": 0,  \"misReportedUnKnown\": 0,  \"monthlyCAT\": 71102,  \"monthlyReportable\": 109551,  \"noResponseKnown\": 0,  \"noResponseUnKnown\": 0,  \"overReportedKnown\": 0,  \"overReportedUnKnown\": 0,  \"previousDayCAT\": 1823,  \"previousDayReportable\": 3429,  \"rejectedByTRKnown\": 0,  \"rejectedByTRUnKnown\": 51,  \"Reportable\": 2344,  \"Timely\": 955,  \"tradeEdited\": 0,  \"tradeReplayed\": 0,  \"weeklyCAT\": 6815,  \"weeklyReportable\": 15435}";
        System.out.println(trade_snapshot);

        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(createHeaders());
        Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any()))
                .thenReturn(true);
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any()))
                .thenReturn(fetchRecordList_For_Snapshot(trade_snapshot));

        service.generateMiSnapShotReport(Lists.newArrayList(createParam("Transaction")),
                createScan("scanId", "Transaction", "MIEXTRACT"), "snapshotFileName");
        Mockito.verify(client, Mockito.atLeastOnce()).pagedScan(Mockito.any());
    }

    @Test
    public void testgenerateMiSnapShot_Collateral() throws IOException, ScanException {
        String collateral_snapshot = "{  \"_id\": {    \"subjectIdentifier.assetClass\": \"NONE\"  },  \"Flow\": \"Collateral\",  \"Jurisdiction\": \"European Markets Infrastructure Regulation\",  \"assetClass\": \"NONE\",  \"Accurate\": 0,  \"CAT\": 0,  \"Complete\": 0,  \"failedToSubmitKnown\": 0,  \"failedToSubmitUnKnown\": 0,  \"ignoredKnown\": 0,  \"ignoredUnKnown\": 0,  \"inProcessUnKnown\": 0,  \"inProcessKnown\": 0,  \"lateReportedKnown\": 0,  \"lateReportedUnKnown\": 0,  \"misReportedKnown\": 0,  \"misReportedUnKnown\": 0,  \"monthlyCAT\": 1952,  \"monthlyReportable\": 2651,  \"noResponseKnown\": 0,  \"noResponseUnKnown\": 0,  \"overReportedKnown\": 0,  \"overReportedUnKnown\": 0,  \"previousDayCAT\": 0,  \"previousDayReportable\": 0,  \"rejectedByTRKnown\": 0,  \"rejectedByTRUnKnown\": 0,  \"Reportable\": 0,  \"Timely\": 0,  \"tradeEdited\": 0,  \"tradeReplayed\": 0,  \"weeklyCAT\": 0,  \"weeklyReportable\": 0}";

        Mockito.when(dataFabricExportUtil.getAllHeaders()).thenReturn(createHeaders());
        Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any()))
                .thenReturn(true);
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any()))
                .thenReturn(fetchRecordList_For_Snapshot(collateral_snapshot));

        service.generateMiSnapShotReport(Lists.newArrayList(createParam("Collateral")),
                createScan("scanId", "Collateral", "MIEXTRACT"), "snapshotFileName");
        Mockito.verify(client, Mockito.atLeastOnce()).pagedScan(Mockito.any());
    }

    @Test
    public void testgenerateMiSnapShotReport() throws IOException, ScanException {
        Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any()))
                .thenReturn(fetchRecordList());
        List<Record> emptyRecords = Lists.newArrayList();
        PagedScanResult pagedScan = new PagedScanResult(emptyRecords, false, "scanId", 1);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class))).thenReturn(pagedScan);

        service.generateMiSnapShotReport(Lists.newArrayList(createParam("Transaction")),
                createScan("scanId", "Transaction", "MIEXTRACT"), "snapshotFileName");
        Mockito.verify(client, Mockito.atLeastOnce()).pagedScan(Mockito.any());
    }

    // Additional test cases for 100% coverage

    @Test
    public void testCalculateThresholdCount() throws Exception {
        List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Collection1"), createParam("Collection2"));
        PagedScanResult pagedScan1 = new PagedScanResult(getMockRecords(Lists.newArrayList("{\"totalCount\": 100}")), true, "scanId1", 1);
        PagedScanResult pagedScan2 = new PagedScanResult(getMockRecords(Lists.newArrayList("{\"totalCount\": 200}")), true, "scanId2", 1);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
                .thenReturn(pagedScan1)
                .thenReturn(pagedScan2);
        int totalCount = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateThresholdCount", scanParamList, userName);
        assertEquals(300, totalCount);
    }

    @Test
    public void testCalculateThresholdCount_ScanExceptionRetry() throws Exception {
        List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Collection1"));
        PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList("{\"totalCount\": 100}")), true, "scanId", 1);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
                .thenThrow(new ScanException("First attempt failed"))
                .thenReturn(pagedScan);
        int totalCount = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateThresholdCount", scanParamList, userName);
        assertEquals(100, totalCount);
    }

    @Test
    public void testModifyFileName() throws Exception {
        List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Reconciliation"));
        String fileName = "originalFileName";
        String reconResult = "{\"identifier\": \"ReconId\", \"reconciliationBusinessDateTime\": \"2023-01-01T00:00:00.000Z\"}";
        PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(reconResult)), true, "scanId", 1);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class))).thenReturn(pagedScan);
        String modifiedFileName = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "modifyFileName", scanParamList, fileName);
        assertEquals("ReconId_2023-01-01_originalFileName", modifiedFileName);
    }

    @Test
    public void testModifyFileName_ScanExceptionRetry() throws Exception {
        List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Reconciliation"));
        String fileName = "originalFileName";
        String reconResult = "{\"identifier\": \"ReconId\", \"reconciliationBusinessDateTime\": \"2023-01-01T00:00:00.000Z\"}";
        PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(reconResult)), true, "scanId", 1);
        Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
                .thenThrow(new ScanException("First attempt failed"))
                .thenReturn(pagedScan);
        String modifiedFileName = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "modifyFileName", scanParamList, fileName);
        assertEquals("ReconId_2023-01-01_originalFileName", modifiedFileName);
    }

    @Test
    public void testGenerateScanRequestId() throws Exception {
        String userName = "testUser";
        String scanId = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateScanRequestId", userName);
        assertTrue(scanId.startsWith(userName + "_SCANREQ_"));
    }

    @Test
    public void testUpdateFailedScan() throws Exception {
        String scanId = "scanId";
        String status = "FAILED";
        String remarks = "Test failure";
        DfExportScan scan = createScan(scanId, "Collection", "user");
        Mockito.when(exportRepo.fetchDfScanById(scanId)).thenReturn(scan);
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "updateFailedScan", scanId, status, remarks);
        assertEquals(status, scan.getExecutionStatus());
        assertEquals(remarks, scan.getRemarks());
    }

    @Test
    public void testGenerateAsOfFromScan() throws Exception {
        String asOf = "2023-01-01T00:00:00.000Z";
        long expectedMillis = dateTimeService.parseDateTime(asOf).getMillis();
        long actualMillis = (long) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateAsOfFromScan", asOf);
        assertEquals(expectedMillis, actualMillis);
    }

    @Test
    public void testCalculateNextRun_Daily() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        scan.setScheduled(true);
        scan.setScheduleFrequency("DAILY");
        DateTime initialDate = DateTime.now();
        scan.setNextRunDateTime(initialDate.toDate());
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateNextRun", scan);
        DateTime expectedDate = initialDate.plusDays(1);
        assertEquals(expectedDate.toString("dd-MM-yyyy HH:mm:ss"), dateTimeService.asString(new DateTime(scan.getNextRunDateTime())));
    }

    @Test
    public void testCalculateNextRun_Weekly() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        scan.setScheduled(true);
        scan.setScheduleFrequency("WEEKLY");
        DateTime initialDate = DateTime.now();
        scan.setNextRunDateTime(initialDate.toDate());
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateNextRun", scan);
        DateTime expectedDate = initialDate.plusDays(7);
        assertEquals(expectedDate.toString("dd-MM-yyyy HH:mm:ss"), dateTimeService.asString(new DateTime(scan.getNextRunDateTime())));
    }

    @Test
    public void testCalculateNextRun_Monthly() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        scan.setScheduled(true);
        scan.setScheduleFrequency("MONTHLY");
        DateTime initialDate = DateTime.now();
        scan.setNextRunDateTime(initialDate.toDate());
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateNextRun", scan);
        DateTime expectedDate = initialDate.plusDays(30);
        assertEquals(expectedDate.toString("dd-MM-yyyy HH:mm:ss"), dateTimeService.asString(new DateTime(scan.getNextRunDateTime())));
    }

    @Test
    public void testPopulateNextRunDate_BeforeCurrent() throws Exception {
        String scanTime = "01:00 AM";
        Date nextRunDate = (Date) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateNextRunDate", scanTime);
        DateTime currentDateTime = dateTimeService.getCurrentUTCDateTime();
        DateTime expectedDateTime = currentDateTime.withHourOfDay(1).withMinuteOfHour(0).withSecondOfMinute(0).withMillisOfSecond(0);
        if (expectedDateTime.isBefore(currentDateTime)) {
            expectedDateTime = expectedDateTime.plusDays(1);
        }
        assertEquals(expectedDateTime.toString("dd-MM-yyyy HH:mm:ss"), dateTimeService.asString(new DateTime(nextRunDate)));
    }

    @Test
    public void testPopulateEmailNotification() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        scan.setExportName("exportFile");
        scan.setLastExecutionDateTime("2023-01-01 00:00:00");
        scan.setExportRecordCount(100);
        scan.setExecutionTime("10");
        Mockito.when(BlotterUtil.getLoggedInUserDetails("user")).thenReturn(new LoggedInUserDetails("User Name", "user@example.com"));
        EmailContent emailContent = (EmailContent) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateEmailNotification", scan);
        assertNotNull(emailContent);
        assertEquals("Blotter Export Notification", emailContent.getEmailSubject());
        assertTrue(emailContent.getEmailBody().contains("Dear User Name"));
    }

    @Test
    public void testPopulateEmailWithAttachment() throws Exception {
        DfExportScan scan = createScan("scanId", "FO_MI_SNAPSHOT", "MIEXTRACT");
        scan.setExportName("exportFile");
        EmailContent emailContent = (EmailContent) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateEmailWithAttachment", scan);
        assertNotNull(emailContent);
        assertEquals("Blotter Export Notification", emailContent.getEmailSubject());
        assertTrue(emailContent.getEmailBody().contains("FO MI SNAPSHOT"));
    }

    @Test
    public void testGenerateMiMailContent() throws Exception {
        DfExportScan scan = createScan("scanId", "CONTROL_MI", "MIEXTRACT");
        scan.setExportName("exportFile");
        String emailBody = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateMiMailContent", scan);
        assertTrue(emailBody.contains("Export for CONTROL MI"));
    }

    @Test
    public void testDeleteIncompleteExportFile() throws Exception {
        String fileName = "testFile";
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "deleteIncompleteExportFile", fileName);
        // No direct assertion possible due to static FileUtils.deleteQuietly, but method is invoked
    }

    @Test
    public void testDeleteIncompleteZipFile() throws Exception {
        String fileName = "testFile.zip";
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "deleteIncompleteZipFile", fileName);
        // No direct assertion possible due to static FileUtils.deleteQuietly, but method is invoked
    }

    @Test
    public void testZipExportFile() throws Exception {
        String fileName = "testFile";
        Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(true);
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "zipExportFile", fileName);
        // File system interaction mocked, verify method invocation
    }

    @Test
    public void testExportDataToFile() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        Set<String> headersList = Sets.newHashSet("header1");
        String fileName = "testFile";
        String collectionName = "Collection";
        List<Record> recordList = getMockRecords(getJsonRecords());
        List<Map<String, String>> parsedRecords = fetchRecordList();
        Mockito.when(dataFabricExportUtil.convertScannedRecords(recordList, collectionName, scan)).thenReturn(parsedRecords);
        Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(true);
        int result = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "exportDataToFile", scan, headersList, fileName, collectionName, recordList);
        assertEquals(1, result);
    }

    @Test
    public void testWriteDataToFile_CSV() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        scan.setExportFileFormat("CSV");
        String fileName = "testFile";
        List<String[]> rows = Lists.newArrayList(new String[]{"header1", "header2"}, new String[]{"data1", "data2"});
        Mockito.when(csvWriter.generateCsvFile(rows, Mockito.anyString(), Mockito.anyString())).thenReturn(true);
        boolean result = (boolean) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "writeDataToFile", scan, fileName, rows);
        assertTrue(result);
        Mockito.verify(csvWriter).generateCsvFile(rows, Mockito.anyString(), Mockito.anyString());
    }

    @Test
    public void testGenerateOutputFileName() throws Exception {
        String fileName = "testFile";
        String ext = "csv";
        String outputPath = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateOutputFileName", fileName, ext);
        assertTrue(outputPath.contains("c://Export"));
        assertTrue(outputPath.endsWith(".csv"));
    }

    @Test
    public void testSubmitTask_Success() {
        DfExportJob job = new DfExportJob(Lists.newArrayList(createParam("Collection")), userName, false, new DfExportScan(), "fileName");
        boolean result = service.submitTask(job);
        assertTrue(result);
    }

    @Test
    public void testSubmitTask_Interrupted() throws Exception {
        DfExportJob job = new DfExportJob(Lists.newArrayList(createParam("Collection")), userName, false, new DfExportScan(), "fileName");
        BlockingQueue<DfExportJob> queue = (BlockingQueue<DfExportJob>) ReflectionTestUtils.getField(dataFabricExportServiceImpl, "queue");
        queue.clear();
        Mockito.doThrow(new InterruptedException()).when(queue).put(Mockito.any(DfExportJob.class));
        boolean result = service.submitTask(job);
        assertFalse(result);
    }

    @Test
    public void testStartScheduledJob() {
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "startScheduledJob");
        Thread thread = (Thread) ReflectionTestUtils.getField(dataFabricExportServiceImpl, "thread");
        assertNotNull(thread);
        assertTrue(thread.isAlive());
        thread.interrupt(); // Clean up
    }

    @Test
    public void testProcessSnapshotPreviousCat() throws Exception {
        Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
        assetWiseMap.put("NONE", new HashMap<String, String>() {{
            put("Jurisdiction", "Jurisdiction");
            put("Flow", "Flow");
            put("previousDayCAT", "100");
            put("previousDayReportable", "200");
        }});
        List<Map<String, String>> result = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "processSnapshotPreviousCat", assetWiseMap, "CAT Previous Day");
        assertEquals(1, result.size());
        assertEquals("CAT Previous Day", result.get(0).get("Metrics"));
        assertEquals("100", result.get(0).get("Record Count"));
        assertEquals("50.0%", result.get(0).get("Percent"));
    }

    @Test
    public void testProcessSnapshotMetric() throws Exception {
        Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
        assetWiseMap.put("NONE", new HashMap<String, String>() {{
            put("Jurisdiction", "Jurisdiction");
            put("Flow", "Flow");
            put("Reportable", "200");
            put("CAT", "100");
        }});
        List<Map<String, String>> result = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "processSnapshotMetric", assetWiseMap, "CAT", "Reportable");
        assertEquals(1, result.size());
        assertEquals("CAT", result.get(0).get("Metrics"));
        assertEquals("100", result.get(0).get("Record Count"));
        assertEquals("50.0%", result.get(0).get("Percent"));
    }

    @Test
    public void testProcessKnownUnknownMetric() throws Exception {
        Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
        assetWiseMap.put("NONE", new HashMap<String, String>() {{
            put("Jurisdiction", "Jurisdiction");
            put("Flow", "Flow");
            put("Reportable", "200");
            put("misReportedKnown", "10");
            put("misReportedUnKnown", "20");
        }});
        List<Map<String, String>> result = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "processKnownUnknownMetric", assetWiseMap, "Mis-reported", "Reportable", "misReported");
        assertEquals(1, result.size());
        assertEquals("Mis-reported", result.get(0).get("Metrics"));
        assertEquals("30", result.get(0).get("Record Count"));
        assertEquals("15.0%", result.get(0).get("Percent"));
    }

    @Test
    public void testGetTotalFromMap() throws Exception {
        Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
        assetWiseMap.put("FX", Collections.singletonMap("fieldcontainerexpectedCount", "10"));
        assetWiseMap.put("Rates", Collections.singletonMap("expectedCount", "20"));
        List<String> assetClasses = Lists.newArrayList("FX", "Rates");
        int total = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getTotalFromMap", assetWiseMap, "expectedCount", assetClasses);
        assertEquals(30, total);
    }

    @Test
    public void testGetPercentMetric() throws Exception {
        String percent = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getPercentMetric", "10", 100);
        assertEquals("10.0", percent);
    }

    @Test
    public void testGetOverReportedPercent() throws Exception {
        String percent = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getOverReportedPercent", "10.0", 10, 100);
        assertEquals("1.0", percent);
    }

    @Test
    public void testGetRecordMap() throws Exception {
        Map<String, String> csvRecordMap = new HashMap<>();
        csvRecordMap.put("key", "value");
        Map<String, String> recordMap = (Map<String, String>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getRecordMap", csvRecordMap);
        assertEquals(csvRecordMap, recordMap);
    }

    @Test
    public void testGetCsvRecordMap() throws Exception {
        Map<String, String> csvRecordMap = (Map<String, String>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getCsvRecordMap", "Jurisdiction", "Flow");
        assertEquals("Jurisdiction", csvRecordMap.get("Jurisdiction"));
        assertEquals("Flow", csvRecordMap.get("Flow"));
    }

    @Test
    public void testPopulateBifurcationKey() throws Exception {
        Map<String, String> knownMap = new HashMap<>();
        knownMap.put("Asset Class Final", "FX");
        knownMap.put("Execution Entity Final", "Entity1");
        knownMap.put("Delegated", "Yes");
        knownMap.put("Regulator", "Reg1");
        knownMap.put("Message Type", "Type1");
        String key = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateBifurcationKey", "JIRA-1", knownMap);
        assertEquals("JIRA-1FXEntity1YesReg1Type1", key);
    }

    @Test
    public void testPopulateDynamicDate() throws Exception {
        String clause = "nonReportableData.tntrReceivedTimestamp >= {T-3}";
        String updatedClause = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateDynamicDate", clause);
        String expectedDate = "'" + dateTimeService.asString(dateTimeService.getPastDateTime(dateTimeService.getCurrentStartDateTime(dateTimeService.getCurrentUTCDateTime()), 3)) + "'";
        assertTrue(updatedClause.contains(expectedDate));
    }

    @Test
    public void testResumeInQueueScans() throws Exception {
        DfExportScan scan = createScan("scanId", "Collection", "user");
        scan.setExecutionStatus("IN QUEUE");
        Mockito.when(exportRepo.fetchScansWithStatus("IN QUEUE")).thenReturn(Lists.newArrayList(scan));
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "resumeInQueueScans");
        Mockito.verify(exportRepo).fetchScansWithStatus("IN QUEUE");
    }

    @Test
    public void testResumeInQueueScansAtStartup() {
        DfExportScan scan = createScan("scanId", "Transaction", "testUser");
        scan.setExecutionStatus("IN QUEUE");
        Mockito.when(exportRepo.fetchScansWithStatus("IN QUEUE")).thenReturn(Lists.newArrayList(scan));
        Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "resumeInQueueScansAtStartup");
        Mockito.verify(exportRepo).fetchScansWithStatus("IN QUEUE");
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testPopulateNextRunDate_ParseException() {
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateNextRunDate", "invalid_time");
    }

    @Test
    public void testFetchCsvRecords_EmptyHeaders() {
        Set<String> headers = new TreeSet<>();
        try {
            ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "fetchCsvRecords", Lists.newArrayList(), headers, false);
            fail("Expected ValidationException");
        } catch (Exception e) {
            assertTrue(e.getCause() instanceof ValidationException);
        }
    }

    @Test
    public void testGetAssetClassCsvName() {
        assertEquals("Rates", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "InterestRate"));
        assertEquals("Credit", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "Credit"));
        assertEquals("Bonds", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "Bonds"));
        assertEquals("ETD", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "ETD"));
        assertEquals("SFT", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "SFT"));
    }

    @Test
    public void testBifurcateKnownRecords() {
        Map<String, String> record1 = new HashMap<>();
        record1.put("Jira", "JIRA-1,JIRA-2");
        record1.put("Asset Class Final", "FX");
        record1.put("Execution Entity Final", "Entity1");
        record1.put("Delegated", "Yes");
        record1.put("Regulator", "Reg1");
        record1.put("Message Type", "Type1");
        record1.put("Count", "10");
        List<Map<String, String>> parsedRecordsList = Lists.newArrayList(record1);
        List<Map<String, String>> bifurcatedList = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "bifurcateKnownRecords", parsedRecordsList);
        assertEquals(2, bifurcatedList.size());
    }

    private PagedScanResult getPagedScan(boolean isFinalPage) {
        return new PagedScanResult(getMockRecords(getJsonRecords()), isFinalPage, "scanId", 1);
    }

    private ScanResult getMockScanResult(List<Record> records) {
        return new ScanResult() {
            @Override
            public AsOf getAsOf() {
                return null;
            }

            @Override
            public String getCommandId() {
                return null;
            }

            @Override
            public ExplainPlan getExplainPlan() {
                return null;
            }

            @Override
            public void close() {
            }

            @Override
            public Iterator<Record> iterator() {
                return records.iterator();
            }
        };
    }

    private List<Record> getMockRecords(List<String> jsonRecords) {
        List<Record> records = Lists.newArrayList();
        for (String jsonRecord : jsonRecords) {
            Record record = new Record();
            RecordId recordId = new RecordId();
            recordId.setDatabaseName("Tntr");
            recordId.setCollectionName("TNTR-trade-uat");
            record.setId(recordId);
            record.setDocument((new JsonDocument()).withContents(jsonRecord));
            records.add(record);
        }
        return records;
    }

    private List<String> getJsonRecords() {
        List<String> jsonRecords = Lists.newArrayList();
        jsonRecords.add(
                "{\n  \"subjectIdentifier\": {\n    \"transactionId\": \"134783067\",\n    \"sourceSystem\": \"GDS GBLO\",\n    \"version\": 2,\n    \"regulatoryRegimeIdentifier\": {\n      \"name\": \"European Markets Infrastructure Regulation\",\n      \"regulatoryAuthority\": \"Financial Conduct Authority (UK)\"\n    },\n    \"regimeImpactType\": \"Transaction Reporting\",\n    \"reportTriggerType\": \"Transaction Lifecycle\",\n    \"reportSubmissionType\": \"Snapshot\"\n  },\n  \"exceptionManagement\": {\n    \"userComments\": [\n      \"Test\",\n      \"Need to replay\"\n    ],\n    \"issueTypes\": [\n      \"Mis Reporting\"\n    ],\n    \"approvalStatus\": \"Replay Approved\",\n    \"assignedTo\": \"sharnin\",\n    \"approvedBy\": \"sharnin\",\n    \"lastActionUser\": \"sharnin\",\n    \"lastActionDate\": \"2021-09-10T13:09:40.053Z\",\n    \"lastAction\": \"TntrRequestReplay\"\n  },\n  \"transactionReportingStatus\": {\n    \"sourceSystemIdentifier\": \"TnTR\",\n    \"transactionStateValue\": \"Acknowledged\",\n    \"stateTransitionDateTime\": \"2021-09-10T12:12:07.902Z\",\n    \"stateTransitionEffectiveDateTime\": \"2021-09-10T12:12:07.902Z\",\n    \"reportSubmissionRepository\": \"DTCCEU\"\n  },\n  \"reportableData\": {\n    \"action\": \"New\",\n    \"clearingStatus\": \"false\",\n    \"confirmationMethod\": \"NotConfirmed\",\n    \"compressedTradeIndicator\": \"true\",\n    \"contractType\": \"SW\",\n    \"effectiveDate1\": \"2021-09-13T00:00:00.000Z\",\n    \"executionVenueId\": \"XXXX\",\n    \"executionVenueMicCode\": \"XXXX\",\n    \"intraGroupIndicator\": \"false\",\n    \"maturityDate\": \"2026-09-13T00:00:00.000Z\",\n    \"leg2SettlementCurr\": \"USD\",\n    \"level\": \"T\",\n    \"lifecycleEvent\": \"Trade\",\n    \"mandatoryClearingJustification\": \"false\",\n    \"messageId\": \"134783067_0_POU_1631275924038_uat\",\n    \"messageType\": \"Snapshot\",\n    \"notionalAmount1\": 100000000,\n    \"notionalCurr1\": \"GBP\",\n    \"notionalCurr2\": \"USD\",\n    \"originalExecutionTimestamp\": \"2021-09-09T06:11:43.000Z\",\n    \"payment1FreqPeriod\": \"M\",\n    \"payment1FreqPeriodMultiplier\": 3,\n    \"terminationDate\": \"2021-09-09T00:00:00.000Z\",\n    \"price1Price\": 1.18049739,\n    \"price1Units\": \"YIELD\",\n    \"priceMultiplier\": 1,\n    \"assetClass\": \"InterestRate\",\n    \"productClassification\": \"SRACCP\",\n    \"productClassificationType\": \"http://www.fpml.org/coding-scheme/external/product-classification/iso10962\",\n    \"productId\": \"InterestRate:CrossCurrency:Basis\",\n    \"productIdType\": \"ISDA\",\n    \"productIdentification\": \"EZP67QKWJQR7\",\n    \"productIdentificationType\": \"http://www.fpml.org/spec/2002/instrument-id-ISIN\",\n    \"quantity\": 1,\n    \"reportingTimestamp\": \"2021-09-10T12:12:04.000Z\",\n    \"resetFreqPeriod1\": \"M\",\n    \"resetFreqPeriodMultiplier1\": 3,\n    \"scheduledTerminationDate1\": \"2026-09-13T00:00:00.000Z\",\n    \"settlementCurr1\": \"GBP\",\n    \"settlementDate\": \"2021-10-10T00:00:00.000Z\",\n    \"settlementType\": \"Cash\",\n    \"submittedFor\": \"Party1\",\n    \"submittingPartyId\": \"549300ZD5KE1EACJTY62\",\n    \"submittingPartyIdType\": \"LEI\",\n    \"tradeParty1NatureOfReportingCpty\": \"F\",\n    \"tradeParty1BeneficiaryId\": \"RR3QWICWWIPCS8A4S074\",\n    \"tradeParty1BeneficiaryIdType\": \"LEI\",\n    \"tradeParty1CorporateSectorType\": \"C\",\n    \"tradeParty1CptySide\": \"S\",\n    \"tradeParty1CountryOfOtherCpty\": \"GB\",\n    \"tradeParty1Id\": \"549300ZD5KE1EACJTY62\",\n    \"tradeParty1IdType\": \"LEI\",\n    \"reportableActionTypeParty1\": \"N\",\n    \"tradeParty1RepDest\": \"FCA\",\n    \"tradeParty1TradingCapacity1\": \"Principal\",\n    \"tradeParty1TransactionId\": \"GDSGBLO134783067\",\n    \"tradeParty2ClearingThreshold\": \"false\",\n    \"tradeParty2CountryOfOtherCpty\": \"CA\",\n    \"tradeParty2Id\": \"75LI66N60BF3QJ2FAR78\",\n    \"tradeParty2Type\": \"LEI\",\n    \"repActionTypeParty2\": \"N\",\n    \"underlyingIdentificationType\": \"http://www.dtcc.com/coding-scheme/external/underlying-id/ISIN\",\n    \"utiId\": \"IR123134783067TNTRuat\",\n    \"utiIdPrefix\": \"1030272448\",\n    \"originalActionTypeParty1\": \"N\",\n    \"leg1FloatingRateIndex\": \"LIBO\",\n    \"leg1FloatingRateTenorPeriod\": \"M\",\n    \"leg1FloatingRateTenorPeriodMultiplier\": 3,\n    \"leg2EffectiveDate\": \"2021-09-13T00:00:00.000Z\",\n    \"leg2FloatingRateIndex\": \"LIBO\",\n    \"leg2FloatingRateTenorPeriod\": \"M\",\n    \"leg2FloatingRateTenorPeriodMultiplier\": 3,\n    \"leg2ResetFrequencyPeriod\": \"M\",\n    \"leg2ResetFrequencyPeriodMultiplier\": 3,\n    \"payment1Date\": \"2021-10-10T00:00:00.000Z\",\n    \"payment2FrequencyPeriodMultiplier\": 3,\n    \"payment2FrequencyPeriod\": \"M\",\n    \"collateralizedFlag\": \"ONEWAY\"\n  },\n  \"nonReportableData\": {\n    \"party1Ciscode\": \"WBUG0G\",\n    \"party2Ciscode\": \"F1711CA\",\n    \"party1NucId\": 92001,\n    \"party2NucId\": 2289043,\n    \"opsBusinessArea\": \"Balance Guaranteed\",\n    \"recordType\": \"House trade\",\n    \"tntrReceivedTimestamp\": \"2021-09-10T12:12:02.805Z\",\n    \"tradeParty2Name\": \"PIMCO RE 1711 PIMCO CAN COREPLUS BD\",\n    \"tradeParty1Name\": \"NWM PLC TRADING\",\n    \"isDelegated\": false,\n    \"tradeVersion\": 0,\n    \"eventExecutionTimestamp\": \"2021-09-09T06:11:43.256Z\"\n  },\n    \"totalCount\": 10,\n  \"appendix\": {}\n}");
        return jsonRecords;
    }

    private DfScanParameters createParam(String collectionName) {
        return new DfScanParameters("", "", "", "", collectionName, false, "blotterName");
    }

    private DfExportScan createScan(String scanId, String collectionName, String userId) {
        DfExportScan scan = new DfExportScan();
        scan.setScanId(scanId);
        scan.setBlotterName("blotterUI");
        scan.setCollectionName(collectionName);
        scan.setRequestedUserId(userId);
        scan.setExportFileFormat(StringConstants.CSV);
        scan.setScheduled(true);
        scan.setScheduledTime("8:30 AM");
        scan.setScheduleFrequency("WEEKLY");
        return scan;
    }

    private DfExportScan createExcelScan() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("scanId");
        scan.setBlotterName("blotterUI");
        scan.setCollectionName("Transaction");
        scan.setRequestedUserId("userId");
        scan.setExportFileFormat(StringConstants.EXCEL);
        scan.setScheduled(true);
        scan.setScheduledTime("8:30 AM");
        scan.setScheduleFrequency("DAILY");
        return scan;
    }

    private Set<String> createHeaders() {
        return Sets.newHashSet("header1", "header2", "header3", "Asset Class Final");
    }

    private List<Map<String, String>> fetchRecordList() {
        Map<String, String> dataMap = new HashMap<>();
        dataMap.put("header1", "data1");
        dataMap.put("header2", "data2");
        dataMap.put("Asset Class Final", "Fx");
        dataMap.put("assetClass", "SFT");
        dataMap.put("Execution Entity Final", "Test");
        dataMap.put("Delegated", "Delegated");
        dataMap.put("Regulator", "Emir");
        dataMap.put("Message Type", "Acknowledged");
        List<Map<String, String>> recordList = Lists.newArrayList();
        recordList.add(dataMap);
        return recordList;
    }

    private List<Map<String, String>> fetchRecordList_For_Snapshot(String inputStr) throws JsonProcessingException {
        List<Map<String, String>> recordList = new ArrayList<>();
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> jsonMap = mapper.readValue(inputStr, Map.class);
        Map<String, String> stringMap = new HashMap<>();

        for (Map.Entry<String, Object> entry : jsonMap.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value instanceof Map) {
                stringMap.put(key, mapper.writeValueAsString(value));
            } else {
                stringMap.put(key, String.valueOf(value));
            }
        }
        recordList.add(stringMap);

        return recordList;
    }

    private RecordId getRecordId(DfExportScan scan) {
        RecordId recordId = new RecordId();
        recordId.setCollectionName(scan.getCollectionName());
        recordId.setKey(scan.getScanId());
        return recordId;
    }

    private ScanRequestBuilder getScanRequestBuilder() {
        return ScanRequestBuilder.create(
                new ScanExpression().withDatabaseName("Tntr").withCollectionName("TNTR-trade-uat"));
    }
}
