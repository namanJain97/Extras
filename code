package com.rbs.tntr.business.taggingService.df;

import com.nwm.tntr.commons.domain.persistence.entity.recon.ReconReport;
import com.nwm.tntr.commons.domain.persistence.entity.recon.ReconReportDocument;
import com.nwm.tntr.commons.domain.persistence.request.QueryParams;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.nwm.tntr.commons.repository.regreporting.recon.ReconReportDocumentRepository;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(SpringRunner.class)
@SpringBootTest
public class DfReconciliationPersistManagerTest {

    @Mock
    private ReconReportDocumentRepository repository;

    private DfReconciliationPersistManager manager;

    private final int batchSize = 2;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        manager = new DfReconciliationPersistManager(repository, batchSize);
    }

    @Test
    public void testGetAllRecords_Success() {
        QueryParams params = new QueryParams();
        List<ReconReportDocument> mockList = Arrays.asList(new ReconReportDocument(), new ReconReportDocument());

        when(repository.findAllByQuery(params)).thenReturn(mockList);

        List<ReconReportDocument> result = manager.getAllRecords(params);

        assertEquals(2, result.size());
        verify(repository, times(1)).findAllByQuery(params);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testGetAllRecords_Exception() {
        QueryParams params = new QueryParams();

        when(repository.findAllByQuery(params)).thenThrow(new RuntimeException("DB Error"));

        manager.getAllRecords(params);
    }

    @Test
    public void testSaveAllRecords_Success() {
        Pair<ReconReport, Long> pair1 = Pair.of(new ReconReport(), 1L);
        Pair<ReconReport, Long> pair2 = Pair.of(new ReconReport(), 1L);
        List<Pair<ReconReport, Long>> input = Arrays.asList(pair1, pair2);

        WriteResult<ReconReport> successResult = mock(WriteResult.class);
        when(successResult.isSuccess()).thenReturn(true);
        when(successResult.isFailure()).thenReturn(false);

        when(repository.compareAndUpdateAll(anyList())).thenReturn(Arrays.asList(successResult, successResult));

        List<WriteResult<ReconReport>> result = manager.saveAllRecords(input);

        assertEquals(2, result.size());
        verify(repository, times(1)).compareAndUpdateAll(anyList());
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testSaveAllRecords_Exception() {
        Pair<ReconReport, Long> pair = Pair.of(new ReconReport(), 1L);
        List<Pair<ReconReport, Long>> input = Collections.singletonList(pair);

        when(repository.compareAndUpdateAll(anyList())).thenThrow(new RuntimeException("Update Error"));

        manager.saveAllRecords(input);
    }

    @Test
    public void testSaveAllRecords_FailureLogging() {
        Pair<ReconReport, Long> pair = Pair.of(new ReconReport(), 1L);
        List<Pair<ReconReport, Long>> input = Collections.singletonList(pair);

        WriteResult<ReconReport> failedResult = mock(WriteResult.class);
        when(failedResult.isSuccess()).thenReturn(false);
        when(failedResult.isFailure()).thenReturn(true);

        WriteResult.ErrorDetail errorDetail = new WriteResult.ErrorDetail("Failure", new RuntimeException("Cause"));
        when(failedResult.getErrorDetail()).thenReturn(errorDetail);

        when(repository.compareAndUpdateAll(anyList())).thenReturn(Collections.singletonList(failedResult));

        List<WriteResult<ReconReport>> result = manager.saveAllRecords(input);

        assertEquals(1, result.size());
        verify(repository, times(1)).compareAndUpdateAll(anyList());
    }
}
