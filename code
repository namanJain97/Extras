package com.rbs.tntr.business.taggingService.df;

import com.nwm.tntr.commons.domain.persistence.entity.recon.ReconReport;
import com.nwm.tntr.commons.domain.persistence.entity.recon.ReconReportDocument;
import com.nwm.tntr.commons.domain.persistence.request.QueryParams;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.nwm.tntr.commons.repository.regreporting.recon.ReconReportDocumentRepository;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(SpringRunner.class)
@SpringBootTest
public class DfReconciliationPersistManagerTest {

    @Mock
    private ReconReportDocumentRepository repository;

    @Mock
    private QueryParams mockQueryParams;

    @Mock
    private ReconReportDocument mockDocument;

    @Mock
    private ReconReport mockReport;

    private DfReconciliationPersistManager manager;

    private final int batchSize = 2;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        manager = new DfReconciliationPersistManager(repository, batchSize);
    }

    @Test
    public void testGetAllRecords_Success() {
        List<ReconReportDocument> mockList = Arrays.asList(mockDocument, mockDocument);

        when(repository.findAllByQuery(mockQueryParams)).thenReturn(mockList);

        List<ReconReportDocument> result = manager.getAllRecords(mockQueryParams);

        assertEquals(2, result.size());
        verify(repository, times(1)).findAllByQuery(mockQueryParams);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testGetAllRecords_Exception() {
        when(repository.findAllByQuery(mockQueryParams)).thenThrow(new RuntimeException("DB Error"));

        manager.getAllRecords(mockQueryParams);
    }

    @Test
    public void testSaveAllRecords_Success() {
        Pair<ReconReport, Long> pair1 = Pair.of(mockReport, 1L);
        Pair<ReconReport, Long> pair2 = Pair.of(mockReport, 1L);
        List<Pair<ReconReport, Long>> input = Arrays.asList(pair1, pair2);

        WriteResult<ReconReport> successResult = mock(WriteResult.class);
        when(successResult.isSuccess()).thenReturn(true);
        when(successResult.isFailure()).thenReturn(false);

        when(repository.compareAndUpdateAll(anyList())).thenReturn(Arrays.asList(successResult, successResult));

        List<WriteResult<ReconReport>> result = manager.saveAllRecords(input);

        assertEquals(2, result.size());
        verify(repository, times(1)).compareAndUpdateAll(anyList());
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testSaveAllRecords_Exception() {
        Pair<ReconReport, Long> pair = Pair.of(mockReport, 1L);
        List<Pair<ReconReport, Long>> input = Collections.singletonList(pair);

        when(repository.compareAndUpdateAll(anyList())).thenThrow(new RuntimeException("Update Error"));

        manager.saveAllRecords(input);
    }

    @Test
    public void testSaveAllRecords_FailureLogging() {
        Pair<ReconReport, Long> pair = Pair.of(mockReport, 1L);
        List<Pair<ReconReport, Long>> input = Collections.singletonList(pair);

        WriteResult<ReconReport> failedResult = mock(WriteResult.class);
        when(failedResult.isSuccess()).thenReturn(false);
        when(failedResult.isFailure()).thenReturn(true);

        WriteResult.ErrorDetail errorDetail = mock(WriteResult.ErrorDetail.class);
        when(errorDetail.getDescription()).thenReturn("Failure Description");
        when(errorDetail.getCause()).thenReturn(new RuntimeException("Failure Cause"));

        when(failedResult.getErrorDetail()).thenReturn(errorDetail);
        when(repository.compareAndUpdateAll(anyList())).thenReturn(Collections.singletonList(failedResult));

        List<WriteResult<ReconReport>> result = manager.saveAllRecords(input);

        assertEquals(1, result.size());
        verify(repository, times(1)).compareAndUpdateAll(anyList());
    }
}
