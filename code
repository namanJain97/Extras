package com.rbs.tntr.business.blotter.services.validators;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.ApprovalStatus;
import com.nwm.tntr.commons.domain.persistence.constant.ReportingRegime;
import com.nwm.tntr.commons.domain.persistence.constant.SourceSystemId;
import com.nwm.tntr.commons.domain.persistence.constant.TransactionStateValue;
import com.nwm.tntr.commons.domain.persistence.entity.ExceptionManagement;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReport;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReportId;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportId;
import com.nwm.tntr.commons.domain.persistence.entity.valuation.ValuationReport;
import com.nwm.tntr.commons.domain.persistence.entity.valuation.ValuationReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.valuation.ValuationReportId;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.PagedScanResult;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.tntr.business.blotter.search.querybuilder.DfScanParameters;
import com.rbs.tntr.business.blotter.services.actions.ActionDocumentId;
import com.rbs.tntr.business.blotter.services.actions.ActionUpdateResult;
import com.rbs.tntr.business.blotter.utility.DataFabricExportUtility;
import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import com.rbs.tntr.domain.blotter.enums.CRAction;
import com.rbs.tntr.domain.blotter.enums.ExceptionStatus;
import com.rbs.tntr.domain.blotter.enums.FlowType;
import com.rbs.tntr.domain.blotter.enums.WorkflowAction;
import com.rbs.tntr.domain.blotter.exceptions.ValidationException;
import com.rbs.tntr.domain.blotter.tntrBlotterView.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.IOException;
import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class ActionRequestValidatorTest {

    @InjectMocks
    private ActionRequestValidator actionRequestValidator;

    @Mock
    private CommonValidator commonValidator;

    @Mock
    private DataFabricExportUtility dataFabricExportUtil;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    // Existing test methods

    @Test(expected = ValidationException.class)
    public void testValidateWorkflowRequests_NullRequest_ShouldThrowValidationException() {
        ExceptionStatus exceptionStatus = ExceptionStatus.Edit_Approved;
        actionRequestValidator.validateWorkflowRequests(null, exceptionStatus);
    }

    @Test(expected = ValidationException.class)
    public void testValidateAddTradeCommentRequests_InvalidRequest() {
        AddTradeCommentRequest request = mock(AddTradeCommentRequest.class);
        when(request.getComment()).thenReturn(null);

        actionRequestValidator.validateAddTradeCommentRequests(Collections.singletonList(request));

        verify(commonValidator).validateComment(null);
    }

    @Test(expected = ValidationException.class)
    public void testValidateAssignRequests_InvalidRequest() {
        AssignTradeRequest request = mock(AssignTradeRequest.class);
        when(request.getAssignTo()).thenReturn(null);

        actionRequestValidator.validateAssignReqeusts(Collections.singletonList(request));
        verify(commonValidator).validateAssignTo(null);
    }

    @Test(expected = ValidationException.class)
    public void testValidateBackdatedTrades_WithInvalidFlow() {
        List<ReplayValuationForBusinessDate> requests = Collections.singletonList(mock(ReplayValuationForBusinessDate.class));
        when(requests.get(0).getFlow()).thenReturn("InvalidFlow");

        actionRequestValidator.validateBackdatedTrades(requests);
    }

    @Test(expected = ValidationException.class)
    public void testValidateCRTradeRequest_InvalidIssueType() {
        CorrectiveReportingForTrade request = mock(CorrectiveReportingForTrade.class);
        when(request.getIssueType()).thenReturn("InvalidType");

        actionRequestValidator.validateCRTradeRequests(Collections.singletonList(request));
    }

    // New test methods for 100% coverage

    /** Tests for validateWorkflowRequests - Valid scenario */
    @Test
    public void testValidateWorkflowRequests_ValidRequest() {
        UpdateExceptionStatusRequest request = mock(UpdateExceptionStatusRequest.class);
        when(request.getAction()).thenReturn(WorkflowAction.RequestCloseException.getValue());
        UserComment comment = mock(UserComment.class);
        when(request.getComment()).thenReturn(comment);
        when(request.getApprovalRequired()).thenReturn("false");
        when(request.getApprovedBy()).thenReturn("approver");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateWorkflowAction(anyString());
        doNothing().when(commonValidator).validateComment(any(UserComment.class));
        doNothing().when(commonValidator).validateApprover(anyString());

        actionRequestValidator.validateWorkflowRequests(Collections.singletonList(request), ExceptionStatus.Open);

        verify(commonValidator).validateWorkflowAction(WorkflowAction.RequestCloseException.getValue());
        verify(commonValidator).validateComment(comment);
        verify(commonValidator).validateApprover("approver");
    }

    /** Tests for validateResetActionRequests - Valid scenario */
    @Test
    public void testValidateResetActionRequests_ValidRequest() {
        UpdateExceptionStatusRequest request = mock(UpdateExceptionStatusRequest.class);
        UserComment comment = mock(UserComment.class);
        when(request.getComment()).thenReturn(comment);
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateComment(any(UserComment.class));

        actionRequestValidator.validateResetActionRequests(Collections.singletonList(request));

        verify(commonValidator).validateComment(comment);
    }

    /** Tests for validateAddTradeCommentRequests - Valid scenario */
    @Test
    public void testValidateAddTradeCommentRequests_ValidRequest() {
        AddTradeCommentRequest request = mock(AddTradeCommentRequest.class);
        UserComment comment = mock(UserComment.class);
        when(request.getComment()).thenReturn(comment);
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateComment(any(UserComment.class));

        actionRequestValidator.validateAddTradeCommentRequests(Collections.singletonList(request));

        verify(commonValidator).validateComment(comment);
    }

    /** Tests for validateRemoveTradeCommentRequests - Valid scenario */
    @Test
    public void testValidateRemoveTradeCommentRequests_ValidRequest() {
        AddTradeCommentRequest request = mock(AddTradeCommentRequest.class);
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        actionRequestValidator.validateRemoveTradeCommentRequests(Collections.singletonList(request));
        // No specific validations to verify, just ensure no exception
    }

    /** Tests for validateAssignReqeusts - Valid scenario */
    @Test
    public void testValidateAssignReqeusts_ValidRequest() {
        AssignTradeRequest request = mock(AssignTradeRequest.class);
        when(request.getAssignTo()).thenReturn("assignee");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateAssignTo(anyString());

        actionRequestValidator.validateAssignReqeusts(Collections.singletonList(request));

        verify(commonValidator).validateAssignTo("assignee");
    }

    /** Tests for validateAddJiraReferenceReqeusts - Valid scenario */
    @Test
    public void testValidateAddJiraReferenceReqeusts_ValidRequest() {
        AddTradeJiraReferenceRequest request = mock(AddTradeJiraReferenceRequest.class);
        when(request.getJiraReference()).thenReturn("JIRA-123");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateJiraReference(anyString());

        actionRequestValidator.validateAddJiraReferenceReqeusts(Collections.singletonList(request));

        verify(commonValidator).validateJiraReference("JIRA-123");
    }

    /** Tests for validateAddJiraTypeReqeusts - Valid scenario */
    @Test
    public void testValidateAddJiraTypeReqeusts_ValidRequest() {
        AddTradeJiraTypeRequest request = mock(AddTradeJiraTypeRequest.class);
        JiraType jiraType = mock(JiraType.class);
        when(request.getJiraType()).thenReturn(jiraType);
        when(jiraType.getIssueType()).thenReturn("Bug");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateJiraType(anyString());

        actionRequestValidator.validateAddJiraTypeReqeusts(Collections.singletonList(request));

        verify(commonValidator).validateJiraType("Bug");
    }

    /** Tests for validateEditReqeusts - Valid scenario */
    @Test
    public void testValidateEditReqeusts_ValidRequest() {
        EditRequest request = mock(EditRequest.class);
        when(request.getAction()).thenReturn(WorkflowAction.RequestEdit.getValue());
        when(request.getApprovalRequired()).thenReturn("false");
        ExceptionManagementData data = mock(ExceptionManagementData.class);
        UserComment comment = mock(UserComment.class);
        when(request.getExceptionManagementData()).thenReturn(data);
        when(data.getComment()).thenReturn(comment);
        when(data.getApprovedBy()).thenReturn("approver");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateEditComment(any(UserComment.class));
        doNothing().when(commonValidator).validateApprover(anyString());

        actionRequestValidator.validateEditReqeusts(Collections.singletonList(request));

        verify(commonValidator).validateEditComment(comment);
        verify(commonValidator).validateApprover("approver");
    }

    /** Tests for validateBackdatedTrades - Valid scenario */
    @Test
    public void testValidateBackdatedTrades_ValidRequest() {
        ReplayValuationForBusinessDate request = mock(ReplayValuationForBusinessDate.class);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());
        when(request.getValuationDate()).thenReturn("2023-01-01");

        doNothing().when(commonValidator).validateValDate(anyString());

        actionRequestValidator.validateBackdatedTrades(Collections.singletonList(request));

        verify(commonValidator).validateValDate("2023-01-01");
    }

    /** Tests for validateBackdatedTradesByDateRange - Valid scenario */
    @Test
    public void testValidateBackdatedTradesByDateRange_ValidRequest() {
        ReplayValuationForDateRange request = mock(ReplayValuationForDateRange.class);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());
        when(request.getValuationDateFrom()).thenReturn("2023-01-01");
        when(request.getValuationDateTo()).thenReturn("2023-01-02");

        doNothing().when(commonValidator).validateValDate(anyString());

        actionRequestValidator.validateBackdatedTradesByDateRange(Collections.singletonList(request));

        verify(commonValidator).validateValDate("2023-01-01");
        verify(commonValidator).validateValDate("2023-01-02");
    }

    /** Tests for validateBackdatedColyDateRange - Valid scenario */
    @Test
    public void testValidateBackdatedColyDateRange_ValidRequest() {
        ReplayCollateralForDateRange request = mock(ReplayCollateralForDateRange.class);
        when(request.getEntity()).thenReturn("Entity");
        when(request.getReportSubmissionType()).thenReturn("Type");
        when(request.getStartDate()).thenReturn("2023-01-01");
        when(request.getEndDate()).thenReturn("2023-01-02");

        doNothing().when(commonValidator).validateVal  void validateBackdatedColyDateRange(List<ReplayCollateralForDateRange> requests) {
        try {
            if (requests.stream().allMatch(request -> request.getEntity() == null || StringUtils.isBlank(request.getEntity())))
                throw new ValidationException(ENTITY_IS_NULL_ERROR);
            if (requests.stream().allMatch(request -> request.getReportSubmissionType() == null || StringUtils.isBlank(request.getReportSubmissionType())))
                throw new ValidationException(REPORT_TYPE_IS_NULL_ERROR);
            String startDate = requests.get(0).getStartDate();
            commonValidator.validateValDate(startDate);
            if (!requests.stream().map(ReplayCollateralForDateRange::getStartDate).allMatch(startDate::equals)) {
                throw new ValidationException(ValidatorConstants.VALUATION_DATE_MULTIPLE_VALUES);
            }
            String endDate = requests.get(0).getEndDate();
            commonValidator.validateValDate(endDate);
            if (!requests.stream().map(ReplayCollateralForDateRange::getEndDate).allMatch(endDate::equals)) {
                throw new ValidationException(ValidatorConstants.VALUATION_DATE_MULTIPLE_VALUES);
            }
        } catch (Exception ex) {
            throw new ValidationException(ex.getMessage(), ex);
        }
    }

    doNothing().when(commonValidator).validateValDate(anyString());

        actionRequestValidator.validateBackdatedColyDateRange(Collections.singletonList(request));

        verify(commonValidator).validateValDate("2023-01-01");
        verify(commonValidator).validateValDate("2023-01-02");
    }

    /** Tests for validateCRTradeRequests - Valid scenario */
    @Test
    public void testValidateCRTradeRequests_ValidRequest() {
        CorrectiveReportingForTrade request = mock(CorrectiveReportingForTrade.class);
        when(request.getIssueType()).thenReturn("Mis Reporting");

        actionRequestValidator.validateCRTradeRequests(Collections.singletonList(request));
        // No exception expected
    }

    /** Tests for validateCRValRequests - Valid scenario */
    @Test
    public void testValidateCRValRequests_ValidRequest() {
        CorrectiveReportingForValuation request = mock(CorrectiveReportingForValuation.class);
        PrimaryKey pk = mock(PrimaryKey.class);
        when(request.getPrimaryKey()).thenReturn(pk);
        when(pk.getSourceSystem()).thenReturn("ValidSystem");
        when(request.getDataFetchFrom()).thenReturn("CMG");
        when(pk.getAction()).thenReturn(CRAction.CR_VALUATION_DATE_RANGE);
        when(request.getValuationDateFrom()).thenReturn("2023-01-01");
        when(request.getValuationDateTo()).thenReturn("2023-01-02");

        doNothing().when(commonValidator).validateValDate(anyString());

        actionRequestValidator.validateCRValRequests(Collections.singletonList(request));

        verify(commonValidator).validateValDate("2023-01-01");
        verify(commonValidator).validateValDate("2023-01-02");
    }

    /** Tests for validateCRColRequests - Valid scenario */
    @Test
    public void testValidateCRColRequests_ValidRequest() {
        CorrectiveReportingForCollateral request = mock(CorrectiveReportingForCollateral.class);
        CorrectiveReportingForTrade pk = mock(CorrectiveReportingForTrade.class);
        when(request.getPrimaryKey()).thenReturn(pk);
        when(pk.getIssueType()).thenReturn("Mis Reporting");
        when(pk.getAction()).thenReturn(CRAction.CR_COLLATERAL_DATE_RANGE);
        when(request.getCollateralDateFrom()).thenReturn("2023-01-01");
        when(request.getCollateralDateTo()).thenReturn("2023-01-02");
        when(request.getOverrideFields()).thenReturn("fields");

        doNothing().when(commonValidator).validateValDate(anyString());
        doNothing().when(commonValidator).validateDateDifference(anyString(), anyString(), anyInt());

        actionRequestValidator.validateCRColRequests(Collections.singletonList(request));

        verify(commonValidator).validateValDate("2023-01-01");
        verify(commonValidator).validateValDate("2023-01-02");
        verify(commonValidator).validateDateDifference("2023-01-01", "2023-01-02", 90);
    }

    /** Tests for validateUserActionType - Valid scenario */
    @Test
    public void testValidateUserActionType_ValidRequest() {
        UpdateUserActionTypeRequest request = mock(UpdateUserActionTypeRequest.class);
        UserComment comment = mock(UserComment.class);
        when(request.getComment()).thenReturn(comment);
        when(request.getUserActionType()).thenReturn("Type");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateComment(any(UserComment.class));
        doNothing().when(commonValidator).validateEditUserActionType(anyString());

        actionRequestValidator.validateUserActionType(Collections.singletonList(request));

        verify(commonValidator).validateComment(comment);
        verify(commonValidator).validateEditUserActionType("Type");
    }

    /** Tests for validateAddTradeCommentTypeRequests - Valid scenario */
    @Test
    public void testValidateAddTradeCommentTypeRequests_ValidRequest() {
        AddTradeCommentTypeRequest request = mock(AddTradeCommentTypeRequest.class);
        CommentType commentType = mock(CommentType.class);
        when(request.getCommentType()).thenReturn(commentType);
        when(commentType.getUserCommentType()).thenReturn("Type");
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        doNothing().when(commonValidator).validateCommentType(anyString());

        actionRequestValidator.validateAddTradeCommentTypeRequests(Collections.singletonList(request));

        verify(commonValidator).validateCommentType("Type");
    }

    /** Tests for validateRemoveTradeCommentTypeRequests - Valid scenario */
    @Test
    public void testValidateRemoveTradeCommentTypeRequests_ValidRequest() {
        AddTradeCommentTypeRequest request = mock(AddTradeCommentTypeRequest.class);
        when(request.getDocumentId()).thenReturn(mock(ActionDocumentId.class));
        when(request.getDocumentId().getKey()).thenReturn("key");
        when(request.getDocumentId().getVersion()).thenReturn(1L);
        when(request.getFlow()).thenReturn(FlowType.TRANSACTION.getValue());

        actionRequestValidator.validateRemoveTradeCommentTypeRequests(Collections.singletonList(request));
        // No specific validations to verify
    }

    /** Tests for validateMAS755Trades */
    @Test
    public void testValidateMAS755Trades_RestrictedRegime() {
        TradeReportDocument trade = mock(TradeReportDocument.class);
        TradeReport tradeReport = mock(TradeReport.class);
        TradeReportId tradeReportId = mock(TradeReportId.class);
        ActionDocumentId docId = mock(ActionDocumentId.class);
        when(trade.getTradeReport()).thenReturn(tradeReport);
        when(tradeReport.getTradeReportId()).thenReturn(tradeReportId);
        when(tradeReportId.getReportingRegime()).thenReturn(ReportingRegime.THE_MONETARY_AUTHORITY_OF_SINGAPORE_755);
        when(trade.getDocumentId()).thenReturn(docId);
        when(docId.getKey()).thenReturn("key");
        when(docId.getVersion()).thenReturn(1L);

        List<TradeReportDocument> trades = new ArrayList<>(Collections.singletonList(trade));
        List<ActionUpdateResult> writeResults = new ArrayList<>();

        actionRequestValidator.validateMAS755Trades(trades, writeResults);

        assertTrue(trades.isEmpty());
        assertEquals(1, writeResults.size());
        assertTrue(writeResults.get(0).getErrorMessage().contains("Action not applicable for Regulatory : MAS 755"));
    }

    /** Tests for validatePermittedExceptionStatus - Restricted trades */
    @Test
    public void testValidatePermittedExceptionStatus_RestrictedTrades() {
        TradeReportDocument trade = mock(TradeReportDocument.class);
        TradeReport tradeReport = mock(TradeReport.class);
        TradeReportId tradeReportId = mock(TradeReportId.class);
        ActionDocumentId docId = mock(ActionDocumentId.class);
        when(trade.getTradeReport()).thenReturn(tradeReport);
        when(tradeReport.getTradeReportId()).thenReturn(tradeReportId);
        when(tradeReportId.getReportingRegime()).thenReturn(ReportingRegime.THE_MONETARY_AUTHORITY_OF_SINGAPORE_755);
        when(trade.getDocumentId()).thenReturn(docId);
        when(docId.getKey()).thenReturn("key");
        when(docId.getVersion()).thenReturn(1L);

        List<TradeReportDocument> trades = new ArrayList<>(Collections.singletonList(trade));
        List<ActionUpdateResult> writeResults = new ArrayList<>();

        actionRequestValidator.validatePermittedExceptionStatus(trades, writeResults, ExceptionStatus.Open);

        assertTrue(trades.isEmpty());
        assertEquals(1, writeResults.size());
    }

    /** Tests for validatePermittedExceptionStatusForVal - Restricted valuation */
    @Test
    public void testValidatePermittedExceptionStatusForVal_Restricted() {
        ValuationReportDocument valDoc = mock(ValuationReportDocument.class);
        ValuationReport valReport = mock(ValuationReport.class);
        ValuationReportId valReportId = mock(ValuationReportId.class);
        ActionDocumentId docId = mock(ActionDocumentId.class);
        when(valDoc.getValuationReport()).thenReturn(valReport);
        when(valReport.getValuationReportId()).thenReturn(valReportId);
        when(valReportId.getReportingRegime()).thenReturn(ReportingRegime.SECURITIES_FINANCING_TRANSACTION_REGULATION_SELF_REPORTING);
        when(valDoc.getDocumentId()).thenReturn(docId);
        when(docId.getKey()).thenReturn("key");
        when(docId.getVersion()).thenReturn(1L);

        List<ValuationReportDocument> vals = new ArrayList<>(Collections.singletonList(valDoc));
        List<ActionUpdateResult> writeResults = new ArrayList<>();

        actionRequestValidator.validatePermittedExceptionStatusForVal(vals, writeResults, ExceptionStatus.Edit_Approved);

        assertTrue(vals.isEmpty());
        assertEquals(1, writeResults.size());
    }

    /** Tests for validatePermittedExceptionStatusForCol - Restricted collateral */
    @Test
    public void testValidatePermittedExceptionStatusForCol_Restricted() {
        CollateralReportDocument colDoc = mock(CollateralReportDocument.class);
        CollateralReport colReport = mock(CollateralReport.class);
        CollateralReportId colReportId = mock(CollateralReportId.class);
        ActionDocumentId docId = mock(ActionDocumentId.class);
        when(colDoc.getCollateralReport()).thenReturn(colReport);
        when(colReport.getCollateralReportId()).thenReturn(colReportId);
        when(colReportId.getReportingRegime()).thenReturn(ReportingRegime.SECURITIES_FINANCING_TRANSACTION_REGULATION_SELF_REPORTING);
        when(colDoc.getDocumentId()).thenReturn(docId);
        when(docId.getKey()).thenReturn("key");
        when(docId.getVersion()).thenReturn(1L);

        List<CollateralReportDocument> cols = new ArrayList<>(Collections.singletonList(colDoc));
        List<ActionUpdateResult> writeResults = new ArrayList<>();

        actionRequestValidator.validatePermittedExceptionStatusForCol(cols, writeResults, ExceptionStatus.Edit_Approved);

        assertTrue(cols.isEmpty());
        assertEquals(1, writeResults.size());
    }

    /** Tests for validateAckedCancleTrade - Various scenarios */
    @Test
    public void testValidateAckedCancleTrade_ValidCase() {
        boolean result = actionRequestValidator.validateAckedCancleTrade(ExceptionStatus.Cancel_Requested, TransactionStateValue.CANCELLED);
        assertTrue(result);
    }

    @Test
    public void testValidateAckedCancleTrade_InvalidCase() {
        boolean result = actionRequestValidator.validateAckedCancleTrade(ExceptionStatus.Cancel_Requested, TransactionStateValue.ACKNOWLEDGED);
        assertFalse(result);
    }

    /** Tests for validateExceptionStatus(ApprovalStatus) - Various scenarios */
    @Test
    public void testValidateExceptionStatusWithApprovalStatus_NullApproval() {
        boolean result = actionRequestValidator.validateExceptionStatus(ExceptionStatus.Open, null);
        assertTrue(result);
    }

    @Test
    public void testValidateExceptionStatusWithApprovalStatus_ValidCase() {
        boolean result = actionRequestValidator.validateExceptionStatus(ExceptionStatus.Cancel_Approved, ApprovalStatus.CANCEL_REQUESTED);
        assertTrue(result);
    }

    @Test
    public void testValidateExceptionStatusWithApprovalStatus_InvalidCase() {
        boolean result = actionRequestValidator.validateExceptionStatus(ExceptionStatus.Open, ApprovalStatus.CANCEL_REQUESTED);
        assertFalse(result);
    }

    /** Tests for validateResetActionApprovalStatus - Various flows */
    @Test
    public void testValidateResetActionApprovalStatus_TransactionFlow() {
        boolean result = actionRequestValidator.validateResetActionApprovalStatus(ApprovalStatus.DUMMY_AMEND_APPROVED, FlowType.TRANSACTION.getValue());
        assertTrue(result);
    }

    @Test
    public void testValidateResetActionApprovalStatus_ValuationFlow() {
        boolean result = actionRequestValidator.validateResetActionApprovalStatus(ApprovalStatus.REPLAY_APPROVED, FlowType.VALUATION.getValue());
        assertTrue(result);
    }

    @Test
    public void testValidateResetActionApprovalStatus_InvalidCase() {
        boolean result = actionRequestValidator.validateResetActionApprovalStatus(ApprovalStatus.OPEN_REQUESTED, FlowType.TRANSACTION.getValue());
        assertFalse(result);
    }

    /** Tests for validateUser */
    @Test
    public void testValidateUser_MatchingUser() {
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(em.getAssignedTo()).thenReturn("user");
        boolean result = actionRequestValidator.validateUser("user", em);
        assertTrue(result);
    }

    @Test
    public void testValidateUser_NonMatchingUser() {
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(em.getAssignedTo()).thenReturn("user1");
        boolean result = actionRequestValidator.validateUser("user2", em);
        assertFalse(result);
    }

    /** Tests for validateApprovalStatus */
    @Test
    public void testValidateApprovalStatus_Valid() {
        boolean result = actionRequestValidator.validateApprovalStatus(ApprovalStatus.CANCEL_APPROVED);
        assertTrue(result);
    }

    @Test
    public void testValidateApprovalStatus_Invalid() {
        boolean result = actionRequestValidator.validateApprovalStatus(ApprovalStatus.OPEN_REQUESTED);
        assertFalse(result);
    }

    /** Tests for validateExceptionStatus(ExceptionStatus) */
    @Test
    public void testValidateExceptionStatusOnly_Valid() {
        boolean result = actionRequestValidator.validateExceptionStatus(ExceptionStatus.Cancel_Approved);
        assertTrue(result);
    }

    @Test
    public void testValidateExceptionStatusOnly_Invalid() {
        boolean result = actionRequestValidator.validateExceptionStatus(ExceptionStatus.Open);
        assertFalse(result);
    }

    /** Tests for isJiraIdPresent */
    @Test
    public void testIsJiraIdPresent_Present() {
        List<String> issueIds = ImmutableList.of("JIRA-123");
        boolean result = actionRequestValidator.isJiraIdPresent(issueIds, "JIRA-123");
        assertTrue(result);
    }

    @Test
    public void testIsJiraIdPresent_NotPresent() {
        List<String> issueIds = ImmutableList.of("JIRA-124");
        boolean result = actionRequestValidator.isJiraIdPresent(issueIds, "JIRA-123");
        assertFalse(result);
    }

    /** Tests for validateApprover - Valid case */
    @Test
    public void testValidateApprover_Valid() throws Exception {
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        ScanRequestBuilder scanBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanBuilder);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(dfClient.pagedScan(scanBuilder)).thenReturn(pagedScan);
        Record record = mock(Record.class);
        when(pagedScan.getRecords()).thenReturn(Collections.singletonList(record));
        JsonDocument jsonDoc = mock(JsonDocument.class);
        when(record.getDocument()).thenReturn(jsonDoc);
        when(jsonDoc.getContents()).thenReturn("{\"username\":\"approver\"}");

        boolean result = actionRequestValidator.validateApprover(ExceptionStatus.Open, "tradeId", "collection", "approver");
        assertTrue(result);
    }

    @Test
    public void testValidateApprover_Invalid() throws Exception {
        boolean result = actionRequestValidator.validateApprover(ExceptionStatus.Edit_Approved, "tradeId", "collection", "approver");
        assertFalse(result);
    }
}
