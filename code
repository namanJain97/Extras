package com.rbs.tntr.business.taggingService.repository;

import static com.rbs.tntr.business.taggingService.repository.TagginServiceSerializer.objectMapper;
import static com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIConstants.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nwm.tntr.commons.domain.persistence.constant.AssetClass;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.nwm.tntr.configuration.ItrConfiguration;
import com.nwm.tntr.itr.IQuery;
import com.nwm.tntr.itr.ItrClient;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.api.exception.UpsertException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.datafabric.domain.client.builder.UpsertRequestBuilder;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.*;
import org.springframework.test.util.ReflectionTestUtils;

public class MIAnalyticsDashboardRepositoryImplTest {

    @InjectMocks
    MIAnalyticsDashboardRepositoryImpl repo;

    @Mock
    DfConnectionManager dfConn;

    @Mock
    ItrConfiguration itrConfig;

    @Mock
    DataFabricClient dfClient;

    @Mock
    private ItrClient itrClient;

    @Mock
    private ScanRequestBuilder scanRequestBuilder;

    @Mock
    private UpsertRequestBuilder upsertRequestBuilder;

    @Mock
    private ScanResult scanResult;

    @Mock
    private Iterator<Record> recordIterator;

    @Mock
    private Record dfRecord;

    @Mock
    private JsonDocument jsonDocument;

    private static final ObjectMapper REAL_OBJECT_MAPPER = new ObjectMapper();
    private static final Date TEST_DATE;

    static {
        try {
            TEST_DATE = new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-19");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        setField("dfClient", dfClient);

        // Set configuration properties via reflection
        ReflectionTestUtils.setField(repo, "databaseName", "testDatabase");
        ReflectionTestUtils.setField(repo, "miCollection", "miCollection");
        ReflectionTestUtils.setField(repo, "foMiCollection", "foMiCollection");
        ReflectionTestUtils.setField(repo, "readTimeOut", 60);

        // Set URLs for various endpoints
        ReflectionTestUtils.setField(repo, "foEmirUrl", "emirUrl");
        ReflectionTestUtils.setField(repo, "foEmirParameterisedUrl", "emirParamUrl");
        ReflectionTestUtils.setField(repo, "foMasUrl", "masUrl");
        ReflectionTestUtils.setField(repo, "foMasParameterisedUrl", "masParamUrl");
        ReflectionTestUtils.setField(repo, "foBoiUrl", "boiUrl");
        ReflectionTestUtils.setField(repo, "foMifidUrl", "mifidUrl");
        ReflectionTestUtils.setField(repo, "foSftrUrl", "sftrUrl");
        ReflectionTestUtils.setField(repo, "foSftrAldopUrl", "sftrAldopUrl");
        ReflectionTestUtils.setField(repo, "foCftcUrl", "cftcUrl");

        // Mock common behaviors
        when(itrConfig.getItr2ProtocolScheme()).thenReturn("http");
        when(itrConfig.getItr2ServiceName()).thenReturn("testService");
    }

    private void setField(String fieldName, Object value) throws Exception {
        Field field = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(repo, value);
    }

    private Object invokePrivateMethod(String methodName, Class<?>[] parameterTypes, Object... args) throws Exception {
        Method method = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod(methodName, parameterTypes);
        method.setAccessible(true);
        return method.invoke(repo, args);
    }

    // Existing Tests (kept as is, only shown partially for brevity)

    @Test
    public void testCreateDfClientConnection_Success() throws StartableException {
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(dfClient).when(spyRepo).getDfClient(any(DfConnectionManager.class));

        spyRepo.createDfClientConnection();

        verify(spyRepo).getDfClient(dfConn);
    }

    @Test
    public void testCreateDfClientConnection_Exception() throws StartableException {
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doThrow(new StartableException("Test exception")).when(spyRepo).getDfClient(any(DfConnectionManager.class));

        spyRepo.createDfClientConnection();

        verify(spyRepo).getDfClient(dfConn);
    }

    // ... (Other existing tests remain unchanged)

    // Additional Test Cases for 100% Coverage

    /** Test successful deserialization of a valid JSON document */
    @Test
    public void testDeserialize_Success() throws Exception {
        MIDashboardAnalytics original = new MIDashboardAnalytics();
        SubjectIdentifier identifier = new SubjectIdentifier("lei", "entity", "flow", "asset", "message", "reg", TEST_DATE);
        original.setSubjectIdentifier(identifier);
        String json = REAL_OBJECT_MAPPER.writeValueAsString(original);
        JsonDocument document = new JsonDocument();
        document.setContents(json);

        MIDashboardAnalytics result = repo.deserailze(document);

        assertNotNull(result);
        assertEquals(identifier.getLei(), result.getSubjectIdentifier().getLei());
    }

    /** Test processFoMiData with EMIR and FX, including NOTFOUND counts */
    @Test
    public void testProcessFoMiData_EMIR_FX() throws Exception {
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        // Mock FO_ASSETWISE_MAP to return only EMIR
        Map<String, List<String>> foAssetWiseMap = new HashMap<>();
        foAssetWiseMap.put(assetClass, Collections.singletonList(EMIR));
        ReflectionTestUtils.setField(repo, "FO_ASSETWISE_MAP", foAssetWiseMap);

        doAnswer(invocation -> {
            String json = "[{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\",\"TRANSACTION_REPORTABLE\":true,\"VERSION_REPORTABLE\":true}," +
                          "{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_NV + "\",\"TRANSACTION_REPORTABLE\":true,\"VERSION_REPORTABLE\":false}," +
                          "{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\",\"TRANSACTION_REPORTABLE\":false,\"VERSION_REPORTABLE\":false}]";
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(eq("http://testService/emirUrl"), any(Itr2Query.class), any());

        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());

        spyRepo.processFoMiData(metadata, TEST_DATE, assetClass);

        ArgumentCaptor<FrontOfficeMIDashboardAnalytics> captor = ArgumentCaptor.forClass(FrontOfficeMIDashboardAnalytics.class);
        verify(spyRepo, times(4)).upsertFoMiSnapshot(captor.capture());
        List<FrontOfficeMIDashboardAnalytics> analytics = captor.getAllValues();

        // Verify EMIR PLC
        FrontOfficeMIDashboardAnalytics emirPlc = analytics.stream()
                .filter(a -> a.getSubjectIdentifier().getRegulation().equals(EMIR) && a.getSubjectIdentifier().getEntity().equals(NWM_PLC))
                .findFirst().orElse(null);
        assertNotNull(emirPlc);
        assertEquals(1, emirPlc.getMiAnalyticsState().getReportableCount());
        assertEquals(0, emirPlc.getMiAnalyticsState().getNonReportableCount());

        // Verify EMIR NV
        FrontOfficeMIDashboardAnalytics emirNv = analytics.stream()
                .filter(a -> a.getSubjectIdentifier().getRegulation().equals(EMIR) && a.getSubjectIdentifier().getEntity().equals(NWM_NV))
                .findFirst().orElse(null);
        assertNotNull(emirNv);
        assertEquals(0, emirNv.getMiAnalyticsState().getReportableCount());
        assertEquals(1, emirNv.getMiAnalyticsState().getNonReportableCount());

        // Verify JND PLC
        FrontOfficeMIDashboardAnalytics jndPlc = analytics.stream()
                .filter(a -> a.getSubjectIdentifier().getRegulation().equals(JND) && a.getSubjectIdentifier().getEntity().equals(NWM_PLC))
                .findFirst().orElse(null);
        assertNotNull(jndPlc);
        assertEquals(0, jndPlc.getMiAnalyticsState().getReportableCount());
        assertEquals(1, jndPlc.getMiAnalyticsState().getNonReportableCount());
    }

    /** Test processFoMiData with EMIR and ETD (parameterized query) */
    @Test
    public void testProcessFoMiData_EMIR_ETD() throws Exception {
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("ETD");
        String assetClass = AssetClass.ETD.value();
        Map<String, List<String>> foAssetWiseMap = new HashMap<>();
        foAssetWiseMap.put(assetClass, Collections.singletonList(EMIR));
        ReflectionTestUtils.setField(repo, "FO_ASSETWISE_MAP", foAssetWiseMap);

        doAnswer(invocation -> {
            String json = "[{\"" + EMIR_ASSETWISE_PARSE_DATA.get(assetClass).get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_PLC + "\"," +
                          "\"" + EMIR_ASSETWISE_PARSE_DATA.get(assetClass).get(TRANSACTION_REPORTABLE) + "\":true," +
                          "\"" + EMIR_ASSETWISE_PARSE_DATA.get(assetClass).get(VERSION_REPORTABLE) + "\":true}]";
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(eq("http://testService/emirParamUrl"), any(IQuery.class), any());

        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());

        spyRepo.processFoMiData(metadata, TEST_DATE, assetClass);

        verify(spyRepo, times(2)).upsertFoMiSnapshot(any()); // EMIR PLC/NV, no NOTFOUND
    }

    /** Test processFoMiData with multiple jurisdictions and exception handling */
    @Test
    public void testProcessFoMiData_MultiJurisdiction_WithException() throws Exception {
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        Map<String, List<String>> foAssetWiseMap = new HashMap<>();
        foAssetWiseMap.put(assetClass, Arrays.asList(EMIR, MAS));
        ReflectionTestUtils.setField(repo, "FO_ASSETWISE_MAP", foAssetWiseMap);

        doThrow(new RuntimeException("ITR error")).when(itrClient).fetch(eq("http://testService/emirUrl"), any(Itr2Query.class), any());
        doAnswer(invocation -> {
            String json = "[{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\",\"TRANSACTION_REPORTABLE\":true,\"VERSION_REPORTABLE\":true}]";
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(eq("http://testService/masUrl"), any(Itr2Query.class), any());

        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());

        spyRepo.processFoMiData(metadata, TEST_DATE, assetClass);

        verify(spyRepo, times(2)).upsertFoMiSnapshot(any()); // MAS PLC/NV only
    }

    /** Test processFoMiData with CFTC_CSA and FX */
    @Test
    public void testProcessFoMiData_CFTC_CSA_FX() throws Exception {
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        Map<String, List<String>> foAssetWiseMap = new HashMap<>();
        foAssetWiseMap.put(assetClass, Collections.singletonList(CFTC_CSA));
        ReflectionTestUtils.setField(repo, "FO_ASSETWISE_MAP", foAssetWiseMap);

        doAnswer(invocation -> {
            String json = "[{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\"," +
                          "\"canada\":\"{TRANSACTION_REPORTABLE=true,VERSION_REPORTABLE=true}\"," +
                          "\"cftc\":\"{TRANSACTION_REPORTABLE=false,VERSION_REPORTABLE=false}\"}]";
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(eq("http://testService/cftcUrl"), any(Itr2Query.class), any());

        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());

        spyRepo.processFoMiData(metadata, TEST_DATE, assetClass);

        verify(spyRepo, times(4)).upsertFoMiSnapshot(any()); // CSA PLC/NV, DF PLC/NV
    }

    /** Test fetchFromItrWithParamQuery for BOI */
    @Test
    public void testFetchFromItrWithParamQuery_BOI() throws Exception {
        Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
        foMiDataMap.put(BOI, new HashMap<>());
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        Map<String, List<String>> boiQueryIds = new HashMap<>();
        boiQueryIds.put(assetClass, Collections.singletonList("query1"));
        ReflectionTestUtils.setField(repo, "BOI_ASSETWISE_QUERY_IDS", boiQueryIds);
        ReflectionTestUtils.setField(repo, "BOI_PARAM_QUERY_SELECT", "select *");

        doAnswer(invocation -> {
            String json = "[{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\",\"TRANSACTION_REPORTABLE\":true,\"VERSION_REPORTABLE\":true}]";
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(eq("http://testService/boiUrl"), any(IQuery.class), any());

        invokePrivateMethod("fetchFromItrWithParamQuery", new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                metadata, foMiDataMap, "boiUrl", BOI, TEST_DATE, assetClass);

        assertEquals(1, foMiDataMap.get(BOI).get("NWM_PLC_REPORTABLE").intValue());
    }

    /** Test fetchFromItrWithParamQuery for SFTR with ALDOP */
    @Test
    public void testFetchFromItrWithParamQuery_SFTR_ALDOP() throws Exception {
        Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
        foMiDataMap.put(SFTR, new HashMap<>());
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        Map<String, List<String>> sftrQueryIds = new HashMap<>();
        sftrQueryIds.put(assetClass, Arrays.asList("query1", SFTR_ALDOP_QUERY_ID));
        ReflectionTestUtils.setField(repo, "SFTR_ASSETWISE_QUERY_IDS", sftrQueryIds);
        ReflectionTestUtils.setField(repo, "SFTR_ASSETWISE_SELECT", Collections.singletonMap(assetClass, "select *"));

        doAnswer(invocation -> {
            String json = "[{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\",\"TRANSACTION_REPORTABLE\":true,\"VERSION_REPORTABLE\":true}]";
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(anyString(), any(IQuery.class), any());

        invokePrivateMethod("fetchFromItrWithParamQuery", new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                metadata, foMiDataMap, "sftrUrl", SFTR, TEST_DATE, assetClass);

        assertEquals(1, foMiDataMap.get(SFTR).get("NWM_PLC_REPORTABLE").intValue());
        verify(itrClient).fetch(eq("http://testService/sftrAldopUrl"), any(IQuery.class), any());
    }

    /** Test fetchFromItrWithoutParamQuery with invalid JSON array */
    @Test
    public void testFetchFromItrWithoutParamQuery_InvalidArray() throws Exception {
        Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
        foMiDataMap.put(EMIR, new HashMap<>());
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");
        metadata.setSelect("select *");

        doAnswer(invocation -> {
            String json = "{ \"key\": \"value\" }"; // Not an array
            return new ByteArrayInputStream(json.getBytes());
        }).when(itrClient).fetch(eq("http://testService/emirUrl"), any(Itr2Query.class), any());

        invokePrivateMethod("fetchFromItrWithoutParamQuery", new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class},
                metadata, foMiDataMap, "emirUrl", EMIR);

        assertTrue(foMiDataMap.get(EMIR).isEmpty());
    }

    /** Test fetchFromItr exception handling */
    @Test
    public void testFetchFromItr_Exception() throws Exception {
        Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
        foMiDataMap.put(EMIR, new HashMap<>());
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("FX");

        doThrow(new IOException("Fetch error")).when(itrClient).fetch(anyString(), any(IQuery.class), any());

        Map<String, Map<String, Integer>> result = (Map<String, Map<String, Integer>>) invokePrivateMethod("fetchFromItr",
                new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                metadata, foMiDataMap, "emirUrl", EMIR, TEST_DATE, "FX");

        assertTrue(result.get(EMIR).isEmpty());
    }

    /** Test parseItrRecord for MIFID non-ETD */
    @Test
    public void testParseItrRecord_MIFID_NonETD() throws Exception {
        String json = "{\"" + MIFID_ASSETWISE_PARSE_DATA.get("FX").get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_NV + "\"," +
                      "\"" + MIFID_ASSETWISE_PARSE_DATA.get("FX").get(TRANSACTION_REPORTABLE) + "\":true," +
                      "\"" + MIFID_ASSETWISE_PARSE_DATA.get("FX").get(VERSION_REPORTABLE) + "\":false}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        parser.nextToken();

        Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, "FX", MIFID);

        assertEquals(LEI_NWM_NV, result.get(MIFID).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(MIFID).get(TRANSACTION_REPORTABLE));
        assertEquals(false, result.get(MIFID).get(VERSION_REPORTABLE));
    }

    /** Test renderCftcDataBlock with malformed input */
    @Test
    public void testRenderCftcDataBlock_Malformed() throws Exception {
        Map<String, Object> jsonMap = new HashMap<>();
        jsonMap.put("cftc", "malformed=string");

        Map<String, Object> result = (Map<String, Object>) invokePrivateMethod("renderCftcDataBlock",
                new Class<?>[]{Map.class, String.class}, jsonMap, "cftc");

        assertEquals("string", result.get("malformed"));
    }

    /** Test calculateMiSnapshotKey uniqueness */
    @Test
    public void testCalculateMiSnapshotKey_Uniqueness() throws Exception {
        SubjectIdentifier id1 = new SubjectIdentifier("lei1", "entity1", "flow1", "asset1", "message1", "reg1", TEST_DATE);
        SubjectIdentifier id2 = new SubjectIdentifier("lei2", "entity2", "flow2", "asset2", "message2", "reg2", TEST_DATE);

        String key1 = (String) invokePrivateMethod("calculateMiSnapshotKey", new Class<?>[]{SubjectIdentifier.class}, id1);
        String key2 = (String) invokePrivateMethod("calculateMiSnapshotKey", new Class<?>[]{SubjectIdentifier.class}, id2);

        assertNotEquals(key1, key2);
    }

    /** Test populateFoLifeTimeParams format */
    @Test
    public void testPopulateFoLifeTimeParams_Format() throws Exception {
        Map<String, String> params = (Map<String, String>) invokePrivateMethod("populateFoLifeTimeParams",
                new Class<?>[]{Date.class}, TEST_DATE);

        assertTrue(params.get(DATETIME_FROM).matches("\\d{4}-\\d{2}-\\d{2}T00:00:00\\.000Z"));
        assertTrue(params.get(DATETIME_TO).matches("\\d{4}-\\d{2}-\\d{2}T23:59:59\\.999Z"));
    }

    /** Test persistFoJurisdictionDetermined */
    @Test
    public void testPersistFoJurisdictionDetermined() throws Exception {
        Map<String, Integer> foData = new HashMap<>();
        foData.put(PLC_REPORTABLE, 1);
        foData.put(PLC_NONREPORTABLE, 2);
        foData.put(NV_REPORTABLE, 3);
        foData.put(NV_NONREPORTABLE, 4);

        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());

        invokePrivateMethod("persistFoJurisdictionDetermined", new Class<?>[]{String.class, String.class, Date.class, Map.class},
                "FX", EMIR, TEST_DATE, foData);

        verify(spyRepo, times(2)).upsertFoMiSnapshot(any());
    }

    // ... (Other existing tests remain unchanged up to testFetchFromItrWithParamQuery_SFTR_WithAldop)
}
