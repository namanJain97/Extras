Could you write all the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

package com.rbs.tntr.business.blotter.services.actions;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.TNTRApplication;
import com.nwm.tntr.commons.domain.persistence.constant.UserActionType;
import com.nwm.tntr.commons.domain.persistence.entity.DocumentId;
import com.nwm.tntr.commons.domain.persistence.entity.ExceptionManagement;
import com.nwm.tntr.commons.domain.persistence.entity.NonReportableData;
import com.nwm.tntr.commons.domain.persistence.entity.collaterallink.CollateralLinkReport;
import com.nwm.tntr.commons.domain.persistence.entity.collaterallink.CollateralLinkReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.rbs.tntr.business.blotter.df.manager.DfCollateralLinkPersistManager;
import com.rbs.tntr.business.blotter.df.updater.CollateralLinkDataUpdater;
import com.rbs.tntr.business.blotter.services.validators.ActionRequestValidator;
import com.rbs.tntr.domain.blotter.enums.ExceptionStatus;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import com.rbs.tntr.domain.blotter.exceptions.DfRunTimeException;
import com.rbs.tntr.domain.blotter.tntrBlotterView.ActionDocumentId;

@Service
public class CollateralLinkActionService {
    private final Logger logger = LoggerFactory.getLogger(CollateralLinkActionService.class);
    private static final String UPDATE_ERROR = "Error updating collateral record : ";
    public static final String COLLATERAL_LINK = "CollateralLink;";

    private final DfCollateralLinkPersistManager dfCollateralPersistManager;
    private final CollateralLinkDataUpdater dataUpdater;
    private final ActionRequestValidator requestValidator;

    @Autowired
    public CollateralLinkActionService(DfCollateralLinkPersistManager dfCollateralPersistManager, CollateralLinkDataUpdater dataUpdater, ActionRequestValidator requestValidator) {
        this.dfCollateralPersistManager = dfCollateralPersistManager;
        this.dataUpdater = dataUpdater;
        this.requestValidator = requestValidator;
    }



    public List<ActionUpdateResult> addComment(List<AddTradeCommentRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithComments(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    public List<ActionUpdateResult> removeComment(List<AddTradeCommentRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithRemovedComments(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }
    
    protected List<Pair<CollateralLinkReport, Long>> getTradeWithComments(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentRequest addTradeCommentRequest = (AddTradeCommentRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addCommentsToException(addTradeCommentRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport collateralLinkRepo = getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralLinkRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithRemovedComments(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentRequest addTradeCommentRequest = (AddTradeCommentRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.removeCommentsToException(addTradeCommentRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport collateralLinkRepo = getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralLinkRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    private CollateralLinkReport getCollateralLinkReport(CollateralLinkReport tradeReport, ExceptionManagement exceptionManagement) {
        return CollateralLinkReport.newBuilder(tradeReport).withExceptionManagement(exceptionManagement)
                                .withNonReportableData(NonReportableData.newBuilder(tradeReport.getNonReportableData())
                                        .withUpdatedByApplication(TNTRApplication.BLOTTER_SERVICE)
                                        .build())
                                .build();
    }

    private Pair<CollateralLinkReport, Long> getReportsWithExpectedBaseVersion(CollateralLinkReportDocument tradeReportDocument, CollateralLinkReport tradeReport) {
        return Pair.of(tradeReport, tradeReportDocument.getDocumentId().getVersion());
    }

    private List<ActionUpdateResult> saveAllRecords(List<CollateralLinkReportDocument> tradeReportDocuments, List<Pair<CollateralLinkReport, Long>> tradeReports) {
        List<WriteResult<CollateralLinkReport>> writeResults =  dfCollateralPersistManager.saveAllRecords(tradeReports);
        List<ActionUpdateResult> result = getResult(tradeReportDocuments, writeResults);
        return result;
    }

	private List<ActionUpdateResult> rollBackRejectedRecords(Map<DocumentId, UpdateRequest> tradeRequestMap) {
		logger.info("Rolling back records to previous version due to rejection");
		List<ActionUpdateResult> writeResults = Lists.newArrayList();
		List<DocumentId> documentIds = Lists.newArrayList();
		tradeRequestMap.keySet().forEach(documentId -> {
			documentIds.add(DocumentId.from(documentId.getKey(), (documentId.getVersion() - 2)));
		});
		List<CollateralLinkReportDocument> collateralLinkReportDocuments = getTradeReportDocuments(documentIds);
		List<CollateralLinkReport> collateralLinkReports = collateralLinkReportDocuments.stream()
				.map(collateralLinkDocument -> collateralLinkDocument.getCollateralLinkReport()).collect(Collectors.toList());
		writeResults = upsertAllRecords(collateralLinkReportDocuments, collateralLinkReports);
		return writeResults;
	}

	private List<ActionUpdateResult> upsertAllRecords(List<CollateralLinkReportDocument> collateralLinkReportDocuments,
			List<CollateralLinkReport> collateralLinkReports) {
		List<WriteResult<CollateralLinkReport>> writeResults = dfCollateralPersistManager
				.upsertAllRecords(collateralLinkReports);
		List<ActionUpdateResult> result = getResult(collateralLinkReportDocuments, writeResults);
		return result;
	}


    private List<ActionUpdateResult> getResult(List<CollateralLinkReportDocument> tradeReportDocuments, List<WriteResult<CollateralLinkReport>> writeResults) {
        List<ActionUpdateResult> results = Lists.newArrayList();
        if(writeResults != null) {
            for (int i = 0; i < writeResults.size(); i++) {
                if (writeResults.get(i).isSuccess()) {
                    results.add(ActionUpdateResult.createSuccess(getTradePrimaryKey(tradeReportDocuments.get(i).getDocumentId()), writeResults.get(i).getDocumentId().getKey(), writeResults.get(i).getDocumentId().getVersion()));
                } else {
                    String error = writeResults.get(i).getErrorDetail().getCause() != null
                            ? writeResults.get(i).getErrorDetail().getDescription() + ". " + writeResults.get(i).getErrorDetail().getCause().getMessage()
                            : writeResults.get(i).getErrorDetail().getDescription();
                    logger.error("Error occured in persisting Collateral Link key : [{}], version : [{}] Reason : [{}]", tradeReportDocuments.get(i).getDocumentId().getKey(), tradeReportDocuments.get(i).getDocumentId().getVersion(), error);
                    results.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocuments.get(i).getDocumentId()), error));
                }
            }
        }

        return results;
    }

    private List<CollateralLinkReportDocument> getTradeReportDocuments(List<DocumentId> documentIds) throws DfRunTimeException {
        return dfCollateralPersistManager.getAllRecordsById(documentIds);
    }

    protected void populateTradeRequestMap(UpdateRequest updateRequest, Map<DocumentId, UpdateRequest> map) {
        ActionDocumentId docId = updateRequest.getDocumentId();
        DocumentId documentId = DocumentId.from(docId.getKey(), docId.getVersion());

        map.put(documentId, updateRequest);
    }

    private ActionDocumentId getTradePrimaryKey(DocumentId documentId) {
        return new ActionDocumentId(documentId.getKey(), documentId.getVersion());
    }

	public List<ActionUpdateResult> updateEditedFields(List<EditRequest> requests, String userName,
			ExceptionStatus exceptionStatus) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
				List<Pair<CollateralLinkReport, Long>> tradeReports = editFields(tradeReportDocuments, tradeRequestMap,
						writeResults, userName, exceptionStatus);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

	protected List<Pair<CollateralLinkReport, Long>> editFields(List<CollateralLinkReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName,
			ExceptionStatus exceptionStatus) {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    try {
                        EditRequest editRequest = (EditRequest) requests.get(tradeReportDocument.getDocumentId());

						CollateralLinkReport tradeRepo = dataUpdater.updateTradeReportData(editRequest, tradeReport,
								userName, exceptionStatus);
                        reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                    } catch (BlotterRunTimeException e) {
                        failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), e.getMessage()));
                        logger.error("Collateral Link edit failed for key : [{}], version : [{}], reason : [{}]",tradeReportDocument.getDocumentId().getKey(), tradeReportDocument.getDocumentId().getVersion(), e.getMessage(), e);
                    }
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while editing collateral. ", e);
            throw new BlotterRunTimeException("Error occured while editing collateral. "+e.getMessage(), e);
        }
    }

    public List<ActionUpdateResult> updateExceptionStatus(List<UpdateExceptionStatusRequest> requests, ExceptionStatus requestedExceptionStatus, String userName) {
        if(requests.isEmpty() || requestValidator.validateExceptionStatus(requestedExceptionStatus)){
            if(!requests.isEmpty()){
                logger.warn("Validation Failed : [{}] action not applicable on Collateral Link Records.", requestedExceptionStatus);
            }
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            

            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithExceptionStatus(tradeReportDocuments, requestedExceptionStatus, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

			if (ExceptionStatus.Edit_Rejected.equals(requestedExceptionStatus)) {
				writeResults = rollBackRejectedRecords(tradeRequestMap);
			}

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return getTradeUpdateResultOnError(requests, e.getMessage());
        }
    }
    
    public List<ActionUpdateResult> performResetAction(List<UpdateExceptionStatusRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = resetActionOnCollateralLink(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return getTradeUpdateResultOnError(requests, e.getMessage());
        }
    }

    private List<ActionUpdateResult> getTradeUpdateResultOnError(List<UpdateExceptionStatusRequest> requests, String errormessage) {
        return requests
                .stream()
                .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + errormessage))
                .collect(Collectors.toList());
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithExceptionStatus(List<CollateralLinkReportDocument> tradeReportDocuments, ExceptionStatus requestedExceptionStatus, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if (!requestValidator.validateExceptionStatus(requestedExceptionStatus, tradeReport.getExceptionManagement().getApprovalStatus())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if (requestValidator.validateApprover(requestedExceptionStatus, tradeReport.getCollateralLinkReportId().getTradeSourceSystemTransactionId(), COLLATERAL_LINK,userName)) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    UpdateExceptionStatusRequest updateExceptionStatusRequest = (UpdateExceptionStatusRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.addExceptionStatus(requestedExceptionStatus, updateExceptionStatusRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport tradeRepo = getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating exception status in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating exception status in ExceptionManagement. ", e);
        }
    }
    
	protected List<Pair<CollateralLinkReport, Long>> resetActionOnCollateralLink(
			List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests,
			List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
		try {
			List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
			for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
				CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
				 if (!requestValidator.validateResetActionApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus(),
	                        requests.get(tradeReportDocument.getDocumentId()).getFlow())) {
					logger.warn("Reset Action is not allowed because Current Approval Status of trade is : {}",
							tradeReport.getExceptionManagement().getApprovalStatus());
					failedTrades.add(
							ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()),
									ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
					logFailuerReason(tradeReportDocument.getDocumentId(),
							ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
				} else {
					UpdateExceptionStatusRequest updateExceptionStatusRequest = (UpdateExceptionStatusRequest) requests
							.get(tradeReportDocument.getDocumentId());
					ExceptionManagement exceptionManagement = dataUpdater.resetAction(updateExceptionStatusRequest,
							tradeReport.getExceptionManagement(), userName);

					CollateralLinkReport tradeRepo = getCollateralLinkReport(tradeReport, exceptionManagement);
					reportsWithExpectedBaseVersions
							.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
				}
			}
			return reportsWithExpectedBaseVersions;
		} catch (Exception e) {
			logger.error("Error occured while updating exception status in ExceptionManagement. ", e);
			throw new BlotterRunTimeException("Error occured while updating exception status in ExceptionManagement. ",
					e);
		}
	}

    public List<ActionUpdateResult> assignExceptionToUser(List<AssignTradeRequest> requests, String userName) {
        try {
            if(requests.isEmpty()){
                return Lists.newArrayList();
            }
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithAssignment(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithAssignment(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AssignTradeRequest assignTradeRequest = (AssignTradeRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.assignException(assignTradeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport tradeRepo =getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating assign user in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating assign user in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> addJiraId(List<AddTradeJiraReferenceRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithJiraReference(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithJiraReference(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                AddTradeJiraReferenceRequest addTradeJiraReferenceRequest = (AddTradeJiraReferenceRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(requestValidator.isJiraIdPresent(tradeReport.getExceptionManagement().getIssueIds(), addTradeJiraReferenceRequest.getJiraReference().getJiraId())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_ID_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_ID_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.addJiraIdToException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport tradeRepo =getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while adding jira id in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while adding jira id in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeJiraId(List<AddTradeJiraReferenceRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = removeJiraReference(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> removeJiraReference(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                AddTradeJiraReferenceRequest addTradeJiraReferenceRequest = (AddTradeJiraReferenceRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(!requestValidator.isJiraIdPresent(tradeReport.getExceptionManagement().getIssueIds(), addTradeJiraReferenceRequest.getJiraReference().getJiraId())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_ID_NOT_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_ID_NOT_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.removeJiraIdFromException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport tradeRepo =getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while removing jira id from ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while removing jira id from ExceptionManagement. ", e);
        }
    }


    public List<ActionUpdateResult> addJiraType(List<AddTradeJiraTypeRequest> requests, String userName) {
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithJiraType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithJiraType(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeJiraTypeRequest addTradeJiraTypeRequest = (AddTradeJiraTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addJiraTypeToException(addTradeJiraTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport tradeRepo =getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while adding jira type in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while adding jira type in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeJiraType(List<AddTradeJiraTypeRequest> requests, String userName) {
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = removeJiraType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> removeJiraType(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                AddTradeJiraTypeRequest addTradeJiraReferenceRequest = (AddTradeJiraTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(!tradeReport.getExceptionManagement().getIssueType().value().equals(addTradeJiraReferenceRequest.getJiraType().getIssueType())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_TYPE_NOT_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_TYPE_NOT_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.removeJiraTypeFromException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport tradeRepo =getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while removing jira type from ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while removing jira type from ExceptionManagement. ", e);
        }
    }

    private void logFailuerReason(DocumentId documentId, String reason){
        logger.warn("Collateral Link validation failed for key : [{}], version : [{}] Reason : [{}]", documentId.getKey(), documentId.getVersion(), reason);
    }
    
	public List<ActionUpdateResult> updateUserActionType(List<UpdateUserActionTypeRequest> requests, String userName) {
		if (requests.isEmpty()) {
			return Lists.newArrayList();
		}
		try {
			List<ActionUpdateResult> writeResults = Lists.newArrayList();

			Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
			requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
			List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(
					Lists.newArrayList(tradeRequestMap.keySet()));

			if (!tradeReportDocuments.isEmpty()) {
				List<Pair<CollateralLinkReport, Long>> tradeReports = getUserActionTypeTrades(tradeReportDocuments,
						tradeRequestMap, writeResults, userName);
				if (!tradeReports.isEmpty()) {
					writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
				}
			}

			return writeResults;
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			return requests.stream().map(request -> ActionUpdateResult.createWithError(request.getDocumentId(),
					UPDATE_ERROR + e.getMessage())).collect(Collectors.toList());
		}
	}

	protected List<Pair<CollateralLinkReport, Long>> getUserActionTypeTrades(List<CollateralLinkReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName)
			throws BlotterRunTimeException {
		try {
			List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

			for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
				CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
				UpdateUserActionTypeRequest updateUserActionTypeRequest = (UpdateUserActionTypeRequest) requests
						.get(tradeReportDocument.getDocumentId());
				ExceptionManagement exceptionManagement = dataUpdater.addComments(tradeReport.getExceptionManagement(),
						userName, updateUserActionTypeRequest.getComment().getComment(),
						updateUserActionTypeRequest.getAction());
				CollateralLinkReport tradeRepo = getTradeReportWithUserActionType(tradeReport, exceptionManagement,
						UserActionType.fromValue(updateUserActionTypeRequest.getUserActionType()));
				reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
			}
			return reportsWithExpectedBaseVersions;
		} catch (Exception e) {
			logger.error("Error occured while updating comments in ExceptionManagement. ", e);
			throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
		}
	}

	private CollateralLinkReport getTradeReportWithUserActionType(CollateralLinkReport tradeReport,
			ExceptionManagement exceptionManagement, UserActionType userActionType) {
		return CollateralLinkReport.newBuilder(tradeReport).withExceptionManagement(exceptionManagement)
				.withNonReportableData(NonReportableData.newBuilder(tradeReport.getNonReportableData())
						.withUserActionType(userActionType).withUpdatedByApplication(TNTRApplication.BLOTTER_SERVICE)
						.build())
				.build();
	}

    public List<ActionUpdateResult> addCommentType(List<AddTradeCommentTypeRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithCommentType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    public List<ActionUpdateResult> removeCommentType(List<AddTradeCommentTypeRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralLinkReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralLinkReport, Long>> tradeReports = getTradeWithRemovedCommentType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithCommentType(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentTypeRequest addTradeCommentTypeRequest = (AddTradeCommentTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addCommentTypeToException(addTradeCommentTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport collateralLinkRepo = getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralLinkRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    protected List<Pair<CollateralLinkReport, Long>> getTradeWithRemovedCommentType(List<CollateralLinkReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralLinkReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralLinkReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralLinkReport tradeReport = tradeReportDocument.getCollateralLinkReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentTypeRequest addTradeCommentTypeRequest = (AddTradeCommentTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.removeCommentTypeToException(addTradeCommentTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralLinkReport collateralLinkRepo = getCollateralLinkReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralLinkRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }
}

Exisitng test class:

package com.rbs.tntr.business.blotter.services.actions;

import com.nwm.tntr.commons.domain.persistence.entity.collaterallink.CollateralLinkReport;
import com.nwm.tntr.commons.domain.persistence.entity.collaterallink.CollateralLinkReportDocument;
import com.rbs.tntr.business.blotter.df.manager.DfCollateralLinkPersistManager;
import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class CollateralLinkActionServiceTest {

    @InjectMocks
    private CollateralLinkActionService collateralLinkActionService;

    @Mock
    private DfCollateralLinkPersistManager dfCollateralPersistManager;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testAddComment_EmptyRequests() {
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralLinkActionService.addComment(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddComment_ValidRequest() {
        List<AddTradeCommentRequest> requests = setupValidCommentRequests();
        List<CollateralLinkReportDocument> documents = setupValidCollateralLinkDocuments();

        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(documents);
        List<ActionUpdateResult> results = collateralLinkActionService.addComment(requests, "username");

        assertFalse(results.isEmpty());
    }

    @Test
    public void testAddComment_ExceptionHandling() {
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenThrow(new RuntimeException("Database Error"));
        List<AddTradeCommentRequest> requests = setupValidCommentRequests();

        List<ActionUpdateResult> results = collateralLinkActionService.addComment(requests, "username");

        assertFalse(results.isEmpty());
    }

    @Test
    public void testRemoveComment_EmptyRequests() {
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralLinkActionService.removeComment(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveComment_ValidRequest() {
        List<AddTradeCommentRequest> requests = setupValidCommentRequests();
        List<CollateralLinkReportDocument> documents = setupValidCollateralLinkDocuments();

        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(documents);
        List<ActionUpdateResult> results = collateralLinkActionService.removeComment(requests, "username");

        assertFalse(results.isEmpty());
    }

    @Test
    public void testAssignExceptionToUser_EmptyRequests() {
        List<AssignTradeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralLinkActionService.assignExceptionToUser(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddJiraId_EmptyRequests() {
        List<AddTradeJiraReferenceRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralLinkActionService.addJiraId(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveJiraId_ExceptionHandling() {
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenThrow(new RuntimeException("Error deleting"));
        List<AddTradeJiraReferenceRequest> requests = setupValidJiraReferenceRequests();

        List<ActionUpdateResult> results = collateralLinkActionService.removeJiraId(requests, "username");
        assertFalse(results.isEmpty());
    }

    @Test
    public void testAddCommentType_EmptyRequests() {
        List<AddTradeCommentTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralLinkActionService.addCommentType(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveCommentType_EmptyRequests() {
        List<AddTradeCommentTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralLinkActionService.removeCommentType(requests, "username");
        assertTrue(results.isEmpty());
    }

    // Helper methods to set up mock data for tests
    private List<AddTradeCommentRequest> setupValidCommentRequests() {
        // Create and return a valid list of AddTradeCommentRequest
        AddTradeCommentRequest request = mock(AddTradeCommentRequest.class);
        return Collections.singletonList(request);
    }

    private List<CollateralLinkReportDocument> setupValidCollateralLinkDocuments() {
        // Create and return a valid list of mocked CollateralLinkReportDocuments
        List<CollateralLinkReportDocument> documents = new ArrayList<>();
        CollateralLinkReportDocument document = mock(CollateralLinkReportDocument.class);
        when(document.getCollateralLinkReport()).thenReturn(mock(CollateralLinkReport.class));
        documents.add(document);
        return documents;
    }

    private List<EditRequest> setupValidEditRequests() {
        // Create and return a valid list of EditRequest
        EditRequest request = mock(EditRequest.class);
        return Collections.singletonList(request);
    }

    private List<AddTradeJiraReferenceRequest> setupValidJiraReferenceRequests() {
        // Create and return a valid list of AddTradeJiraReferenceRequest
        AddTradeJiraReferenceRequest request = mock(AddTradeJiraReferenceRequest.class);
        return Collections.singletonList(request);
    }
}
