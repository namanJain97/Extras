Could you write all the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

package com.rbs.tntr.business.blotter.web.controllers;

import com.rbs.datafabric.domain.RecordId;
import com.rbs.tntr.business.blotter.security.TntrRole;
import com.rbs.tntr.business.blotter.services.blotterEvents.BlotterEventRepository;
import com.rbs.tntr.business.blotter.services.blotterEvents.BlotterSubscriptionDeletionResult;
import com.rbs.tntr.business.blotter.services.blotterEvents.IndexCreationResult;
import com.rbs.tntr.business.blotter.services.blotterEvents.SubscriptionEventManager;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.web.request.blotterEvents.BlotterEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.annotation.Secured;
import org.springframework.web.bind.annotation.*;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping(value= "api/v1/blotter-events")
@Secured({TntrRole.Name.READONLY})
public class BlotterEventsController {

    static final Logger LOGGER = LoggerFactory.getLogger(BlotterEventsController.class);

    final BlotterEventRepository eventRepository;
    final DateTimeService dateTimeService;
    final SubscriptionEventManager subscriptionEventManager;

    public BlotterEventsController(BlotterEventRepository eventRepository,
                                   DateTimeService dateTimeService,
                                   SubscriptionEventManager subscriptionEventManager
                                   ) {
        this.eventRepository = eventRepository;
        this.dateTimeService = dateTimeService;
        this.subscriptionEventManager = subscriptionEventManager;
    }

    @RequestMapping(method = RequestMethod.POST)
    public ResponseEntity save(@RequestBody BlotterEvent blotterEvent){
        try{
            RecordId recordId = eventRepository.save(blotterEvent);
            return new ResponseEntity(recordId, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error saving blotter event %s",blotterEvent.getEventId());
            LOGGER.error("Error saving blotter event {}",blotterEvent.getEventId(),ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }


    @RequestMapping(value = "bulk",method = RequestMethod.POST)
    public ResponseEntity saveAll(@RequestBody List<BlotterEvent> blotterEvents){
        try{
            List<RecordId> recordIds = eventRepository.saveAll(blotterEvents);
            return new ResponseEntity(recordIds, HttpStatus.OK);
        }catch (Exception ex){
            List<String> eventIds = blotterEvents.stream().map(e->e.getEventId())
                    .collect(Collectors.toList());
            String message = String.format("Error saving blotter events %s",String.join(",",eventIds));
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Secured({TntrRole.Name.ITSUPPORT})
    @RequestMapping(value = "create-indexes",method = RequestMethod.POST)
    public ResponseEntity createIndexesDropExisting(boolean dropExisting){
        try{
            HashMap<String, IndexCreationResult> result = eventRepository.dropAndCreateIndexes(dropExisting);
            return new ResponseEntity(result, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error in creating/recreating indexes");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value="active-subscriptions",method = RequestMethod.GET)
    public ResponseEntity getActiveSubscriptions(@RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date asOf){
        try{
            List<BlotterEvent> activeSubscriptions = eventRepository.getActiveSubscriptions(asOf);
            return new ResponseEntity(activeSubscriptions, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error fetching active subscriptions");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value="by-date-range",method = RequestMethod.GET)
    public ResponseEntity getEventsByDateTime(@RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date  from, @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date to){
        try{
            List<BlotterEvent> activeSubscriptions = eventRepository.eventsByDateRange(from,to);
            return new ResponseEntity(activeSubscriptions, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error fetching subscriptions for date range");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "{date}",method = RequestMethod.GET)
    public ResponseEntity getEventsByDateTime(@PathVariable("date") @DateTimeFormat(pattern = "yyyy-MM-dd") Date date){
        try{
            Date from = date;
            Date to =dateTimeService.addDays(date,1);
            List<BlotterEvent> activeSubscriptions = eventRepository.eventsByDateRange(from,to);
            return new ResponseEntity(activeSubscriptions, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error fetching subscriptions for date");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value="details",method = RequestMethod.POST)
    public ResponseEntity getSubscriptions(@RequestBody List<String> eventIds){
        try{
            List<BlotterEvent> subscriptions = eventRepository.getEvents(eventIds);
            return new ResponseEntity(subscriptions, HttpStatus.OK);
        }catch (Exception ex){
            String message="Error fetching blotter event details";
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value="details/sessions",method = RequestMethod.GET)
    public ResponseEntity getSubscriptions(@RequestParam String sessionId){
        try{
            List<BlotterEvent> subscriptions = eventRepository.getEvents(sessionId);
            return new ResponseEntity(subscriptions, HttpStatus.OK);
        }catch (Exception ex){
            String message="Error fetching blotter event details";
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value="by-user",method = RequestMethod.GET)
    public ResponseEntity getEventsByUser(@RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date from, @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date to, @RequestParam String userName){
        try{
            List<BlotterEvent> activeSubscriptions = eventRepository.getEventsByUser(from,to,userName);
            return new ResponseEntity(activeSubscriptions, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error fetching subscriptions for user");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Secured({TntrRole.Name.ITSUPPORT})
    @RequestMapping(value="active-subscriptions",method = RequestMethod.DELETE)
    public ResponseEntity deleteActiveSubscriptions(@RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date asOf){
        try{

            HashMap<String, BlotterSubscriptionDeletionResult> result
                    = subscriptionEventManager.deleteAllActiveSubscriptions(asOf);
            return new ResponseEntity(result, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error deleting active subscriptions");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Secured({TntrRole.Name.ITSUPPORT})
    @RequestMapping(value="subscriptions/delete",method = RequestMethod.POST)
    public ResponseEntity deleteBlotterSubscriptions(@RequestBody List<String> blotterSubscriptionIds){
        try{
            HashMap<String, BlotterSubscriptionDeletionResult> result
                    = subscriptionEventManager.deleteBlotterSubscriptions(blotterSubscriptionIds);
            return new ResponseEntity(result, HttpStatus.OK);
        }catch (Exception ex){
            String message = String.format("Error deleting active subscriptions");
            LOGGER.error(message,ex);
            return new ResponseEntity(message,HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }


}

Existing test class:

package com.rbs.tntr.business.blotter.web.controllers;

import com.rbs.tntr.business.blotter.services.blotterEvents.BlotterEventRepository;
import com.rbs.tntr.business.blotter.services.blotterEvents.IndexCreationResult;
import com.rbs.tntr.business.blotter.web.request.blotterEvents.BlotterEvent;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class BlotterEventsControllerTest {

    @Mock
    private BlotterEventRepository eventRepository;

    @InjectMocks
    private BlotterEventsController controller;

    private BlotterEvent blotterEvent;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        blotterEvent = new BlotterEvent();
        blotterEvent.setEventId("testEvent");
    }

    // Added exception handling tests for DataFabricSerializerException, UpsertException, OptimisticLockException
    @Test
    public void testSave_DataFabricSerializerException() throws Exception {
        when(eventRepository.save(blotterEvent)).thenThrow(new com.rbs.datafabric.common.DataFabricSerializerException("Serialization Error"));

        ResponseEntity<?> response = controller.save(blotterEvent);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter event"));
    }

    @Test
    public void testSave_UpsertException() throws Exception {
        when(eventRepository.save(blotterEvent)).thenThrow(new com.rbs.datafabric.api.exception.UpsertException("Upsert Error"));

        ResponseEntity<?> response = controller.save(blotterEvent);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter event"));
    }

    @Test
    public void testSave_OptimisticLockException() throws Exception {
        when(eventRepository.save(blotterEvent)).thenThrow(new com.rbs.datafabric.api.exception.OptimisticLockException("Optimistic Lock Error"));

        ResponseEntity<?> response = controller.save(blotterEvent);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter event"));
    }

    @Test
    public void testSaveAll_DataFabricSerializerException() throws Exception {
        List<BlotterEvent> events = Collections.singletonList(blotterEvent);
        when(eventRepository.saveAll(events)).thenThrow(new com.rbs.datafabric.common.DataFabricSerializerException("Serialization Error"));

        ResponseEntity<?> response = controller.saveAll(events);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter events"));
    }

    @Test
    public void testSaveAll_UpsertException() throws Exception {
        List<BlotterEvent> events = Collections.singletonList(blotterEvent);
        when(eventRepository.saveAll(events)).thenThrow(new com.rbs.datafabric.api.exception.UpsertException("Upsert Error"));

        ResponseEntity<?> response = controller.saveAll(events);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter events"));
    }

    @Test
    public void testCreateIndexesDropExisting_Success() throws Exception {
        HashMap<String, IndexCreationResult> mockResult = new HashMap<>();
        when(eventRepository.dropAndCreateIndexes(true)).thenReturn(mockResult);

        ResponseEntity<?> response = controller.createIndexesDropExisting(true);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockResult, response.getBody());
    }

}
