package com.rbs.tntr.business.blotter.services.common;

import com.nwm.tntr.commons.core.SpringContext;
import com.nwm.tntr.commons.enums.ApiQueryFilter;
import com.nwm.tntr.commons.repository.collateral.CollateralTdxRepository;
import com.nwm.tntr.commons.repository.recon.ReconTdxRepository;
import com.nwm.tntr.commons.repository.recon.ReconTdxService;
import com.nwm.tntr.commons.repository.reconBatchTrigger.ReconBatchTriggerRepository;
import com.nwm.tntr.commons.repository.service.tdx.TdxService;
import com.nwm.tntr.commons.repository.trade.TradeTdxRepository;
import com.nwm.tntr.commons.repository.trade.ValuationsTdxRepository;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.tntr.business.blotter.services.reconciliationActions.ReconciliationActionService;
import com.rbs.tntr.business.blotter.web.request.futures.FuturesDashboardSearchRequest;
import com.rbs.tntr.domain.blotter.enums.FlowType;
import com.tdx.client.api.exception.TDXClientFactoryException;
import com.tdx.client.api.exception.TDXException;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.context.ApplicationContext;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class TdxFacadeTest {

    @InjectMocks
    private TdxFacade tdxFacade;

    @Mock
    private ReconTdxService reconTdxService;

    @Mock
    private ReconBatchTriggerRepository reconBatchTriggerRepository;

    @Mock
    private ReconciliationActionService reconciliationActionService;

    @Mock
    private ApplicationContext mockContext;

    @Mock
    private ReconTdxRepository reconTdxRepository;

    @Mock
    private CollateralTdxRepository collateralTdxRepository;

    @Mock
    private ValuationsTdxRepository valuationsTdxRepository;

    @Mock
    private TradeTdxRepository tradeTdxRepository;

    @Mock
    private TdxService reconTdxServiceImpl;

    @Mock
    private TdxService collateralTdxService;

    @Mock
    private TdxService valuationsTdxService;

    @Mock
    private TdxService tradeTdxService;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        // Use reflection to set mock ApplicationContext in SpringContext
        Field contextField = SpringContext.class.getDeclaredField("context");
        contextField.setAccessible(true);
        contextField.set(null, mockContext);

        // Configure mockContext to return mocked repositories
        when(mockContext.getBean(ReconTdxRepository.class)).thenReturn(reconTdxRepository);
        when(mockContext.getBean(CollateralTdxRepository.class)).thenReturn(collateralTdxRepository);
        when(mockContext.getBean(ValuationsTdxRepository.class)).thenReturn(valuationsTdxRepository);
        when(mockContext.getBean(TradeTdxRepository.class)).thenReturn(tradeTdxRepository);

        // Configure repository mocks to return mocked TdxService instances
        when(reconTdxRepository.getTdxService()).thenReturn(reconTdxServiceImpl);
        when(reconTdxRepository.getTdxDataSetName()).thenReturn("reconDataset");
        when(collateralTdxRepository.getTdxService()).thenReturn(collateralTdxService);
        when(collateralTdxRepository.getTdxDataSetName()).thenReturn("collateralDataset");
        when(valuationsTdxRepository.getTdxService()).thenReturn(valuationsTdxService);
        when(valuationsTdxRepository.getTdxDataSetName()).thenReturn("valuationsDataset");
        when(tradeTdxRepository.getTdxService()).thenReturn(tradeTdxService);
        when(tradeTdxRepository.getTdxDataSetName()).thenReturn("tradeDataset");
    }

    @Test
    public void testExecuteReadCommand_ReconBatchTrigger() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONC_BATCH_TRIGGER.getValue(), true, 100, "2023-01-01");
        List<HashMap> expectedList = new ArrayList<>();
        when(reconBatchTriggerRepository.getReconBatchByCriteria("whereClause", "groupByClause", null, true, 100))
                .thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(reconBatchTriggerRepository).getReconBatchByCriteria("whereClause", "groupByClause", null, true, 100);
    }

    @Test
    public void testExecuteReadCommand_Reconciliation() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION.getValue(), false, 0, null);
        EnumMap<ApiQueryFilter, Object> expectedMap = createExpectedMap("selectClause", "whereClause", "groupByClause", false, 0, null);
        List<HashMap> expectedList = new ArrayList<>();
        when(reconTdxServiceImpl.getDocumentByTdxServiceWithGroupBy("reconDataset", expectedMap)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(reconTdxServiceImpl).getDocumentByTdxServiceWithGroupBy("reconDataset", expectedMap);
    }

    @Test
    public void testExecuteReadCommand_ReconciliationDf() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION_DF.getValue(), true, 50, "2023-01-01");
        List<HashMap> expectedList = new ArrayList<>();
        when(reconciliationActionService.executeReadCommand(request)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(reconciliationActionService).executeReadCommand(request);
    }

    @Test
    public void testExecuteReadCommand_Collateral() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.COLLATERAL.getValue(), true, 200, "2023-01-01");
        EnumMap<ApiQueryFilter, Object> expectedMap = createExpectedMap("selectClause", "whereClause", "groupByClause", true, 200, "2023-01-01");
        List<HashMap> expectedList = new ArrayList<>();
        when(collateralTdxService.getDocumentByTdxServiceWithGroupBy("collateralDataset", expectedMap)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(collateralTdxService).getDocumentByTdxServiceWithGroupBy("collateralDataset", expectedMap);
    }

    @Test
    public void testExecuteReadCommand_Valuation() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.VALUATION.getValue(), false, 0, null);
        EnumMap<ApiQueryFilter, Object> expectedMap = createExpectedMap("selectClause", "whereClause", "groupByClause", false, 0, null);
        List<HashMap> expectedList = new ArrayList<>();
        when(valuationsTdxService.getDocumentByTdxServiceWithGroupBy("valuationsDataset", expectedMap)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(valuationsTdxService).getDocumentByTdxServiceWithGroupBy("valuationsDataset", expectedMap);
    }

    @Test
    public void testExecuteReadCommand_OtherFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest("TRADE", true, 150, "2023-01-01");
        EnumMap<ApiQueryFilter, Object> expectedMap = createExpectedMap("selectClause", "whereClause", "groupByClause", true, 150, "2023-01-01");
        List<HashMap> expectedList = new ArrayList<>();
        when(tradeTdxService.getDocumentByTdxServiceWithGroupBy("tradeDataset", expectedMap)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(tradeTdxService).getDocumentByTdxServiceWithGroupBy("tradeDataset", expectedMap);
    }

    @Test
    public void testExecuteReadCommand_NoRowLimit() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION.getValue(), true, 0, "2023-01-01");
        EnumMap<ApiQueryFilter, Object> expectedMap = createExpectedMap("selectClause", "whereClause", "groupByClause", true, 0, "2023-01-01");
        List<HashMap> expectedList = new ArrayList<>();
        when(reconTdxServiceImpl.getDocumentByTdxServiceWithGroupBy("reconDataset", expectedMap)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(reconTdxServiceImpl).getDocumentByTdxServiceWithGroupBy("reconDataset", expectedMap);
    }

    @Test
    public void testExecuteReadCommand_NoAsOf() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.COLLATERAL.getValue(), false, 100, null);
        EnumMap<ApiQueryFilter, Object> expectedMap = createExpectedMap("selectClause", "whereClause", "groupByClause", false, 100, null);
        List<HashMap> expectedList = new ArrayList<>();
        when(collateralTdxService.getDocumentByTdxServiceWithGroupBy("collateralDataset", expectedMap)).thenReturn(expectedList);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertEquals(expectedList, result);
        verify(collateralTdxService).getDocumentByTdxServiceWithGroupBy("collateralDataset", expectedMap);
    }

    @Test(expected = TDXException.class)
    public void testExecuteReadCommand_ReconBatchTrigger_ThrowsTDXException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONC_BATCH_TRIGGER.getValue(), true, 100, "2023-01-01");
        when(reconBatchTriggerRepository.getReconBatchByCriteria(anyString(), anyString(), any(), anyBoolean(), anyInt()))
                .thenThrow(new TDXException("Test TDXException"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = IOException.class)
    public void testExecuteReadCommand_Reconciliation_ThrowsIOException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION.getValue(), false, 0, null);
        when(reconTdxServiceImpl.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
                .thenThrow(new IOException("Test IOException"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = StartableException.class)
    public void testExecuteReadCommand_Collateral_ThrowsStartableException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.COLLATERAL.getValue(), true, 200, "2023-01-01");
        when(collateralTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
                .thenThrow(new StartableException("Test StartableException"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = ScanException.class)
    public void testExecuteReadCommand_Valuation_ThrowsScanException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.VALUATION.getValue(), false, 0, null);
        when(valuationsTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
                .thenThrow(new ScanException("Test ScanException"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = TDXClientFactoryException.class)
    public void testExecuteReadCommand_OtherFlow_ThrowsTDXClientFactoryException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest("TRADE", true, 150, "2023-01-01");
        when(tradeTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
                .thenThrow(new TDXClientFactoryException("Test TDXClientFactoryException"));

        tdxFacade.executeReadCommand(request);
    }

    private FuturesDashboardSearchRequest createRequest(String flow, boolean history, int rowLimit, String asOf) {
        FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
        request.setFlow(flow);
        request.setSelectClause("selectClause");
        request.setWhereClause("whereClause");
        request.setGroupByClause("groupByClause");
        request.setHistory(history);
        request.setRowLimit(rowLimit);
        request.setAsOf(asOf);
        return request;
    }

    private EnumMap<ApiQueryFilter, Object> createExpectedMap(String select, String where, String groupBy, boolean history, int rowLimit, String asOf) {
        EnumшивMap<ApiQueryFilter, Object> map = new EnumMap<>(ApiQueryFilter.class);
        map.put(ApiQueryFilter.SELECT, select);
        map.put(ApiQueryFilter.WHERE, where);
        map.put(ApiQueryFilter.GROUP_BY, groupBy);
        map.put(ApiQueryFilter.HISTORY, history);
        if (rowLimit > 0) {
            map.put(ApiQueryFilter.ROW_LIMIT, rowLimit);
        }
        if (asOf != null && !asOf.isEmpty()) {
            map.put(ApiQueryFilter.AS_OF, asOf);
        }
        return map;
    }
}
