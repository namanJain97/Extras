// Add these test methods to DataFabricExportServiceTest

@Test
public void testFetchAndExportRecordsMultiCollection_ZeroRecords() throws Exception {
    Mockito.when(exportRepo.fetchDfScanById(Mockito.anyString()))
        .thenReturn(createScan("agrakit_blotter_123123", "Transaction,Valuation", "agrakit"));
    Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any()))
        .thenReturn(new ArrayList<>());
    Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
        .thenReturn(new PagedScanResult(Collections.emptyList(), true, "scanId", 1));
    
    boolean result = service.fetchAndExportRecordsMultiCollection(
        Lists.newArrayList(createParam("Transaction")),
        "userName",
        true,
        createScan("scanId", "Transaction", "agrakit"),
        "fileName",
        false
    );
    
    assertTrue(result);
    Mockito.verify(exportRepo, Mockito.times(1)).upsertDfScan(Mockito.any());
}

@Test
public void testPopulateEmailNotification() throws Exception {
    DfExportScan scan = createScan("scanId", "Collection", "user");
    scan.setExportRecordCount(100);
    scan.setExecutionTime("10");
    scan.setLastExecutionDateTime("01-01-2025 12:00:00");
    scan.setExportName("exportFile");
    
    EmailContent emailContent = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "populateEmailNotification", 
        scan
    );
    
    assertNotNull(emailContent);
    assertTrue(emailContent.getEmailBody().contains("100"));
}

@Test
public void testGenerateMiMailContent() throws Exception {
    DfExportScan scan = createScan("scanId", "CONTROL_MI", "MI_EXTRACT");
    scan.setExportRecordCount(50);
    
    String emailContent = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "generateMiMailContent", 
        scan
    );
    
    assertNotNull(emailContent);
    assertTrue(emailContent.contains("CONTROL MI"));
}

@Test
public void testDeleteIncompleteZipFile() throws Exception {
    String zipPath = "test.zip";
    File zipFile = new File(zipPath);
    zipFile.createNewFile();
    
    ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "deleteIncompleteZipFile", 
        zipPath
    );
    
    assertFalse(zipFile.exists());
}

@Test
public void testZipExportFile_Success() throws Exception {
    String fileName = "testFile";
    String csvPath = service.generateOutputFileName(fileName, StringConstants.EXT_CSV);
    new File(csvPath).getParentFile().mkdirs();
    new File(csvPath).createNewFile();
    
    ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "zipExportFile", 
        fileName
    );
    
    File zipFile = new File(service.generateOutputFileName(fileName, StringConstants.EXT_ZIP));
    assertTrue(zipFile.exists());
    zipFile.delete();
}

@Test
public void testZipExportFile_Failure() throws Exception {
    String fileName = "invalidFile";
    ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "zipExportFile", 
        fileName
    );
    // Verify error is logged
}

@Test
public void testGenerateOutputFileName() {
    String miFileName = service.generateOutputFileName("MI_Report", StringConstants.EXT_CSV);
    assertTrue(miFileName.contains("/MI/"));
    
    String regularFileName = service.generateOutputFileName("Report", StringConstants.EXT_CSV);
    assertFalse(regularFileName.contains("/MI/"));
}

@Test
public void testSubmitTask_Success() {
    DfExportJob job = new DfExportJob(
        Lists.newArrayList(createParam("Collection")),
        "user",
        true,
        createScan("scanId", "Collection", "user"),
        "fileName"
    );
    boolean result = service.submitTask(job);
    assertTrue(result);
}

@Test
public void testSubmitTask_InterruptedException() throws Exception {
    Thread.currentThread().interrupt();
    DfExportJob job = new DfExportJob(
        Lists.newArrayList(createParam("Collection")),
        "user",
        true,
        createScan("scanId", "Collection", "user"),
        "fileName"
    );
    boolean result = service.submitTask(job);
    assertFalse(result);
}

@Test
public void testStartScheduledJob_InterruptedException() throws Exception {
    // Use reflection to get the thread and interrupt it
    Thread exportThread = (Thread) ReflectionTestUtils.getField(service, "thread");
    exportThread.interrupt();
    
    // Verify the thread handles interruption
    Mockito.verify(service, Mockito.timeout(1000)).scheduledDfExports();
}

@Test
public void testGenerateMiSnapShotReport_Exception() throws Exception {
    Mockito.when(client.pagedScan(Mockito.any()))
        .thenThrow(new ScanException("DF Error"));
    
    service.generateMiSnapShotReport(
        Lists.newArrayList(createParam("Transaction")),
        createScan("scanId", "Transaction", "MIEXTRACT"),
        "snapshotFileName"
    );
    // Verify error handling
}

@Test
public void testResumeInQueueScans() {
    DfExportScan scan = createScan("scanId", "Collection", "user");
    scan.setExecutionStatus(StringConstants.STATUS_IN_QUEUE);
    Mockito.when(exportRepo.fetchScansWithStatus(StringConstants.STATUS_IN_QUEUE))
        .thenReturn(Lists.newArrayList(scan));
    
    ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "resumeInQueueScans"
    );
    
    Mockito.verify(exportRepo, Mockito.times(1)).fetchScansWithStatus(StringConstants.STATUS_IN_QUEUE);
    Mockito.verify(service, Mockito.times(1)).submitTask(Mockito.any());
}

@Test
public void testGenerateWeeklyKnownMiExport_WithJiraIds() throws Exception {
    Map<String, String> record = new HashMap<>();
    record.put("Jira", "JIRA-123,JIRA-456");
    record.put("Asset Class Final", "FX");
    record.put("Execution Entity Final", "Entity1");
    record.put("Delegated", "Yes");
    record.put("Regulator", "Reg1");
    record.put("Message Type", "Type1");
    record.put("Count", "10");
    
    List<Map<String, String>> records = Lists.newArrayList(record);
    Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any()))
        .thenReturn(records);
    
    boolean result = service.generateWeeklyKnownMiExport(
        Lists.newArrayList(createParam("Transaction")),
        createScan("scanId", "Transaction", "MIEXTRACT"),
        "fileName"
    );
    
    assertTrue(result);
}

@Test
public void testBifurcateKnownRecords_MultipleJiraIds() {
    Map<String, String> record = new HashMap<>();
    record.put("Jira", "JIRA-123,JIRA-456");
    record.put("Asset Class Final", "FX");
    record.put("Execution Entity Final", "Entity1");
    record.put("Delegated", "Yes");
    record.put("Regulator", "Reg1");
    record.put("Message Type", "Type1");
    record.put("Count", "10");
    
    List<Map<String, String>> records = Lists.newArrayList(record);
    List<Map<String, String>> bifurcated = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl,
        "bifurcateKnownRecords",
        records
    );
    
    assertEquals(2, bifurcated.size());
    assertEquals("JIRA-123", bifurcated.get(0).get("Jira"));
}
