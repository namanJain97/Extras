package com.rbs.tntr.business.taggingService.repository;

import static com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIConstants.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nwm.tntr.commons.domain.persistence.constant.AssetClass;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.nwm.tntr.configuration.ItrConfiguration;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.tntr.business.taggingService.service.common.ItrClient;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.*;
import org.junit.Test;
import org.mockito.*;
import org.springframework.test.util.ReflectionTestUtils;

public class MIAnalyticsDashboardRepositoryImplTest {

    // Existing setup and tests are assumed to be included here
    // Only additional test cases are provided below

    @InjectMocks
    MIAnalyticsDashboardRepositoryImpl repo;

    @Mock
    DfConnectionManager dfConn;

    @Mock
    ItrConfiguration itrConfig;

    @Mock
    DataFabricClient dfClient;

    @Mock
    ItrClient itrClient;

    private static final ObjectMapper REAL_OBJECT_MAPPER = new ObjectMapper();
    private static final Date TEST_DATE;

    static {
        try {
            TEST_DATE = new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-19");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private Object invokePrivateMethod(String methodName, Class<?>[] parameterTypes, Object... args) throws Exception {
        Method method = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod(methodName, parameterTypes);
        method.setAccessible(true);
        return method.invoke(repo, args);
    }

    @Test
    public void testDeserialize_Success() throws IOException {
        // Create a valid MIDashboardAnalytics object
        MIDashboardAnalytics original = new MIDashboardAnalytics();
        original.setSubjectIdentifier(new SubjectIdentifier("testLei", "testEntity", "testFlow", "testAsset", "testMessage", "testRegulation", TEST_DATE));
        // Serialize it
        Document document = repo.serialize(original);
        // Deserialize and verify
        MIDashboardAnalytics deserialized = repo.deserailze(document);
        assertNotNull(deserialized);
        assertEquals(original.getSubjectIdentifier().getLei(), deserialized.getSubjectIdentifier().getLei());
        assertEquals(original.getSubjectIdentifier().getEntity(), deserialized.getSubjectIdentifier().getEntity());
        assertEquals(original.getSubjectIdentifier().getFlow(), deserialized.getSubjectIdentifier().getFlow());
        assertEquals(original.getSubjectIdentifier().getAssetClass(), deserialized.getSubjectIdentifier().getAssetClass());
        assertEquals(original.getSubjectIdentifier().getMessageType(), deserialized.getSubjectIdentifier().getMessageType());
        assertEquals(original.getSubjectIdentifier().getRegulation(), deserialized.getSubjectIdentifier().getRegulation());
        assertEquals(original.getSubjectIdentifier().getBusinessDate(), deserialized.getSubjectIdentifier().getBusinessDate());
    }

    @Test(expected = ScanException.class)
    public void testFetchStatistics_ScanException() throws ScanException {
        DFQueryMetaData dfScanParameters = new DFQueryMetaData();
        dfScanParameters.setCollectionName("miCollection");
        when(dfClient.scan(any(ScanRequestBuilder.class))).thenThrow(new ScanException("Test scan exception"));
        repo.fetchStatistics(dfScanParameters, "count");
    }

    @Test
    public void testProcessFoMiData_CFTC_CSA() throws Exception {
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("testStat");
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        Map<String, Map<String, Integer>> mockResult = new HashMap<>();
        mockResult.put(CFTC_CSA, new HashMap<String, Integer>() {{
            put(PLC_REPORTABLE, 1);
            put(PLC_NONREPORTABLE, 2);
            put(PLC_NOTFOUND, 3);
            put(NV_REPORTABLE, 4);
            put(NV_NONREPORTABLE, 5);
            put(NV_NOTFOUND, 6);
        }});
        doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), any(), any(), any(), any());
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
        spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
        verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
    }

    @Test
    public void testProcessFoMiData_SFTR() throws Exception {
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setStatName("testStat");
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        Map<String, Map<String, Integer>> mockResult = new HashMap<>();
        mockResult.put(SFTR, new HashMap<String, Integer>() {{
            put(PLC_REPORTABLE, 1);
            put(PLC_NONREPORTABLE, 2);
            put(PLC_NOTFOUND, 3);
            put(NV_REPORTABLE, 4);
            put(NV_NONREPORTABLE, 5);
            put(NV_NOTFOUND, 6);
        }});
        doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), any(), any(), any(), any());
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
        spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.ETD.value());
        verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
    }

    @Test
    public void testPopulateFoLifeTimeParams() throws Exception {
        Date businessDate = TEST_DATE;
        Map<String, String> params = (Map<String, String>) invokePrivateMethod("populateFoLifeTimeParams", new Class<?>[]{Date.class}, businessDate);
        assertNotNull(params);
        assertEquals(2, params.size());
        assertTrue(params.containsKey(DATETIME_FROM));
        assertTrue(params.containsKey(DATETIME_TO));
        // Optionally verify date formats if DateTimeService behavior is known
    }

    @Test
    public void testItrParameterizedQueryForFo() throws Exception {
        Date businessDate = TEST_DATE;
        String queryId = "testQueryId";
        String selectClause = "select field";
        Itr2ParameterisedQuery iQuery = (Itr2ParameterisedQuery) invokePrivateMethod("itrParameterizedQueryForFo", new Class<?>[]{Date.class, String.class, String.class}, businessDate, queryId, selectClause);
        assertNotNull(iQuery);
        assertEquals(queryId, iQuery.getQueryId());
        assertTrue(iQuery.isStreamResultsEnabled());
        assertTrue(iQuery.isQueryPlanLoggingEnabled());
        Map<String, String> params = iQuery.getParams();
        assertNotNull(params);
        assertEquals(2, params.size());
        assertTrue(params.containsKey(DATETIME_FROM));
        assertTrue(params.containsKey(DATETIME_TO));
    }

    @Test
    public void testPersistFoJurisdictionDetermined() throws Exception {
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        String jurisdiction = EMIR;
        Date businessDate = TEST_DATE;
        Map<String, Integer> itrMiData = new HashMap<>();
        itrMiData.put(PLC_REPORTABLE, 1);
        itrMiData.put(PLC_NONREPORTABLE, 2);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
        invokePrivateMethod("persistFoJurisdictionDetermined", new Class<?>[]{String.class, String.class, Date.class, Map.class}, assetClass, jurisdiction, businessDate, itrMiData);
        verify(spyRepo, times(2)).upsertFoMiSnapshot(any());
    }

    @Test
    public void testPersistFoJurisdictionNotDetermined() throws Exception {
        String assetClass = AssetClass.FOREIGN_EXCHANGE.value();
        Date businessDate = TEST_DATE;
        Integer plcNotFound = 3;
        Integer nvNotFound = 4;
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
        invokePrivateMethod("persistFoJurisdictionNotDetermined", new Class<?>[]{String.class, Date.class, Integer.class, Integer.class}, assetClass, businessDate, plcNotFound, nvNotFound);
        verify(spyRepo, times(2)).upsertFoMiSnapshot(any());
    }

    @Test
    public void testGenerateFoMap() throws Exception {
        Map<String, Integer> foMap = (Map<String, Integer>) invokePrivateMethod("generateFoMap", new Class<?>[]{});
        assertNotNull(foMap);
        assertEquals(6, foMap.size());
        assertEquals(0, foMap.get(PLC_REPORTABLE).intValue());
        assertEquals(0, foMap.get(PLC_NONREPORTABLE).intValue());
        assertEquals(0, foMap.get(PLC_NOTFOUND).intValue());
        assertEquals(0, foMap.get(NV_REPORTABLE).intValue());
        assertEquals(0, foMap.get(NV_NONREPORTABLE).intValue());
        assertEquals(0, foMap.get(NV_NOTFOUND).intValue());
    }

    @Test
    public void testFetchFromItrWithParamQuery_SFTR_Aldop() throws Exception {
        DFQueryMetaData dFQueryMetaData = new DFQueryMetaData();
        Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
        String originalItrUrl = "sftrUrl";
        String jurisdiction = SFTR;
        Date businessDate = TEST_DATE;
        String assetClass = AssetClass.ETD.value();
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        // Mock SFTR_ASSETWISE_QUERY_IDS to include SFTR_ALDOP_QUERY_ID
        Map<String, List<String>> sftrQueryIds = new HashMap<>();
        sftrQueryIds.put(assetClass, Arrays.asList(SFTR_ALDOP_QUERY_ID, "otherQueryId"));
        ReflectionTestUtils.setField(spyRepo, "SFTR_ASSETWISE_QUERY_IDS", sftrQueryIds);
        doNothing().when(spyRepo).fetchData(any(), any(), any(), any(), any());
        invokePrivateMethod("fetchFromItrWithParamQuery", new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                dFQueryMetaData, foMiDataMap, originalItrUrl, jurisdiction, businessDate, assetClass);
        ArgumentCaptor<String> urlCaptor = ArgumentCaptor.forClass(String.class);
        verify(spyRepo, times(2)).fetchData(any(), same(foMiDataMap), urlCaptor.capture(), eq(jurisdiction), same(dFQueryMetaData));
        List<String> capturedUrls = urlCaptor.getAllValues();
        String expectedAldopUrl = spyRepo.getURL((String) ReflectionTestUtils.getField(spyRepo, "foSftrAldopUrl"));
        String expectedOriginalUrl = spyRepo.getURL(originalItrUrl);
        assertTrue(capturedUrls.contains(expectedAldopUrl));
        assertTrue(capturedUrls.contains(expectedOriginalUrl));
    }
}
