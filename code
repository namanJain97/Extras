Could you write all the test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

/**
 * 
 */
package com.rbs.tntr.business.blotter.utility;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Maps;
import com.rbs.tntr.business.blotter.search.querybuilder.LoggedInUserDetails;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;

/**
 * Description : 
 * @author agrakit
 * Created By: Niket Agrawal
 * Created On 05-01-2023
 */
@Configuration
public class BlotterUtil {

	private static final String RESPONSE = "response";

	private static final Logger LOGGER = LoggerFactory.getLogger(BlotterUtil.class);

	private static String userDetailsHost;

	@Value("${loggedin.user.details.endpoint}")
	public void setUserDetailsHost(String hostEndpoint) {
		BlotterUtil.userDetailsHost = hostEndpoint;
	}

	public static LoggedInUserDetails getLoggedInUserDetails(String userRacfId) {
		try {
			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(MediaType.APPLICATION_JSON);
			HttpEntity<Object> entity = new HttpEntity<>(headers);
			HashMap<String, Object> uriVariables = Maps.newHashMap();
			uriVariables.put("userRacfId", userRacfId);
			ResponseEntity<String> response = new RestTemplate().exchange(userDetailsHost, HttpMethod.GET, entity,
					String.class, uriVariables);
			if (response.getStatusCode() == HttpStatus.OK) {
				ObjectMapper mapper = new ObjectMapper();
				JsonNode node = mapper.readTree(response.getBody());
				if (node.hasNonNull(RESPONSE) && node.get(RESPONSE).hasNonNull("docs")
						&& node.get(RESPONSE).get("docs").has(0)) {
					Map<String, Object> userMap = mapper.convertValue(node.get(RESPONSE).get("docs").get(0),
							new TypeReference<Map<String, Object>>() {
							});
					return mapper.convertValue(userMap, LoggedInUserDetails.class);
				} else {
					LOGGER.error("API Response doesnt have User Details");
					throw new BlotterRunTimeException("API Response doesnt have User Details");
				}
			} else {
				LOGGER.error("Error in Response while fetching user details");
				throw new BlotterRunTimeException("Error in Response while fetching user details");
			}
		} catch (IOException ex) {
			LOGGER.error("There was an exception while fetching user details", ex);
			throw new BlotterRunTimeException("There was an exception while fetching user details", ex);
		}
	}
}
