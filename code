package com.rbs.tntr.business.blotter.services;

import com.nwm.tntr.domain.email.EmailContent;
import com.rbs.datafabric.api.PagedScanResult;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.tntr.business.blotter.repository.DataFabricExportRepository;
import com.rbs.tntr.business.blotter.search.querybuilder.DfExportScan;
import com.rbs.tntr.business.blotter.search.querybuilder.DfScanParameters;
import com.rbs.tntr.business.blotter.search.querybuilder.LoggedInUserDetails;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.services.jobs.DfExportJob;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import com.rbs.tntr.domain.blotter.exceptions.ValidationException;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.*;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.slf4j.Logger;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.File;
import java.lang.reflect.Field;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import static com.rbs.tntr.business.blotter.services.common.StringConstants.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyListOf;
import static org.mockito.Matchers.anySetOf;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.*;

public class DataFabricExportServiceImplTest {

    @InjectMocks
    private DataFabricExportServiceImpl dataFabricExportService;

    @Mock
    private DataFabricExportUtility dataFabricExportUtil;
    @Mock
    private CsvWriterImpl csvWriter;
    @Mock
    private ExcelWriterImpl excelWriter;
    @Mock
    private DataFabricExportRepository dfExportRepository;
    @Mock
    private DateTimeService dateTimeService;
    @Mock
    private EmailService emailService;
    @Mock
    private DataFabricClient dataFabricClient;
    @Mock
    private Logger logger;
    @Mock
    private BlockingQueue<DfExportJob> mockQueue;
    @Mock
    private PagedScanResult pagedScanResult;
    @Mock
    private Record record;
    @Mock
    private JsonDocument jsonDocument;
    @Mock
    private Document document;
    @Mock
    private ScanResult scanResult;

    private AutoCloseable closeable;

    @Before
    public void setUp() throws Exception {
        closeable = MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(dataFabricExportService, "outputFilePath", "/test/output");
        ReflectionTestUtils.setField(dataFabricExportService, "miReceiverEmail", "test@example.com");
        ReflectionTestUtils.setField(dataFabricExportService, "exportThresholdCount", 1000);
        ReflectionTestUtils.setField(dataFabricExportService, "exportThresholdCountFeature", true);
        ReflectionTestUtils.setField(dataFabricExportService, "zippedExportFeature", true);
        ReflectionTestUtils.setField(dataFabricExportService, "emailNotificationFeature", true);
        ReflectionTestUtils.setField(dataFabricExportService, "exportPageCount", 100);
        ReflectionTestUtils.setField(dataFabricExportService, "smtpHost", "smtp.example.com");
        ReflectionTestUtils.setField(dataFabricExportService, "emailFrom", "noreply@example.com");
        ReflectionTestUtils.setField(dataFabricExportService, "queue", new LinkedBlockingQueue<>());

        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dataFabricClient);
        when(dataFabricClient.pagedScan(any(ScanRequestBuilder.class))).thenReturn(pagedScanResult);
        when(pagedScanResult.getRecords()).thenReturn(Collections.singletonList(record));
        when(record.getDocument()).thenReturn(document);
        when(document.getContents()).thenReturn("{\"totalCount\":10}");
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);
    }

    @Test
    public void testCalculateThresholdCount() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("testCollection");
        List<DfScanParameters> scanParamList = Collections.singletonList(scanParam);

        int result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "calculateThresholdCount", 
            scanParamList, 
            "testUser"
        );
        assertEquals(10, result);
    }

    @Test
    public void testModifyFileName() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("Reconciliation");
        List<DfScanParameters> scanParamList = Collections.singletonList(scanParam);
        when(record.getDocument()).thenReturn(jsonDocument);
        when(jsonDocument.getContents()).thenReturn("{\"identifier\":\"ID123\",\"reconciliationBusinessDateTime\":\"2023-01-01T00:00:00Z\"}");

        String result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "modifyFileName", 
            scanParamList, 
            "originalFileName"
        );
        assertEquals("ID123_2023-01-01_originalFileName", result);
    }

    @Test
    public void testGenerateScanRequestId() {
        String result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "generateScanRequestId", 
            "testUser"
        );
        assertTrue(result.startsWith("testUser_scan_req_"));
    }

    @Test
    public void testFilterLatestScanList_Valid() {
        DfExportScan scan = new DfExportScan();
        scan.setLastExecutionDateTime("01-01-2023 12:00:00");
        when(dateTimeService.getCurrentUTCDateTime()).thenReturn(new DateTime(2023, 1, 1, 12, 0));
        when(dateTimeService.getDirectPastDateTime(any(DateTime.class), anyInt())).thenReturn(new DateTime(2023, 1, 1, 11, 0));

        boolean result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "filterLatestScanList", 
            scan
        );
        assertTrue(result);
    }

    @Test
    public void testPopulateNextRunDate_TimeAfterCurrent() throws ParseException {
        SimpleDateFormat sdf = new SimpleDateFormat("hh:mm a");
        Date testTime = sdf.parse("11:00 AM");
        when(dateTimeService.getCurrentUTCDateTime()).thenReturn(new DateTime().withHourOfDay(10));

        Date result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "populateNextRunDate", 
            "11:00 AM"
        );
        assertEquals(testTime, result);
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testPopulateNextRunDate_InvalidTime() {
        ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "populateNextRunDate", 
            "invalidTime"
        );
    }

    @Test
    public void testFetchCsvRecords_WithAppend() {
        Set<String> headers = new LinkedHashSet<>(Arrays.asList("header1", "header2"));
        List<Map<String, String>> recordList = new ArrayList<>();
        Map<String, String> recordMap = new HashMap<>();
        recordMap.put("header1", "value1");
        recordList.add(recordMap);

        List<String[]> result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "fetchCsvRecords", 
            recordList, 
            headers, 
            true
        );
        assertEquals(1, result.size()); // Only data rows (no header)
    }

    @Test
    public void testWriteDataToFile_Success() throws IOException {
        DfExportScan scan = new DfExportScan();
        scan.setExportFileFormat("CSV");
        List<String[]> rows = new ArrayList<>();
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);

        boolean result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "writeDataToFile", 
            scan, 
            "testFile", 
            rows
        );
        assertTrue(result);
    }

    @Test
    public void testGenerateOutputFileName_MI() {
        String result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "generateOutputFileName", 
            "MI_testFile", 
            "zip"
        );
        assertTrue(result.contains("/test/output/") && result.contains("/MI/"));
    }

    @Test
    public void testStartScheduledJob() throws InterruptedException {
        // Setup a job in the queue
        DfExportJob job = new DfExportJob(
            Collections.emptyList(), 
            "testUser", 
            true, 
            new DfExportScan(), 
            "testFile"
        );
        dataFabricExportService.submitTask(job);
        
        // Start the job executor thread
        ReflectionTestUtils.invokeMethod(dataFabricExportService, "startScheduledJob");
        Thread.sleep(500); // Allow time for thread execution
        
        // Verify job processing
        verify(dfExportRepository, atLeastOnce()).upsertDfScan(any(DfExportScan.class));
    }

    @Test
    public void testResumeInQueueScans() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScan");
        scan.setExecutionStatus(STATUS_IN_QUEUE);
        when(dfExportRepository.fetchScansWithStatus(STATUS_IN_QUEUE)).thenReturn(Collections.singletonList(scan));
        
        ReflectionTestUtils.invokeMethod(dataFabricExportService, "resumeInQueueScans");
        verify(dfExportRepository).fetchScansWithStatus(STATUS_IN_QUEUE);
        assertFalse(dataFabricExportService.queue.isEmpty());
    }

    @Test
    public void testZipExportFile_Success() throws Exception {
        File testFile = File.createTempFile("test", ".csv");
        testFile.deleteOnExit();
        ReflectionTestUtils.setField(dataFabricExportService, "outputFilePath", testFile.getParent());
        
        ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "zipExportFile", 
            testFile.getName().replace(".csv", "")
        );
        
        File zipFile = new File(testFile.getParent() + "/" + testFile.getName().replace(".csv", ".zip"));
        assertTrue(zipFile.exists());
        zipFile.deleteOnExit();
    }

    @Test
    public void testPopulateDynamicDate() {
        String clause = "date > [D-1]";
        String result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "populateDynamicDate", 
            clause
        );
        assertTrue(result.contains("'"));
    }

    @Test
    public void testPopulateEmailNotification() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        scan.setBlotterName("TestBlotter");
        scan.setExportRecordCount(100);
        scan.setExecutionTime("10");
        scan.setLastExecutionDateTime("01-01-2023 12:00:00");
        
        EmailContent result = ReflectionTestUtils.invokeMethod(
            dataFabricExportService, 
            "populateEmailNotification", 
            scan
        );
        assertNotNull(result);
    }

    @Test
    public void testGenerateForcedExport() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("forcedScan");
        when(dfExportRepository.fetchDfScanById("forcedScan")).thenReturn(scan);
        
        dataFabricExportService.generateForcedExport("forcedScan", "testUser");
        assertFalse(dataFabricExportService.queue.isEmpty());
    }

    // Clean up mocks
    public void tearDown() throws Exception {
        closeable.close();
    }
}
