/**
 * Description : ObjectManagementUtility Test Class
 * @author agrakit
 * Created By : Niket Agrawal
 * Created On : 02-Jul-2022	
 */
package com.rbs.tntr.business.blotter.utility;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.AllocationType;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralLeg;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder;
import com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData;
import com.rbs.tntr.business.blotter.services.common.StringConstants;

public class ObjectManagementUtilityTest {

	private ObjectManagementUtility utilObj;
	
	// Mock objects for testing exception scenarios
	@Mock
	private Object mockObject;

	@Before
	public void setup() {
		utilObj = new ObjectManagementUtility();
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testTradeObjectCompare() {
		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData existingReportableData = com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData
					.newBuilder().withAction("action").withBuyer("buyer").withIndexSeries(2)
					.withTradeParty1MandatoryClearing(true)
					.withAsOfDateTime(ZonedDateTime.parse("2022-09-30T00:00:00.000Z")).build();
		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData updatedReportableData = com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData
					.newBuilder().withAction("editedAction").withBuyer("buyer").withIndexSeries(1)
					.withTradeParty1MandatoryClearing(true)
					.withAsOfDateTime(ZonedDateTime.parse("2022-09-03T00:00:00.000Z")).build();

		String editedFields = utilObj.compareAndGetDiff(existingReportableData, updatedReportableData);
		assertEquals("action,indexSeries,asOfDateTime", editedFields);
	}

	@Test
	public void testValObjectCompare() {
		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData existingReportableData = com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData
					.newBuilder().withClearingStatus("clearingStatus")
					.withTradeParty1ValuationAmount(BigDecimal.valueOf(Double.valueOf("10000"))).withAction("action")
					.build();

		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData updatedReportableData = com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData
					.newBuilder().withClearingStatus("clearingStatusChanged")
					.withTradeParty1ValuationAmount(BigDecimal.valueOf(Double.valueOf("10"))).withAction("action")
					.build();

		String editedFields = utilObj.compareAndGetDiff(existingReportableData, updatedReportableData);
		assertEquals("clearingStatus,tradeParty1ValuationAmount", editedFields);
	}

	@Test
	public void testCVMObjectCompare() {
		com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData existingReportableData = com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData
					.newBuilder().withAction("action")
					.withExcessCollateralPosted(BigDecimal.valueOf(Double.valueOf("100"))).build();

		com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData updatedReportableData = com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData
					.newBuilder().withAction("action")
					.withExcessCollateralPosted(BigDecimal.valueOf(Double.valueOf("100"))).build();

		String editedFields = utilObj.compareAndGetDiff(existingReportableData, updatedReportableData);
		assertEquals(StringConstants.NO_FIELD_EDITED, editedFields);
	}

	@Test
	public void testCollObjectCompare() {
		com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData existingReportableData = com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData
					.newBuilder().withAction("action")
					.withExcessCollateralPosted(BigDecimal.valueOf(Double.valueOf("100"))).build();

		com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData updatedReportableData = com.nwm.tntr.commons.domain.persistence.entity.collateral.ReportableData
					.newBuilder().withAction("action")
					.withExcessCollateralPosted(BigDecimal.valueOf(Double.valueOf("1"))).build();

		String editedFields = utilObj.compareAndGetDiff(existingReportableData, updatedReportableData);
		assertEquals("excessCollateralPosted", editedFields);
	}

	@Test
	public void testCLMObjectCompare() {
		com.nwm.tntr.commons.domain.persistence.entity.collaterallink.ReportableData existingReportableData = com.nwm.tntr.commons.domain.persistence.entity.collaterallink.ReportableData
					.newBuilder().withAction("action")
					.withExcessCollateralPosted(BigDecimal.valueOf(Double.valueOf("100")))
					.withReportingTimestamp(ZonedDateTime.parse("2022-09-30T00:00:00.000Z")).build();

		com.nwm.tntr.commons.domain.persistence.entity.collaterallink.ReportableData updatedReportableData = com.nwm.tntr.commons.domain.persistence.entity.collaterallink.ReportableData
					.newBuilder().withAction("action")
					.withExcessCollateralPosted(BigDecimal.valueOf(Double.valueOf("1")))
					.withReportingTimestamp(ZonedDateTime.parse("2022-09-30T00:00:00.000Z")).build();

		String editedFields = utilObj.compareAndGetDiff(existingReportableData, updatedReportableData);
		assertEquals("excessCollateralPosted", editedFields);
	}

	@Test
	public void testObjectBuilder() throws JsonParseException, JsonMappingException, IOException {
		String inputJsonData = "{\"action\":\"action\",\"asOfDateTime\":\"2022-09-30T00:00:00.000Z\",\"leg1NotionalAmount\":\"1000\"}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData existingObj = com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData
					.newBuilder().withAction("action").withAsOfDateTime(ZonedDateTime.parse("2022-09-30T00:00:00.000Z"))
					.withLeg1NotionalAmount(BigDecimal.valueOf(Double.valueOf("1000"))).build();

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder updatedBuilder = (Builder) utilObj
					.buildObjectBuilder(
								com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.newBuilder(),
								updatedReportableFields);
		String editedFields = utilObj.compareAndGetDiff(existingObj, updatedBuilder.build());
		assertEquals(StringConstants.NO_FIELD_EDITED, editedFields);
	}
	
	@Test
	public void testObjectBuilderWithEdit() throws JsonParseException, JsonMappingException, IOException {
		String inputJsonData = "{\"action\":\"updatedAction\",\"allocationType\":\"PREA\",\"asOfDateTime\":\"2022-08-30T00:00:00.000Z\",\"leg1NotionalAmount\":\"10\",\"tradeParty1MandatoryClearing\":\"true\"}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData existingObj = com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData
					.newBuilder().withAction("action").withAllocationType(AllocationType.POST_ALLOCATED).withAsOfDateTime(ZonedDateTime.parse("2022-09-30T00:00:00.000Z"))
					.withLeg1NotionalAmount(BigDecimal.valueOf(Double.valueOf("1000"))).build();

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder updatedBuilder = (Builder) utilObj
					.buildObjectBuilder(
								com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.newBuilder(),
								updatedReportableFields);
		String editedFields = utilObj.compareAndGetDiff(existingObj, updatedBuilder.build());
		assertEquals("action,leg1NotionalAmount,tradeParty1MandatoryClearing,asOfDateTime,allocationType", editedFields);
	}

	@Test
	public void testObjectBuilderWithEmpty() throws JsonParseException, JsonMappingException, IOException {
		String inputJsonData = "{\"action\":\"EMPTY\",\"asOfDateTime\":\"EMPTY\",\"leg1NotionalAmount\":\"EMPTY\"}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData existingObj = com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData
					.newBuilder().withAction("action").withAsOfDateTime(ZonedDateTime.parse("2022-09-30T00:00:00.000Z"))
					.withLeg1NotionalAmount(BigDecimal.valueOf(Double.valueOf("1000"))).build();

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder updatedBuilder = (Builder) utilObj
					.buildObjectBuilder(
								com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.newBuilder(),
								updatedReportableFields);
		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData updatedReportable = updatedBuilder.build();
		String editedFields = utilObj.compareAndGetDiff(existingObj, updatedReportable);
		assertEquals("action,leg1NotionalAmount,asOfDateTime", editedFields);
		assertNull(updatedReportable.getAction());
		assertNull(updatedReportable.getAsOfDateTime());
		assertNull(updatedReportable.getLeg1NotionalAmount());
	}

	@Test
	public void testIsSuppressedEventSwitching() throws JsonParseException, JsonMappingException, IOException {
		String inputJsonData = "{\"isSuppressedEventSwitching\":true}";
		Object inputReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		Builder builderWithUpdatedFields = (com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder) utilObj
				.buildObjectBuilder(com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.newBuilder(),
						inputReportableFields);
		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData updatedReportableData = builderWithUpdatedFields.build();
		
		assertTrue(updatedReportableData.getIsSuppressedEventSwitching());
	}

	@Test
	public void testObjectWithNesttedObjects() throws IOException {
		String inputJsonData = "{\"tradeParty1NatureOfReportingCpty\": \"test\",\"collateralLegListCount\": 1,\"collateralLegList\": {\"productIdentification\": \"XS1897340854\",\"counterpartySide\": \"WHOLE\"}}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData existingObj = com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData
				.newBuilder().withAction("action").withTradeParty1NatureOfReportingCpty("FC").build();

		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData.Builder updatedBuilder = (ReportableData.Builder) utilObj
				.buildObjectBuilder(
						com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData.newBuilder(),
						updatedReportableFields);
		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData updatedReportable = updatedBuilder.build();
		String editedFields = utilObj.compareAndGetDiff(existingObj, updatedReportable);
		assertEquals("action,tradeParty1NatureOfReportingCpty,collateralLegList.productIdentification,collateralLegList.counterpartySide", editedFields);
	}

	@Test(expected = BlotterRunTimeException.class)
	public void testFprException() throws IOException {
		String inputJsonData = "{\"action\":\"EMPTY\",\"asOfDateTime\":\"EMPTY\",\"leg1NotionalAmount\":\"a\"}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData existingObj = com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData
				.newBuilder().withAction("action").withAsOfDateTime(ZonedDateTime.parse("2022-09-30T00:00:00.000Z"))
				.withLeg1NotionalAmount(BigDecimal.valueOf(Double.valueOf("1000"))).build();

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder updatedBuilder = (Builder) utilObj
				.buildObjectBuilder(
						com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.newBuilder(),
						updatedReportableFields);
		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData updatedReportable = updatedBuilder.build();
	}

	// NEW TEST CASES FOR 100% COVERAGE

	@Test
	public void testCompareAndGetDiffWithBothNullValues() {
		// Test case for both null values scenario
		TestObject obj1 = new TestObject();
		TestObject obj2 = new TestObject();
		
		String result = utilObj.compareAndGetDiff(obj1, obj2);
		assertEquals(StringConstants.NO_FIELD_EDITED, result);
	}

	@Test
	public void testCompareAndGetDiffWithOneNullValue() {
		// Test case where one object has null value and other has non-null
		TestObject obj1 = new TestObject();
		obj1.setStringField("test");
		TestObject obj2 = new TestObject();
		obj2.setStringField(null);
		
		String result = utilObj.compareAndGetDiff(obj1, obj2);
		assertEquals("stringField", result);
	}

	@Test
	public void testCompareAndGetDiffWithCollateralLegListNull() {
		// Test collateralLegList with null values
		TestObjectWithCollateralLegList obj1 = new TestObjectWithCollateralLegList();
		obj1.setCollateralLegList(null);
		TestObjectWithCollateralLegList obj2 = new TestObjectWithCollateralLegList();
		obj2.setCollateralLegList(Lists.newArrayList(CollateralLeg.newBuilder().build()));
		
		String result = utilObj.compareAndGetDiff(obj1, obj2);
		assertTrue(result.contains("collateralLegList"));
	}

	@Test
	public void testCompareAndGetDiffWithListDifferentSizes() {
		// Test case where lists have different sizes
		TestObjectWithList obj1 = new TestObjectWithList();
		obj1.setTestList(Arrays.asList("item1", "item2"));
		TestObjectWithList obj2 = new TestObjectWithList();
		obj2.setTestList(Arrays.asList("item1"));
		
		String result = utilObj.compareAndGetDiff(obj1, obj2);
		assertEquals("testList", result);
	}

	@Test
	public void testCompareNestedObjectsWithDifferentClasses() throws Exception {
		// Test compareNestedObjects with different classes using reflection
		Method method = ObjectManagementUtility.class.getDeclaredMethod("compareNestedObjects", Object.class, Object.class, String.class);
		method.setAccessible(true);
		
		String obj1 = "test";
		Integer obj2 = 123;
		
		@SuppressWarnings("unchecked")
		List<String> result = (List<String>) method.invoke(utilObj, obj1, obj2, "testField");
		assertEquals(1, result.size());
		assertEquals("testField", result.get(0));
	}

	@Test
	public void testCompareNestedObjectsWithNullValues() throws Exception {
		// Test compareNestedObjects with null values
		Method method = ObjectManagementUtility.class.getDeclaredMethod("compareNestedObjects", Object.class, Object.class, String.class);
		method.setAccessible(true);
		
		TestObject obj1 = new TestObject();
		obj1.setStringField("test");
		TestObject obj2 = new TestObject();
		obj2.setStringField(null);
		
		@SuppressWarnings("unchecked")
		List<String> result = (List<String>) method.invoke(utilObj, obj1, obj2, "testField");
		assertTrue(result.contains("testField.stringField"));
	}

	@Test
	public void testBuildObjectBuilderWithBlankFieldValue() throws IOException {
		// Test buildObjectBuilder with blank field value
		String inputJsonData = "{\"action\":\"\",\"buyer\":\"testBuyer\"}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.Builder builder = 
			com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData.newBuilder();
		
		utilObj.buildObjectBuilder(builder, updatedReportableFields);
		
		// The blank action field should be skipped
		com.nwm.tntr.commons.domain.persistence.entity.trade.ReportableData result = builder.build();
		assertNull(result.getAction());
		assertEquals("testBuyer", result.getBuyer());
	}

	@Test
	public void testBuildObjectBuilderWithCollateralLegListCount0() throws IOException {
		// Test with collateralLegListCount = 0
		String inputJsonData = "{\"collateralLegListCount\": \"0\",\"collateralLegList\": {\"productIdentification\": \"test\"}}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData.Builder builder = 
			com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData.newBuilder();
		
		utilObj.buildObjectBuilder(builder, updatedReportableFields);
		
		// Should handle collateralLegListCount = 0
		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData result = builder.build();
		assertNull(result.getCollateralLegList());
	}

	@Test
	public void testBuildObjectBuilderWithCollateralLegListInvalidCount() throws IOException {
		// Test with invalid collateralLegListCount
		String inputJsonData = "{\"collateralLegListCount\": \"2\",\"collateralLegList\": {\"productIdentification\": \"test\"}}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);

		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData.Builder builder = 
			com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData.newBuilder();
		
		utilObj.buildObjectBuilder(builder, updatedReportableFields);
		
		// Should not process collateralLegList with invalid count
		com.nwm.tntr.commons.domain.persistence.entity.valuation.ReportableData result = builder.build();
		assertNull(result.getCollateralLegList());
	}

	@Test
	public void testIsCollateralLegCountValidWithNull() throws Exception {
		// Test isCollateralLegCountValid with null count
		Method method = ObjectManagementUtility.class.getDeclaredMethod("isCollateralLegCountValid", Map.class);
		method.setAccessible(true);
		
		Map<String, String> inputFields = new HashMap<>();
		inputFields.put("collateralLegListCount", null);
		
		Boolean result = (Boolean) method.invoke(utilObj, inputFields);
		assertFalse(result);
	}

	@Test
	public void testAreAllFieldsNullWithNullObject() throws Exception {
		// Test areAllFieldsNull with null object
		Method method = ObjectManagementUtility.class.getDeclaredMethod("areAllFieldsNull", Object.class);
		method.setAccessible(true);
		
		Boolean result = (Boolean) method.invoke(utilObj, (Object) null);
		assertTrue(result);
	}

	@Test
	public void testAreAllFieldsNullWithNonNullFields() throws Exception {
		// Test areAllFieldsNull with non-null fields
		Method method = ObjectManagementUtility.class.getDeclaredMethod("areAllFieldsNull", Object.class);
		method.setAccessible(true);
		
		TestObject obj = new TestObject();
		obj.setStringField("test");
		
		Boolean result = (Boolean) method.invoke(utilObj, obj);
		assertFalse(result);
	}

	@Test
	public void testAreAllFieldsNullWithAllNullFields() throws Exception {
		// Test areAllFieldsNull with all null fields
		Method method = ObjectManagementUtility.class.getDeclaredMethod("areAllFieldsNull", Object.class);
		method.setAccessible(true);
		
		TestObject obj = new TestObject();
		
		Boolean result = (Boolean) method.invoke(utilObj, obj);
		assertTrue(result);
	}

	@Test(expected = BlotterRunTimeException.class)
	public void testAreAllFieldsNullWithException() throws Exception {
		// Test areAllFieldsNull with reflection exception
		Method method = ObjectManagementUtility.class.getDeclaredMethod("areAllFieldsNull", Object.class);
		method.setAccessible(true);
		
		// Create a mock object that will throw IllegalAccessException
		Object mockObj = mock(Object.class);
		when(mockObj.getClass()).thenReturn(TestObject.class);
		
		method.invoke(utilObj, mockObj);
	}

	@Test
	public void testSetFieldValueWithAllDataTypes() throws Exception {
		// Test setFieldValue with all supported data types
		TestObjectWithAllTypes obj = new TestObjectWithAllTypes();
		
		Method method = ObjectManagementUtility.class.getDeclaredMethod("setFieldValue", Object.class, Field.class, String.class);
		method.setAccessible(true);
		
		// Test String
		Field stringField = TestObjectWithAllTypes.class.getDeclaredField("stringField");
		stringField.setAccessible(true);
		method.invoke(utilObj, obj, stringField, "testString");
		assertEquals("testString", obj.getStringField());
		
		// Test ZonedDateTime
		Field dateField = TestObjectWithAllTypes.class.getDeclaredField("dateField");
		dateField.setAccessible(true);
		method.invoke(utilObj, obj, dateField, "2022-09-30T00:00:00.000Z");
		assertNotNull(obj.getDateField());
		
		// Test Double
		Field doubleField = TestObjectWithAllTypes.class.getDeclaredField("doubleField");
		doubleField.setAccessible(true);
		method.invoke(utilObj, obj, doubleField, "123.45");
		assertEquals(Double.valueOf(123.45), obj.getDoubleField());
		
		// Test BigDecimal
		Field bigDecimalField = TestObjectWithAllTypes.class.getDeclaredField("bigDecimalField");
		bigDecimalField.setAccessible(true);
		method.invoke(utilObj, obj, bigDecimalField, "999.99");
		assertEquals(new BigDecimal("999.99"), obj.getBigDecimalField());
		
		// Test Integer
		Field intField = TestObjectWithAllTypes.class.getDeclaredField("intField");
		intField.setAccessible(true);
		method.invoke(utilObj, obj, intField, "42");
		assertEquals(Integer.valueOf(42), obj.getIntField());
		
		// Test Boolean
		Field boolField = TestObjectWithAllTypes.class.getDeclaredField("boolField");
		boolField.setAccessible(true);
		method.invoke(utilObj, obj, boolField, "true");
		assertTrue(obj.getBoolField());
		
		// Test Float
		Field floatField = TestObjectWithAllTypes.class.getDeclaredField("floatField");
		floatField.setAccessible(true);
		method.invoke(utilObj, obj, floatField, "3.14");
		assertEquals(Float.valueOf(3.14f), obj.getFloatField());
		
		// Test Long
		Field longField = TestObjectWithAllTypes.class.getDeclaredField("longField");
		longField.setAccessible(true);
		method.invoke(utilObj, obj, longField, "1234567890");
		assertEquals(Long.valueOf(1234567890L), obj.getLongField());
	}

	@Test
	public void testSetFieldValueWithEnumFromValue() throws Exception {
		// Test enum with fromValue method
		TestObjectWithEnum obj = new TestObjectWithEnum();
		
		Method method = ObjectManagementUtility.class.getDeclaredMethod("setFieldValue", Object.class, Field.class, String.class);
		method.setAccessible(true);
		
		Field enumField = TestObjectWithEnum.class.getDeclaredField("allocationType");
		enumField.setAccessible(true);
		method.invoke(utilObj, obj, enumField, "PREA");
		assertEquals(AllocationType.PRE_ALLOCATED, obj.getAllocationType());
	}

	@Test
	public void testPopulateJsonFieldsWithNestedObjects() {
		// Test populateJsonFields with nested JSON objects
		Map<String, Object> nestedData = new HashMap<>();
		nestedData.put("nestedField", "nestedValue");
		
		Map<String, Object> testData = new HashMap<>();
		testData.put("simpleField", "simpleValue");
		testData.put("nestedObject", nestedData);
		
		Map<String, String> result = utilObj.populateJsonFields(testData);
		
		assertEquals("simpleValue", result.get("simpleField"));
		assertTrue(result.get("nestedObject").contains("nestedField"));
		assertTrue(result.get("nestedObject").contains("nestedValue"));
	}

	@Test(expected = BlotterRunTimeException.class)
	public void testCompareAndGetDiffWithIllegalAccessException() throws Exception {
		// Test exception handling in compareAndGetDiff
		TestObject obj1 = new TestObject();
		TestObject obj2 = new TestObject();
		
		// Use reflection to create a scenario that would cause IllegalAccessException
		Field field = TestObject.class.getDeclaredField("stringField");
		field.setAccessible(false); // Make field inaccessible
		
		// This should trigger the exception handling
		utilObj.compareAndGetDiff(obj1, obj2);
	}

	@Test(expected = BlotterRunTimeException.class)
	public void testBuildObjectBuilderWithReflectiveOperationException() throws IOException {
		// Test exception handling in buildObjectBuilder with invalid data type
		String inputJsonData = "{\"invalidField\":\"invalidValue\"}";
		Object updatedReportableFields = new ObjectMapper().readValue(inputJsonData, Object.class);
		
		// Create a test object that will cause reflection issues
		TestObjectWithInvalidSetter testObj = new TestObjectWithInvalidSetter();
		
		utilObj.buildObjectBuilder(testObj, updatedReportableFields);
	}

	@Test
	public void testPopulateEditedFieldsWithSingleProperty() throws Exception {
		// Test populateEditedFields with single property
		Method method = ObjectManagementUtility.class.getDeclaredMethod("populateEditedFields", List.class);
		method.setAccessible(true);
		
		List<String> properties = Arrays.asList("singleProperty");
		String result = (String) metho
