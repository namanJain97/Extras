// Add these tests to the existing ReconciliationActionServiceImplTest class

@Test
public void testGetReconWithComments_UserValidationFailure() throws Exception {
    // Mock BreakManagement with different user
    BreakManagement breakManagement = BreakManagement.newBuilder()
        .withLastActionUser("other_user")
        .build();
    
    ReconReport reconReport = ReconReport.newBuilder()
        .withBreakManagement(breakManagement)
        .build();
    
    ReconReportDocument reconReportDocument = new ReconReportDocument(
        DocumentId.from("id", 1L), 
        DocumentLifetime.from(ZonedDateTime.now(), ZonedDateTime.now()),
        reconReport
    );
    
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(reconReportDocument.getDocumentId(), new AddReconciliationComment());
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    List<Pair<ReconReport, Long>> result = reconciliationServiceImpl.getReconWithComments(
        Lists.newArrayList(reconReportDocument),
        requests,
        writeResults
    );
    
    Assert.assertTrue(result.isEmpty());
    Assert.assertEquals(1, writeResults.size());
    Assert.assertEquals(ActionRequestValidator.USER_VALIDATION_ERROR, writeResults.get(0).getErrorMessage());
}

@Test
public void testGetReconWithComments_Exception() {
    // Mock data to cause exception
    ReconReportDocument reconReportDocument = getTestReconReport();
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(reconReportDocument.getDocumentId(), new AddReconciliationComment());
    
    // Use spy to throw exception in dataUpdater
    ReconDataUpdater spyUpdater = Mockito.spy(new ReconDataUpdater());
    Mockito.doThrow(new RuntimeException("Test exception")).when(spyUpdater)
        .addCommentsToException(Mockito.any(), Mockito.any(), Mockito.any());
    
    ReconciliationActionServiceImpl service = new ReconciliationActionServiceImpl(
        dfReconPersistManager, spyUpdater, blotterSecurityService, requestValidator
    );
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    Assert.assertThrows(BlotterRunTimeException.class, () -> 
        service.getReconWithComments(
            Lists.newArrayList(reconReportDocument),
            requests,
            writeResults
        )
    );
}

@Test
public void testGetReconWithWorkflow_UserValidationFailure() throws Exception {
    // Similar setup to testGetReconWithComments_UserValidationFailure
    // ...
}

@Test
public void testGetReconWithBreakResolution_Exception() {
    // Mock data to cause exception
    AssignPAndMBreakResolution request = new AssignPAndMBreakResolution();
    List<ReconReportDocument> documents = Lists.newArrayList(getTestReconReport());
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Use spy to throw exception
    ReconDataUpdater spyUpdater = Mockito.spy(new ReconDataUpdater());
    Mockito.doThrow(new RuntimeException("Test exception")).when(spyUpdater)
        .assignPAndMBreakResolution(Mockito.any(), Mockito.any());
    
    ReconciliationActionServiceImpl service = new ReconciliationActionServiceImpl(
        dfReconPersistManager, spyUpdater, blotterSecurityService, requestValidator
    );
    
    Assert.assertThrows(BlotterRunTimeException.class, () ->
        service.getReconWithBreakResolution(documents, request, writeResults)
    );
}

@Test
public void testGetReconWithDueDate_UserValidationFailure() throws Exception {
    // Similar setup to testGetReconWithComments_UserValidationFailure
    // ...
}

@Test
public void testGetPAndMRecordsWithBreakOwner_UserValidationFailure() throws Exception {
    // Similar setup to testGetReconWithComments_UserValidationFailure
    // ...
}

@Test
public void testGetReconWithJiraId_UserValidationFailure() throws Exception {
    // Similar setup to testGetReconWithComments_UserValidationFailure
    // ...
}

@Test
public void testGetReconWithJiraId_JiraIdPresent() throws Exception {
    // Setup existing JIRA ID in BreakManagement
    BreakManagement breakManagement = BreakManagement.newBuilder()
        .setIssueTrackingReferences(Lists.newArrayList("EXISTING_JIRA"))
        .build();
    
    ReconReport reconReport = ReconReport.newBuilder()
        .withBreakManagement(breakManagement)
        .build();
    
    ReconReportDocument reconReportDocument = new ReconReportDocument(
        DocumentId.from("id", 1L), 
        DocumentLifetime.from(ZonedDateTime.now(), ZonedDateTime.now()),
        reconReport
    );
    
    AddReconciliationJiraReference request = new AddReconciliationJiraReference();
    request.getJiraReference().setJiraId("EXISTING_JIRA");
    
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(reconReportDocument.getDocumentId(), request);
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    List<Pair<ReconReport, Long>> result = reconciliationServiceImpl.getReconWithJiraId(
        Lists.newArrayList(reconReportDocument),
        requests,
        writeResults
    );
    
    Assert.assertTrue(result.isEmpty());
    Assert.assertEquals(1, writeResults.size());
    Assert.assertEquals(ActionRequestValidator.JIRA_ID_PRESENT, writeResults.get(0).getErrorMessage());
}

@Test
public void testRemoveJiraId_JiraIdNotPresent() throws Exception {
    // Setup BreakManagement without JIRA ID
    BreakManagement breakManagement = BreakManagement.newBuilder()
        .setIssueTrackingReferences(Lists.newArrayList())
        .build();
    
    ReconReport reconReport = ReconReport.newBuilder()
        .withBreakManagement(breakManagement)
        .build();
    
    ReconReportDocument reconReportDocument = new ReconReportDocument(
        DocumentId.from("id", 1L), 
        DocumentLifetime.from(ZonedDateTime.now(), ZonedDateTime.now()),
        reconReport
    );
    
    AddReconciliationJiraReference request = new AddReconciliationJiraReference();
    request.getJiraReference().setJiraId("MISSING_JIRA");
    
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(reconReportDocument.getDocumentId(), request);
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    List<Pair<ReconReport, Long>> result = reconciliationServiceImpl.removeJiraId(
        Lists.newArrayList(reconReportDocument),
        requests,
        writeResults
    );
    
    Assert.assertTrue(result.isEmpty());
    Assert.assertEquals(1, writeResults.size());
    Assert.assertEquals(ActionRequestValidator.JIRA_ID_NOT_PRESENT, writeResults.get(0).getErrorMessage());
}

@Test
public void testGetReconWithAssign_Exception() {
    // Mock data to cause exception
    ReconReportDocument reconReportDocument = getTestReconReport();
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(reconReportDocument.getDocumentId(), new AssignReconciliationBreak());
    
    // Use spy to throw exception
    ReconDataUpdater spyUpdater = Mockito.spy(new ReconDataUpdater());
    Mockito.doThrow(new RuntimeException("Test exception")).when(spyUpdater)
        .addAssignToException(Mockito.any(), Mockito.any(), Mockito.any());
    
    ReconciliationActionServiceImpl service = new ReconciliationActionServiceImpl(
        dfReconPersistManager, spyUpdater, blotterSecurityService, requestValidator
    );
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    Assert.assertThrows(BlotterRunTimeException.class, () -> 
        service.getReconWithAssign(
            Lists.newArrayList(reconReportDocument),
            requests,
            writeResults
        )
    );
}

@Test
public void testGetReconWithJiraType_Exception() {
    // Similar setup to testGetReconWithAssign_Exception
    // ...
}

@Test
public void testRemoveJiraType_UserValidationFailure() throws Exception {
    // Similar setup to testGetReconWithComments_UserValidationFailure
    // ...
}

@Test
public void testLogFailuerReason() throws Exception {
    DocumentId documentId = DocumentId.from("test_id", 1L);
    String reason = "Test failure reason";
    
    // Use reflection to test private method
    Method method = ReconciliationActionServiceImpl.class
        .getDeclaredMethod("logFailuerReason", DocumentId.class, String.class);
    method.setAccessible(true);
    
    method.invoke(reconciliationServiceImpl, documentId, reason);
    
    // Verify logging occurs (could also use Log4j TestAppender)
}

@Test
public void testExecuteReadCommand() {
    FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
    request.setWhereClause("test_where");
    request.setSelectClause("test_select");
    request.setGroupByClause("test_group_by");
    
    // Mock projection data
    Projection projection = Mockito.mock(Projection.class);
    Mockito.when(projection.getProjectionData()).thenReturn(Collections.singletonMap("key", "value"));
    Mockito.when(dfReconPersistManager.findProjectionWithGroupingByQuery(Mockito.any()))
        .thenReturn(Lists.newArrayList(projection));
    
    List<HashMap> result = reconciliationServiceImpl.executeReadCommand(request);
    
    Assert.assertEquals(1, result.size());
    Assert.assertEquals("value", result.get(0).get("key"));
}

@Test
public void testExecuteReadProjection() {
    FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
    request.setWhereClause("test_where");
    request.setSelectClause("test_select");
    request.setGroupByClause("test_group_by");
    
    Projection projection = Mockito.mock(Projection.class);
    Mockito.when(dfReconPersistManager.findProjectionWithGroupingByQuery(Mockito.any()))
        .thenReturn(Lists.newArrayList(projection));
    
    List<Projection> result = reconciliationServiceImpl.executeReadProjection(request);
    
    Assert.assertEquals(1, result.size());
    Assert.assertEquals(projection, result.get(0));
}

@Test
public void testGetQueryParamsObj() {
    FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
    request.setWhereClause("test_where");
    request.setAsOf("test_as_of");
    request.setComment("test_comment");
    request.setOrderBy("test_order_by");
    request.setRowLimit(100);
    request.setHistory(true);
    
    QueryParams params = reconciliationServiceImpl.getQueryParamsObj(request);
    
    Assert.assertEquals("test_where", params.getQueryWhere());
    Assert.assertEquals("test_as_of", params.getAsOf());
    Assert.assertEquals("test_comment", params.getComment());
    Assert.assertEquals("test_order_by", params.getOrderBy());
    Assert.assertEquals(100, params.getMaxResults().intValue());
    Assert.assertTrue(params.isVersionHistoryEnabled());
}

@Test
public void testGetProjectionQuery() {
    FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
    request.setWhereClause("test_where");
    request.setSelectClause("test_select");
    request.setGroupByClause("test_group_by");
    
    ProjectionQueryGroupByParams params = reconciliationServiceImpl.getProjectionQuery(request);
    
    Assert.assertEquals("test_select", params.getSelect());
    Assert.assertEquals("test_group_by", params.getGroupBy());
    Assert.assertEquals("test_where", params.getReadRequestParams().getQueryWhere());
}
