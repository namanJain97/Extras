package com.rbs.tntr.business.blotter.services;

import com.google.common.collect.Lists;
import com.nwm.tntr.domain.email.EmailContent;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.PagedScanResult;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.tntr.business.blotter.repository.DataFabricExportRepository;
import com.rbs.tntr.business.blotter.search.querybuilder.DfExportScan;
import com.rbs.tntr.business.blotter.search.querybuilder.DfScanParameters;
import com.rbs.tntr.business.blotter.search.querybuilder.LoggedInUserDetails;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.services.jobs.DfExportJob;
import com.rbs.tntr.business.blotter.utility.BlotterUtil;
import com.rbs.tntr.business.blotter.utility.CsvWriterImpl;
import com.rbs.tntr.business.blotter.utility.DataFabricExportUtility;
import com.rbs.tntr.business.blotter.utility.ExcelWriterImpl;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import com.rbs.tntr.domain.blotter.exceptions.ValidationException;
import com.nwm.tntr.services.email.EmailService;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.BlockingQueue;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.*;

public class DataFabricExportServiceImplTest {

    @Mock
    private DataFabricExportRepository dfExportRepository;

    @Mock
    private DataFabricExportUtility dataFabricExportUtil;

    @Mock
    private CsvWriterImpl csvWriter;

    @Mock
    private ExcelWriterImpl excelWriter;

    @Mock
    private DateTimeService dateTimeService;

    @Mock
    private EmailService emailService;

    @Mock
    private BlockingQueue<DfExportJob> mockQueue;

    @Mock
    private Logger logger;

    @InjectMocks
    private DataFabricExportServiceImpl dataFabricExportService;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        // Set up DateTimeService mocks
        when(dateTimeService.getCurrentUTCDateTime()).thenReturn(new DateTime());
        when(dateTimeService.getUTCDateAsString(any(DateTime.class))).thenReturn("2023-01-01");
        when(dateTimeService.getCurrentDateTimeAsString()).thenReturn("01-01-2023 12:00:00");
        when(dateTimeService.parseDateTime(anyString())).thenReturn(new DateTime());

        // Inject properties via reflection
        setField("outputFilePath", "/output/path");
        setField("schedularFrequency", "1000");
        setField("miReceiverEmail", "mi@example.com");
        setField("exportThresholdCount", 1000);
        setField("exportThresholdCountFeature", true);
        setField("zippedExportFeature", true);
        setField("emailNotificationFeature", true);
        setField("exportPageCount", 100);
        setField("smtpHost", "smtp.example.com");
        setField("emailFrom", "from@example.com");

        // Mock static BlotterUtil
        LoggedInUserDetails userDetails = new LoggedInUserDetails();
        userDetails.setName("Test User");
        userDetails.setEmail("test@example.com");
        mockStaticBlotterUtil(userDetails);
    }

    private void setField(String fieldName, Object value) throws Exception {
        Field field = DataFabricExportServiceImpl.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(dataFabricExportService, value);
    }

    private void mockStaticBlotterUtil(LoggedInUserDetails userDetails) {
        // Since we can't use PowerMockito, assume BlotterUtil is injectable or mock it via reflection if needed
        // For simplicity, we'll assume it's testable through method calls
    }

    // fetchAndExportRecords Tests
    @Test
    public void testFetchAndExportRecords_ValidParameters() throws InterruptedException {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName("testBlotter");
        scanParameters.setCollectionName("testCollection");
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        doNothing().when(mockQueue).put(any(DfExportJob.class));
        boolean result = dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, scan);
        assertTrue(result);
        verify(mockQueue).put(any(DfExportJob.class));
    }

    @Test(expected = ValidationException.class)
    public void testFetchAndExportRecordsValidationFailure_InvalidBlotterName() {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName(""); // Invalid
        scanParameters.setCollectionName("testCollection");
        String userName = "testUser";
        dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, new DfExportScan());
    }

    @Test(expected = ValidationException.class)
    public void testFetchAndExportRecordsValidationFailure_InvalidUserName() {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName("testBlotter");
        scanParameters.setCollectionName("testCollection");
        String userName = "";
        dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, new DfExportScan());
    }

    @Test
    public void testFetchAndExportRecords_QueueException() throws InterruptedException {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName("testBlotter");
        scanParameters.setCollectionName("testCollection");
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        doThrow(new InterruptedException()).when(mockQueue).put(any(DfExportJob.class));
        boolean result = dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, scan);
        assertFalse(result); // Should return false on exception
    }

    // insertDfScan Tests
    @Test
    public void testInsertDfScan_WithoutScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        RecordId result = dataFabricExportService.insertDfScan(scan);
        assertEquals(mockRecordId, result);
        assertEquals("Created", scan.getExecutionStatus());
    }

    @Test
    public void testInsertDfScan_WithScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        scan.setScheduled(true);
        scan.setScheduledTime("11:00 AM");
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        when(dateTimeService.getCurrentDateWithStartTime(anyInt(), anyInt())).thenReturn(new DateTime());
        when(dateTimeService.asString(any(DateTime.class))).thenReturn("2023-01-01 11:00:00");
        RecordId result = dataFabricExportService.insertDfScan(scan);
        assertEquals(mockRecordId, result);
        assertEquals("Scheduled", scan.getExecutionStatus());
        assertNotNull(scan.getNextRunDateTime());
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testInsertDfScan_SchedulingParseException() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        scan.setScheduled(true);
        scan.setScheduledTime("invalid"); // Causes ParseException
        dataFabricExportService.insertDfScan(scan);
    }

    // fetchDfScansForUser Tests
    @Test
    public void testFetchDfScansForUser_WithinDateRange() {
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        scan.setCreationDate("01-01-2023 12:00:00");
        List<DfExportScan> mockScans = Arrays.asList(scan);
        when(dfExportRepository.fetchDfScansForUser(userName)).thenReturn(mockScans);
        when(dateTimeService.getDirectPastDateTime(any(DateTime.class), eq(60))).thenReturn(new DateTime().minusDays(1));
        when(dateTimeService.parseDateTimeFromString(anyString())).thenReturn(new DateTime());
        List<DfExportScan> result = dataFabricExportService.fetchDfScansForUser(userName);
        assertEquals(1, result.size());
    }

    @Test
    public void testFetchDfScansForUser_NoScans() {
        String userName = "testUser";
        when(dfExportRepository.fetchDfScansForUser(userName)).thenReturn(Collections.emptyList());
        List<DfExportScan> result = dataFabricExportService.fetchDfScansForUser(userName);
        assertTrue(result.isEmpty());
    }

    @Test
    public void testFetchDfScansForUser_OlderScans() {
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        scan.setCreationDate("01-01-2000 00:00:00");
        List<DfExportScan> mockScans = Arrays.asList(scan);
        when(dfExportRepository.fetchDfScansForUser(userName)).thenReturn(mockScans);
        when(dateTimeService.getDirectPastDateTime(any(DateTime.class), eq(60))).thenReturn(new DateTime());
        when(dateTimeService.parseDateTimeFromString(anyString())).thenReturn(new DateTime(2000, 1, 1, 0, 0));
        List<DfExportScan> result = dataFabricExportService.fetchDfScansForUser(userName);
        assertTrue(result.isEmpty());
    }

    // updateDfScan Tests
    @Test
    public void testUpdateDfScan_WithScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        scan.setScheduled(true);
        scan.setScheduledTime("11:00 AM");
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        when(dateTimeService.getCurrentDateWithStartTime(anyInt(), anyInt())).thenReturn(new DateTime());
        when(dateTimeService.asString(any(DateTime.class))).thenReturn("2023-01-01 11:00:00");
        List<RecordId> result = dataFabricExportService.updateDfScan(Arrays.asList(scan));
        assertEquals(1, result.size());
        assertEquals("Scheduled", scan.getExecutionStatus());
    }

    @Test
    public void testUpdateDfScan_WithoutScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        List<RecordId> result = dataFabricExportService.updateDfScan(Arrays.asList(scan));
        assertEquals(1, result.size());
    }

    @Test(expected = ValidationException.class)
    public void testUpdateDfScan_InvalidScanId() {
        List<DfExportScan> scans = new ArrayList<>();
        DfExportScan scan = new DfExportScan();
        scan.setScanId(null); // Invalid scan ID
        scans.add(scan);
        dataFabricExportService.updateDfScan(scans);
    }

    // fetchScanByIdAndGenerateExport Tests
    @Test
    public void testFetchScanByIdAndGenerateExport_Success() throws InterruptedException {
        String scanId = "testScanId";
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        scan.setScanId(scanId);
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchDfScanById(scanId)).thenReturn(scan);
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        doNothing().when(mockQueue).put(any(DfExportJob.class));
        boolean result = dataFabricExportService.fetchScanByIdAndGenerateExport(scanId, userName);
        assertTrue(result);
        verify(mockQueue).put(any(DfExportJob.class));
    }

    @Test(expected = ValidationException.class)
    public void testFetchScanByIdAndGenerateExport_InvalidScanId() {
        dataFabricExportService.fetchScanByIdAndGenerateExport("", "testUser");
    }

    // deleteExportScans Tests
    @Test
    public void testDeleteExportScans_ValidScanIds() {
        List<String> scanIds = Arrays.asList("scan1", "scan2");
        when(dfExportRepository.deleteExportScans(scanIds)).thenReturn(2L);
        long result = dataFabricExportService.deleteExportScans(scanIds);
        assertEquals(2L, result);
    }

    @Test(expected = ValidationException.class)
    public void testDeleteExportScans_EmptyList() {
        dataFabricExportService.deleteExportScans(Collections.emptyList());
    }

    @Test(expected = ValidationException.class)
    public void testDeleteExportScans_NullList() {
        dataFabricExportService.deleteExportScans(null);
    }

    // fetchDfExportScanById Tests
    @Test
    public void testFetchDfExportScanById_ValidScanId() {
        String scanId = "testScanId";
        DfExportScan scan = new DfExportScan();
        when(dfExportRepository.fetchDfScanById(scanId)).thenReturn(scan);
        DfExportScan result = dataFabricExportService.fetchDfExportScanById(scanId);
        assertEquals(scan, result);
    }

    @Test(expected = ValidationException.class)
    public void testFetchDfExportScanById_InvalidScanId() {
        dataFabricExportService.fetchDfExportScanById("");
    }

    // scheduledDfExports Tests
    @Test
    public void testScheduledDfExports_WithScans() throws InterruptedException {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("scheduledScan");
        scan.setRequestedUserId("testUser");
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchScheduledScans()).thenReturn(Arrays.asList(scan));
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        doNothing().when(mockQueue).put(any(DfExportJob.class));
        dataFabricExportService.scheduledDfExports();
        verify(mockQueue).put(any(DfExportJob.class));
    }

    @Test
    public void testScheduledDfExports_NoScans() {
        when(dfExportRepository.fetchScheduledScans()).thenReturn(Collections.emptyList());
        dataFabricExportService.scheduledDfExports();
        verify(mockQueue, never()).put(any(DfExportJob.class));
    }

    // generateExportFileName Tests
    @Test
    public void testGenerateExportFileName() {
        String blotterName = "testBlotter";
        String userName = "testUser";
        String fileName = dataFabricExportService.generateExportFileName(blotterName, userName);
        assertTrue(fileName.startsWith("testUser_testBlotter_"));
    }

    // submitTask Tests
    @Test
    public void testSubmitTask_Success() throws InterruptedException {
        DfExportJob job = new DfExportJob(Collections.emptyList(), "testUser", false, new DfExportScan(), "fileName");
        doNothing().when(mockQueue).put(job);
        boolean result = dataFabricExportService.submitTask(job);
        assertTrue(result);
    }

    @Test
    public void testSubmitTask_InterruptedException() throws InterruptedException {
        DfExportJob job = new DfExportJob(Collections.emptyList(), "testUser", false, new DfExportScan(), "fileName");
        doThrow(new InterruptedException()).when(mockQueue).put(job);
        boolean result = dataFabricExportService.submitTask(job);
        assertFalse(result);
    }

    // generateForcedExport Tests
    @Test
    public void testGenerateForcedExport_ValidScanId() throws InterruptedException {
        String scanId = "testScanId";
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        scan.setScanId(scanId);
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchDfScanById(scanId)).thenReturn(scan);
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        doNothing().when(mockQueue).put(any(DfExportJob.class));
        dataFabricExportService.generateForcedExport(scanId, userName);
        verify(mockQueue).put(any(DfExportJob.class));
    }

    @Test(expected = ValidationException.class)
    public void testGenerateForcedExport_InvalidScanId() {
        dataFabricExportService.generateForcedExport("", "testUser");
    }

    // getMiFolderPath Tests
    @Test
    public void testGetMiFolderPath() {
        String path = dataFabricExportService.getMiFolderPath();
        assertEquals("/output/path/2023-01-01/MI", path);
    }

    // generateMiSnapShotReport Tests
    @Test
    public void testGenerateMiSnapShotReport_ValidData() throws Exception {
        List<DfScanParameters> scanParamList = Arrays.asList(new DfScanParameters());
        DfExportScan scan = new DfExportScan();
        scan.setCollectionName("testCollection");
        String fileName = "testFile";
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getNativeScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(pagedScan.getRecords()).thenReturn(Arrays.asList(mock(Record.class)));
        when(pagedScan.isFinalPage()).thenReturn(true);
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dfClient.pagedScan(scanRequestBuilder)).thenReturn(pagedScan);
        Map<String, String> mockRecord = new HashMap<>();
        mockRecord.put("assetClass", "NONE");
        mockRecord.put("jurisdiction", "TestJurisdiction");
        mockRecord.put("flow", "TestFlow");
        mockRecord.put("reportable", "100");
        mockRecord.put("complete", "90");
        when(dataFabricExportUtil.convertScannedRecords(anyList(), anyString(), any(DfExportScan.class))).thenReturn(Arrays.asList(mockRecord));
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);
        dataFabricExportService.generateMiSnapShotReport(scanParamList, scan, fileName);
        verify(csvWriter, times(2)).generateCsvFile(anyList(), anyString(), anyString());
    }

    @Test
    public void testGenerateMiSnapShotReport_NoRecords() throws Exception {
        List<DfScanParameters> scanParamList = Arrays.asList(new DfScanParameters());
        DfExportScan scan = new DfExportScan();
        String fileName = "testFile";
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getNativeScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(pagedScan.getRecords()).thenReturn(Collections.emptyList());
        when(pagedScan.isFinalPage()).thenReturn(true);
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dfClient.pagedScan(scanRequestBuilder)).thenReturn(pagedScan);
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);
        dataFabricExportService.generateMiSnapShotReport(scanParamList, scan, fileName);
        verify(csvWriter).generateCsvFile(anyList(), anyString(), anyString()); // Only headers written
    }

    // generateWeeklyKnownMiExport Tests
    @Test
    public void testGenerateWeeklyKnownMiExport_ValidData() throws Exception {
        List<DfScanParameters> scanParamList = Arrays.asList(new DfScanParameters());
        DfExportScan scan = new DfExportScan();
        scan.setCollectionName("testCollection");
        scan.setRequestedUserId("MI_EXTRACT");
        String fileName = "testFile";
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        ScanResult scanResult = mock(ScanResult.class);
        Iterator<Record> iterator = Arrays.asList(mock(Record.class)).iterator();
        when(scanResult.iterator()).thenReturn(iterator);
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dfClient.scan(scanRequestBuilder)).thenReturn(scanResult);
        Map<String, String> mockRecord = new HashMap<>();
        mockRecord.put("Jira", "JIRA-123");
        when(dataFabricExportUtil.convertScannedRecords(anyList(), anyString(), any(DfExportScan.class))).thenReturn(Arrays.asList(mockRecord));
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);
        when(dataFabricExportUtil.getAllHeaders()).thenReturn(new LinkedHashSet<>(Arrays.asList("Jira")));
        boolean result = dataFabricExportService.generateWeeklyKnownMiExport(scanParamList, scan, fileName);
        assertTrue(result);
        verify(csvWriter, times(2)).generateCsvFile(anyList(), anyString(), anyString());
    }

    @Test
    public void testGenerateWeeklyKnownMiExport_NoRecords() throws Exception {
        List<DfScanParameters> scanParamList = Arrays.asList(new DfScanParameters());
        DfExportScan scan = new DfExportScan();
        String fileName = "testFile";
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        ScanResult scanResult = mock(ScanResult.class);
        when(scanResult.iterator()).thenReturn(Collections.<Record>emptyList().iterator());
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dfClient.scan(scanRequestBuilder)).thenReturn(scanResult);
        boolean result = dataFabricExportService.generateWeeklyKnownMiExport(scanParamList, scan, fileName);
        assertTrue(result); // Returns true even if no records
    }

    // Private Method Tests via Reflection
    @Test
    public void testCalculateThresholdCount() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("calculateThresholdCount", List.class, String.class);
        method.setAccessible(true);
        List<DfScanParameters> scanParamList = Arrays.asList(new DfScanParameters());
        String userName = "testUser";
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        Record record = mock(Record.class);
        JsonDocument jsonDoc = mock(JsonDocument.class);
        when(jsonDoc.getContents()).thenReturn("{\"totalCount\": 500}");
        when(record.getDocument()).thenReturn(jsonDoc);
        when(pagedScan.getRecords()).thenReturn(Arrays.asList(record));
        when(dfClient.pagedScan(scanRequestBuilder)).thenReturn(pagedScan);
        int result = (int) method.invoke(dataFabricExportService, scanParamList, userName);
        assertEquals(500, result);
    }

    @Test
    public void testModifyFileName() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("modifyFileName", List.class, String.class);
        method.setAccessible(true);
        DfScanParameters scanParam = new DfScanParameters();
        List<DfScanParameters> scanParamList = Arrays.asList(scanParam);
        String fileName = "testFile";
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        Record record = mock(Record.class);
        JsonDocument jsonDoc = mock(JsonDocument.class);
        when(jsonDoc.getContents()).thenReturn("{\"identifier\": \"ID123\", \"reconciliationBusinessDateTime\": \"2023-01-01T00:00:00\"}");
        when(record.getDocument()).thenReturn(jsonDoc);
        when(pagedScan.getRecords()).thenReturn(Arrays.asList(record));
        when(dfClient.pagedScan(scanRequestBuilder)).thenReturn(pagedScan);
        String result = (String) method.invoke(dataFabricExportService, scanParamList, fileName);
        assertEquals("ID123_2023-01-01_testFile", result);
    }

    @Test
    public void testFetchAndExportRecordsMultiCollection_Success() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("fetchAndExportRecordsMultiCollection",
                List.class, String.class, boolean.class, DfExportScan.class, String.class, boolean.class);
        method.setAccessible(true);
        List<DfScanParameters> scanParamList = Arrays.asList(new DfScanParameters());
        String userName = "testUser";
        boolean isSavedScan = true;
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        scan.setCollectionName("testCollection");
        String fileName = "testFile";
        boolean isForcedRun = false;
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(mock(DataFabricClient.class));
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(mock(ScanRequestBuilder.class));
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(pagedScan.getRecords()).thenReturn(Arrays.asList(mock(Record.class)));
        when(pagedScan.isFinalPage()).thenReturn(true);
        when(dataFabricExportUtil.getDataFabricClient().pagedScan(any(ScanRequestBuilder.class))).thenReturn(pagedScan);
        when(dataFabricExportUtil.convertScannedRecords(anyList(), anyString(), any(DfExportScan.class))).thenReturn(Arrays.asList(new HashMap<>()));
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);
        when(dataFabricExportUtil.getAllHeaders()).thenReturn(new LinkedHashSet<>(Arrays.asList("header1")));
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        when(dfExportRepository.fetchDfScanById("testScanId")).thenReturn(scan);
        boolean result = (boolean) method.invoke(dataFabricExportService, scanParamList, userName, isSavedScan, scan, fileName, isForcedRun);
        assertTrue(result);
    }

    @Test
    public void testFetchAndExportRecordsMultiCollection_ThresholdExceeded() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("fetchAndExportRecordsMultiCollection",
                List.class, String.class, boolean.class, DfExportScan.class, String.class, boolean.class);
        method.setAccessible(true);
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("testCollection");
        List<DfScanParameters> scanParamList = Arrays.asList(scanParam);
        String userName = "testUser";
        boolean isSavedScan = true;
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        scan.setCollectionName("testCollection");
        String fileName = "testFile";
        boolean isForcedRun = false;
        DataFabricClient dfClient = mock(DataFabricClient.class);
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        ScanRequestBuilder scanRequestBuilder = mock(ScanRequestBuilder.class);
        when(dataFabricExportUtil.getScanRequestBuilder(any(DfScanParameters.class))).thenReturn(scanRequestBuilder);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        Record record = mock(Record.class);
        JsonDocument jsonDoc = mock(JsonDocument.class);
        when(jsonDoc.getContents()).thenReturn("{\"totalCount\": 2000}");
        when(record.getDocument()).thenReturn(jsonDoc);
        when(pagedScan.getRecords()).thenReturn(Arrays.asList(record));
        when(dfClient.pagedScan(scanRequestBuilder)).thenReturn(pagedScan);
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        when(dfExportRepository.fetchDfScanById("testScanId")).thenReturn(scan);
        boolean result = (boolean) method.invoke(dataFabricExportService, scanParamList, userName, isSavedScan, scan, fileName, isForcedRun);
        assertFalse(result);
        assertEquals("Skipped", scan.getExecutionStatus());
    }

    @Test
    public void testPopulateEmailNotification() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("populateEmailNotification", DfExportScan.class);
        method.setAccessible(true);
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        scan.setBlotterName("testBlotter");
        scan.setExportName("testExport");
        scan.setLastExecutionDateTime("01-01-2023 12:00:00");
        scan.setExportRecordCount(100);
        scan.setExecutionTime("10");
        EmailContent emailContent = (EmailContent) method.invoke(dataFabricExportService, scan);
        assertNotNull(emailContent);
        assertTrue(emailContent.getEmailBody().contains("Test User"));
    }

    @Test
    public void testResumeInQueueScans() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("resumeInQueueScans");
        method.setAccessible(true);
        DfExportScan scan = new DfExportScan();
        scan.setScanId("inQueueScan");
        scan.setRequestedUserId("testUser");
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchScansWithStatus("In Queue")).thenReturn(Arrays.asList(scan));
        RecordId mockRecordId = new RecordId("key", 1L);
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(mockRecordId);
        doNothing().when(mockQueue).put(any(DfExportJob.class));
        method.invoke(dataFabricExportService);
        verify(mockQueue).put(any(DfExportJob.class));
    }

    @Test
    public void testPopulateDynamicDate() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("populateDynamicDate", String.class);
        method.setAccessible(true);
        String clause = "date <= $D5";
        when(dateTimeService.getPastDateTime(any(DateTime.class), eq(5))).thenReturn(new DateTime());
        when(dateTimeService.asString(any(DateTime.class))).thenReturn("2023-01-01");
        String result = (String) method.invoke(dataFabricExportService, clause);
        assertEquals("date <= '2023-01-01'", result);
    }

    @Test
    public void testZipExportFile() throws Exception {
        Method method = DataFabricExportServiceImpl.class.getDeclaredMethod("zipExportFile", String.class);
        method.setAccessible(true);
        String fileName = "testFile";
        File mockFile = mock(File.class);
        when(mockFile.exists()).thenReturn(true);
        FileUtils.deleteQuietly(mockFile); // Mock file deletion
        method.invoke(dataFabricExportService, fileName);
        // Verify file operations via logs or indirect effects if possible
    }
}
