package com.rbs.tntr.business.taggingService.repository;

import static org.junit.Assert.; import static org.mockito.Mockito.;

import java.io.IOException; import java.lang.reflect.Method; import java.nio.charset.StandardCharsets; import java.text.SimpleDateFormat; import java.util.*;

import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.databind.ObjectMapper; import com.google.common.hash.Hashing; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.runners.MockitoJUnitRunner;

import com.rbs.datafabric.api.ScanResult; import com.rbs.datafabric.api.exception.ScanException; import com.rbs.datafabric.api.exception.UpsertException; import com.rbs.datafabric.domain.Document; import com.rbs.datafabric.domain.JsonDocument; import com.rbs.datafabric.domain.Record; import com.rbs.datafabric.domain.RecordId; import com.rbs.datafabric.client.DataFabricClient; import com.nwm.tntr.commons.domain.persistence.constant.AssetClass; import com.nwm.tntr.commons.repository.df.DfConnectionManager; import com.rbs.tntr.business.taggingService.service.common.ItrClient; import com.rbs.tntr.configuration.ItrConfiguration; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.DFQueryMetaData; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIDashboardAnalytics; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.SubjectIdentifier; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeMIDashboardAnalytics; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeSubjectIdentifier; import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;

@RunWith(MockitoJUnitRunner.class) public class MIAnalyticsDashboardRepositoryImplTest {

@Mock
private DfConnectionManager dfConnectionManager;
@Mock
private ItrConfiguration itrConfiguration;
@Mock
private ItrClient itrClient;
@Mock
private DataFabricClient dfClient;

@InjectMocks
private MIAnalyticsDashboardRepositoryImpl repository;

@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    // stub dfConnectionManager to produce dfClient via inherited getDfClient
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repository);
    doReturn(dfClient).when(spyRepo).getDfClient(dfConnectionManager);
    repository = spyRepo;
    repository.createDfClientConnection();
    // stub itrConfiguration
    when(itrConfiguration.getItr2ProtocolScheme()).thenReturn("http");
    when(itrConfiguration.getItr2ServiceName()).thenReturn("service");
    // set config fields via reflection
    setField(repository, "databaseName", "db");
    setField(repository, "miCollection", "coll");
    setField(repository, "foMiCollection", "foColl");
    setField(repository, "readTimeOut", 10);
    setField(repository, "foEmirUrl", "emir");
    setField(repository, "foEmirParameterisedUrl", "emirParam");
    setField(repository, "foMasUrl", "mas");
    setField(repository, "foMasParameterisedUrl", "masParam");
    setField(repository, "foBoiUrl", "boi");
    setField(repository, "foMifidUrl", "mifid");
    setField(repository, "foSftrUrl", "sftr");
    setField(repository, "foSftrAldopUrl", "sftrAldop");
    setField(repository, "foCftcUrl", "cftc");
}

// utility to set private fields
private void setField(Object target, String name, Object value) throws Exception {
    java.lang.reflect.Field field = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredField(name);
    field.setAccessible(true);
    field.set(target, value);
}

@Test
public void testSerializeDeserialize() throws Exception {
    SubjectIdentifier sid = new SubjectIdentifier();
    sid.setBusinessDate(new SimpleDateFormat("ddMMyyyy").parse("01012020"));
    sid.setAssetClass("AC"); sid.setEntity("E"); sid.setFlow("F"); sid.setLei("L"); sid.setMessageType("M"); sid.setRegulation("R");
    MIDashboardAnalytics stats = new MIDashboardAnalytics();
    stats.setSubjectIdentifier(sid);
    Document doc = invokeSerialize(stats);
    assertTrue(doc instanceof JsonDocument);
    MIDashboardAnalytics out = invokeDeserialize(doc);
    assertEquals(stats.getSubjectIdentifier().getLei(), out.getSubjectIdentifier().getLei());
}

@Test
public void testCalculateMiSnapshotKey() throws Exception {
    SubjectIdentifier sid = new SubjectIdentifier();
    sid.setBusinessDate(new SimpleDateFormat("ddMMyyyy").parse("02022022"));
    sid.setAssetClass("AC"); sid.setEntity("E"); sid.setFlow("F"); sid.setLei("L"); sid.setMessageType("M"); sid.setRegulation("R");
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("calculateMiSnapshotKey", SubjectIdentifier.class);
    m.setAccessible(true);
    String key = (String) m.invoke(repository, sid);
    String raw = (new SimpleDateFormat("ddMMyyyy").format(sid.getBusinessDate())+"L"+"AC"+"E"+"F"+"R"+"M").replaceAll("\\s"," ");
    raw = Hashing.sha1().hashString(raw, StandardCharsets.UTF_8).toString();
    assertEquals(raw, key);
}

@Test
public void testCalculateFoMiSnapshotKey() throws Exception {
    FrontOfficeSubjectIdentifier sid = new FrontOfficeSubjectIdentifier("E","L","AC","R", new Date());
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("calculateFoMiSnapshotKey", FrontOfficeSubjectIdentifier.class);
    m.setAccessible(true);
    String key = (String) m.invoke(repository, sid);
    String raw = (new SimpleDateFormat("ddMMyyyy").format(sid.getBusinessDate())+"AC"+"E"+"L"+"R").replaceAll("\\s","");
    raw = Hashing.sha1().hashString(raw, StandardCharsets.UTF_8).toString();
    assertEquals(raw, key);
}

@Test
public void testGetURL() {
    String url = repository.getURL("path");
    assertEquals("http://service/path", url);
}

@Test
public void testUpsertMiSnapshotSuccess() throws Exception {
    MIDashboardAnalytics stats = new MIDashboardAnalytics();
    stats.setSubjectIdentifier(new SubjectIdentifier());
    RecordId rid = new RecordId();
    when(dfClient.upsert(any())).thenReturn(rid);
    RecordId out = repository.upsertMiSnapshot(stats);
    assertSame(rid, out);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testUpsertMiSnapshotException() throws Exception {
    MIDashboardAnalytics stats = new MIDashboardAnalytics();
    stats.setSubjectIdentifier(new SubjectIdentifier());
    when(dfClient.upsert(any())).thenThrow(new UpsertException("x"));
    repository.upsertMiSnapshot(stats);
}

@Test
public void testUpsertFoMiSnapshotSuccess() throws Exception {
    FrontOfficeMIDashboardAnalytics stats = new FrontOfficeMIDashboardAnalytics();
    stats.setSubjectIdentifier(new FrontOfficeSubjectIdentifier("E","L","AC","R", new Date()));
    RecordId rid = new RecordId();
    when(dfClient.upsert(any())).thenReturn(rid);
    RecordId out = repository.upsertFoMiSnapshot(stats);
    assertSame(rid, out);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testUpsertFoMiSnapshotException() throws Exception {
    FrontOfficeMIDashboardAnalytics stats = new FrontOfficeMIDashboardAnalytics();
    stats.setSubjectIdentifier(new FrontOfficeSubjectIdentifier("E","L","AC","R", new Date()));
    when(dfClient.upsert(any())).thenThrow(new UpsertException("x"));
    repository.upsertFoMiSnapshot(stats);
}

@Test
public void testFetchStatisticsSuccess() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("coll");
    // stub scan result
    ScanResult scanResult = mock(ScanResult.class);
    Record record = mock(Record.class);
    JsonDocument jd = new JsonDocument().withContents("{\"count\":7}");
    when(record.getDocument()).thenReturn((Document)jd);
    Iterator<Record> it = Collections.singletonList(record).iterator();
    when(scanResult.iterator()).thenReturn(it);
    when(dfClient.scan(any())).thenReturn(scanResult);
    int count = repository.fetchStatistics(meta, "count");
    assertEquals(7, count);
}

@Test
public void testFetchStatisticsNoRecords() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("coll");
    when(dfClient.scan(any())).thenReturn(null);
    int count = repository.fetchStatistics(meta, "count");
    assertEquals(0, count);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchStatisticsIOException() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("coll");
    ScanResult scanResult = mock(ScanResult.class);
    Record record = mock(Record.class);
    JsonDocument jd = new JsonDocument().withContents("invalid json");
    when(record.getDocument()).thenReturn((Document)jd);
    Iterator<Record> it = Collections.singletonList(record).iterator();
    when(scanResult.iterator()).thenReturn(it);
    when(dfClient.scan(any())).thenReturn(scanResult);
    repository.fetchStatistics(meta, "count");
}

@Test
public void testFetchRecordsFromDfSuccess() {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("coll");
    ScanResult scanResult = mock(ScanResult.class);
    Record r1 = mock(Record.class); JsonDocument jd = new JsonDocument().withContents("{}");
    when(r1.getDocument()).thenReturn((Document)jd);
    Record r2 = mock(Record.class); when(r2.getDocument()).thenReturn(null);
    Iterator<Record> it = Arrays.asList(r1, r2).iterator();
    when(scanResult.iterator()).thenReturn(it);
    when(dfClient.scan(any())).thenReturn(scanResult);
    List<Record> out = repository.fetchRecordsFromDf(meta);
    assertEquals(1, out.size());
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchRecordsFromDfException() {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("coll");
    when(dfClient.scan(any())).thenThrow(new RuntimeException("x"));
    repository.fetchRecordsFromDf(meta);
}

@Test
public void testRenderCftcDataBlock() throws Exception {
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("renderCftcDataBlock", Map.class, String.class);
    m.setAccessible(true);
    Map<String,Object> map = new HashMap<>();
    map.put("cftc", "{a=true,b=false}");
    Map<String,Object> out = (Map<String,Object>) m.invoke(repository, map, "cftc");
    assertEquals("true", out.get("a"));
    assertEquals("false", out.get("b"));
}

@Test
public void testFlattenMap() throws Exception {
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("flattenMap", Map.class);
    m.setAccessible(true);
    Map<String,Object> nested = new HashMap<>();
    Map<String,Object> inner = new HashMap<>(); inner.put("k","v");
    nested.put("n", inner);
    Map<String,Object> out = (Map<String,Object>) m.invoke(repository, nested);
    assertEquals("v", out.get("n.k"));
}

@Test
public void testParseRecord() throws Exception {
    String json = "{\"x\":1,\"y\":{\"z\":2}}";
    JsonParser parser = new ObjectMapper().getFactory().createParser(json);
    parser.nextToken();
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("parseRecord", JsonParser.class);
    m.setAccessible(true);
    Map<String,Object> out = (Map<String,Object>) m.invoke(repository, parser);
    assertEquals(1, out.get("x"));
    assertEquals(2, out.get("y.z"));
}

// helper to call serialize
private Document invokeSerialize(Object stats) throws Exception {
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("serialize", Object.class);
    m.setAccessible(true);
    return (Document) m.invoke(repository, stats);
}

private MIDashboardAnalytics invokeDeserialize(Document doc) throws Exception {
    Method m = MIAnalyticsDashboardRepositoryImpl.class.getDeclaredMethod("deserailze", Document.class);
    m.setAccessible(true);
    return (MIDashboardAnalytics) m.invoke(repository, doc);
}

}

