package com.rbs.tntr.business.blotter.services;

import com.google.common.collect.Lists;
import com.nwm.tntr.domain.email.EmailContent;
import com.rbs.datafabric.api.PagedScanResult;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.tntr.business.blotter.repository.DataFabricExportRepository;
import com.rbs.tntr.business.blotter.search.querybuilder.DfExportScan;
import com.rbs.tntr.business.blotter.search.querybuilder.DfScanParameters;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.services.jobs.DfExportJob;
import com.rbs.tntr.business.blotter.utility.CsvWriterImpl;
import com.rbs.tntr.business.blotter.utility.DataFabricExportUtility;
import com.rbs.tntr.business.blotter.utility.ExcelWriterImpl;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import com.rbs.tntr.domain.blotter.exceptions.ValidationException;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.File;
import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.BlockingQueue;

import static com.rbs.tntr.business.blotter.services.common.StringConstants.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class DataFabricExportServiceImplTest {

    @InjectMocks
    private DataFabricExportServiceImpl dataFabricExportService;

    @Mock
    private DataFabricExportUtility dataFabricExportUtil;

    @Mock
    private CsvWriterImpl csvWriter;

    @Mock
    private ExcelWriterImpl excelWriter;

    @Mock
    private DataFabricExportRepository dfExportRepository;

    @Mock
    private DateTimeService dateTimeService;

    @Mock
    private EmailService emailService;

    @Mock
    private BlockingQueue<DfExportJob> mockQueue;

    @Mock
    private DataFabricClient dfClient;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        // Set configuration properties using reflection
        setField("outputFilePath", "/test/path");
        setField("schedularFrequency", "1000");
        setField("miReceiverEmail", "test@example.com");
        setField("exportThresholdCount", 1000);
        setField("exportThresholdCountFeature", true);
        setField("zippedExportFeature", true);
        setField("emailNotificationFeature", true);
        setField("exportPageCount", 100);
        setField("smtpHost", "smtp.example.com");
        setField("emailFrom", "noreply@example.com");

        // Set the queue to mockQueue using reflection
        Field queueField = DataFabricExportServiceImpl.class.getDeclaredField("queue");
        queueField.setAccessible(true);
        queueField.set(dataFabricExportService, mockQueue);

        // Mock dateTimeService defaults
        when(dateTimeService.getCurrentUTCDateTime()).thenReturn(new DateTime(2023, 1, 1, 10, 0));
        when(dateTimeService.getUTCDateAsString(any(DateTime.class))).thenReturn("20230101");
        when(dateTimeService.getCurrentDateTimeAsString()).thenReturn("01-01-2023 10:00:00");
    }

    private void setField(String fieldName, Object value) throws Exception {
        Field field = DataFabricExportServiceImpl.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(dataFabricExportService, value);
    }

    // Existing Tests (Updated for Consistency)
    @Test(expected = ValidationException.class)
    public void testFetchAndExportRecordsValidationFailure_InvalidBlotterName() {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName(""); // Invalid
        scanParameters.setCollectionName("testCollection");
        String userName = "testUser";
        dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, new DfExportScan());
    }

    @Test(expected = ValidationException.class)
    public void testUpdateDfScanInvalidScanId() {
        List<DfExportScan> scans = new ArrayList<>();
        DfExportScan scan = new DfExportScan();
        scan.setScanId(null); // Invalid scan ID
        scans.add(scan);
        dataFabricExportService.updateDfScan(scans);
    }

    @Test(expected = ValidationException.class)
    public void testFetchScanByIdAndGenerateExportWithEmptyScanId() {
        dataFabricExportService.fetchScanByIdAndGenerateExport("", "testUser");
    }

    // Additional Tests for fetchAndExportRecords
    @Test
    public void testFetchAndExportRecords_Success() throws Exception {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName("testBlotter");
        scanParameters.setCollectionName("testCollection");
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        when(mockQueue.put(any(DfExportJob.class))).thenReturn(null);

        boolean result = dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, scan);

        assertTrue(result);
        ArgumentCaptor<DfExportJob> captor = ArgumentCaptor.forClass(DfExportJob.class);
        verify(mockQueue).put(captor.capture());
        DfExportJob job = captor.getValue();
        assertEquals(userName, job.getUserName());
        assertFalse(job.isSavedScan());
        assertEquals(scan, job.getScan());
        assertTrue(job.getFileName().startsWith(userName + "__"));
    }

    @Test
    public void testFetchAndExportRecords_QueueException() throws Exception {
        DfScanParameters scanParameters = new DfScanParameters();
        scanParameters.setBlotterName("testBlotter");
        scanParameters.setCollectionName("testCollection");
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        doThrow(new InterruptedException()).when(mockQueue).put(any(DfExportJob.class));

        boolean result = dataFabricExportService.fetchAndExportRecords(scanParameters, userName, false, scan);

        assertFalse(result);
    }

    // Tests for insertDfScan
    @Test
    public void testInsertDfScan_WithoutScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(new RecordId("testId"));

        RecordId recordId = dataFabricExportService.insertDfScan(scan);

        assertNotNull(recordId);
        assertEquals("CREATED", scan.getExecutionStatus());
        assertTrue(scan.getScanId().startsWith("testUser_SCAN_REQ_ID_"));
        verify(dfExportRepository).upsertDfScan(scan);
    }

    @Test
    public void testInsertDfScan_WithScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        scan.setScheduled(true);
        scan.setScheduledTime("11:00 AM");
        Date nextRunDate = new Date();
        when(dateTimeService.parseDateTime(anyString())).thenReturn(new DateTime(nextRunDate));
        when(dateTimeService.getCurrentDateWithStartTime(11, 0)).thenReturn(new DateTime(nextRunDate));
        when(dfExportRepository.upsertDfScan(any(DfExportScan.class))).thenReturn(new RecordId("testId"));

        RecordId recordId = dataFabricExportService.insertDfScan(scan);

        assertNotNull(recordId);
        assertEquals("SCHEDULED", scan.getExecutionStatus());
        assertNotNull(scan.getNextRunDateTime());
        verify(dfExportRepository).upsertDfScan(scan);
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testInsertDfScan_SchedulingParseException() {
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("testUser");
        scan.setScheduled(true);
        scan.setScheduledTime("invalid"); // Causes ParseException
        dataFabricExportService.insertDfScan(scan);
    }

    // Tests for fetchDfScansForUser
    @Test
    public void testFetchDfScansForUser() {
        String userName = "testUser";
        DfExportScan recentScan = new DfExportScan();
        recentScan.setCreationDate("01-01-2023 10:00:00");
        DfExportScan oldScan = new DfExportScan();
        oldScan.setCreationDate("01-12-2022 10:00:00");
        when(dfExportRepository.fetchDfScansForUser(userName)).thenReturn(Arrays.asList(recentScan, oldScan));
        when(dateTimeService.getDirectPastDateTime(any(DateTime.class), eq(60))).thenReturn(new DateTime(2022, 12, 2, 10, 0));
        when(dateTimeService.parseDateTimeFromString(anyString())).thenAnswer(invocation -> new DateTime(DateTime.parse((String) invocation.getArguments()[0])));

        List<DfExportScan> result = dataFabricExportService.fetchDfScansForUser(userName);

        assertEquals(1, result.size());
        assertEquals(recentScan, result.get(0));
    }

    // Tests for updateDfScan
    @Test
    public void testUpdateDfScan_WithScheduling() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        scan.setScheduled(true);
        scan.setScheduledTime("11:00 AM");
        Date nextRunDate = new Date();
        when(dateTimeService.getCurrentDateWithStartTime(11, 0)).thenReturn(new DateTime(nextRunDate));
        when(dfExportRepository.upsertDfScan(scan)).thenReturn(new RecordId("testId"));

        List<RecordId> result = dataFabricExportService.updateDfScan(Lists.newArrayList(scan));

        assertEquals(1, result.size());
        assertEquals("SCHEDULED", scan.getExecutionStatus());
        assertNotNull(scan.getNextRunDateTime());
        verify(dfExportRepository).upsertDfScan(scan);
    }

    // Tests for fetchScanByIdAndGenerateExport
    @Test
    public void testFetchScanByIdAndGenerateExport_Success() {
        String scanId = "testScanId";
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        scan.setScanId(scanId);
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchDfScanById(scanId)).thenReturn(scan);
        when(dfExportRepository.upsertDfScan(scan)).thenReturn(new RecordId("testId"));
        when(mockQueue.put(any(DfExportJob.class))).thenReturn(null);

        boolean result = dataFabricExportService.fetchScanByIdAndGenerateExport(scanId, userName);

        assertTrue(result);
        assertEquals("IN QUEUE", scan.getExecutionStatus());
        verify(mockQueue).put(any(DfExportJob.class));
    }

    // Tests for deleteExportScans
    @Test
    public void testDeleteExportScans_Success() {
        List<String> scanIds = Arrays.asList("id1", "id2");
        when(dfExportRepository.deleteExportScans(scanIds)).thenReturn(2L);

        long result = dataFabricExportService.deleteExportScans(scanIds);

        assertEquals(2L, result);
    }

    @Test(expected = ValidationException.class)
    public void testDeleteExportScans_EmptyList() {
        dataFabricExportService.deleteExportScans(Collections.emptyList());
    }

    // Tests for fetchDfExportScanById
    @Test
    public void testFetchDfExportScanById_Success() {
        String scanId = "testScanId";
        DfExportScan scan = new DfExportScan();
        when(dfExportRepository.fetchDfScanById(scanId)).thenReturn(scan);

        DfExportScan result = dataFabricExportService.fetchDfExportScanById(scanId);

        assertEquals(scan, result);
    }

    // Tests for scheduledDfExports
    @Test
    public void testScheduledDfExports() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        scan.setRequestedUserId("testUser");
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchScheduledScans()).thenReturn(Collections.singletonList(scan));
        when(dfExportRepository.upsertDfScan(scan)).thenReturn(new RecordId("testId"));
        when(mockQueue.put(any(DfExportJob.class))).thenReturn(null);

        dataFabricExportService.scheduledDfExports();

        assertEquals("IN QUEUE", scan.getExecutionStatus());
        verify(mockQueue).put(any(DfExportJob.class));
    }

    // Tests for generateExportFileName
    @Test
    public void testGenerateExportFileName() {
        String blotterName = "testBlotter";
        String userName = "testUser";

        String fileName = dataFabricExportService.generateExportFileName(blotterName, userName);

        assertTrue(fileName.startsWith("testUser_testBlotter_"));
    }

    // Tests for submitTask
    @Test
    public void testSubmitTask_Success() throws InterruptedException {
        DfExportJob job = new DfExportJob(Collections.emptyList(), "testUser", false, new DfExportScan(), "fileName");
        when(mockQueue.put(job)).thenReturn(null);

        boolean result = dataFabricExportService.submitTask(job);

        assertTrue(result);
        verify(mockQueue).put(job);
    }

    @Test
    public void testSubmitTask_InterruptedException() throws InterruptedException {
        DfExportJob job = new DfExportJob(Collections.emptyList(), "testUser", false, new DfExportScan(), "fileName");
        doThrow(new InterruptedException()).when(mockQueue).put(job);

        boolean result = dataFabricExportService.submitTask(job);

        assertFalse(result);
    }

    // Tests for generateForcedExport
    @Test
    public void testGenerateForcedExport_Success() {
        String scanId = "testScanId";
        String userName = "testUser";
        DfExportScan scan = new DfExportScan();
        scan.setScanId(scanId);
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchDfScanById(scanId)).thenReturn(scan);
        when(dfExportRepository.upsertDfScan(scan)).thenReturn(new RecordId("testId"));
        when(mockQueue.put(any(DfExportJob.class))).thenReturn(null);

        dataFabricExportService.generateForcedExport(scanId, userName);

        assertEquals("IN QUEUE", scan.getExecutionStatus());
        ArgumentCaptor<DfExportJob> captor = ArgumentCaptor.forClass(DfExportJob.class);
        verify(mockQueue).put(captor.capture());
        assertTrue(captor.getValue().isForcedRun());
    }

    // Tests for generateMiSnapShotReport
    @Test
    public void testGenerateMiSnapShotReport_Success() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setBlotterName("testBlotter");
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("FO_MI_SNAPSHOT");
        String fileName = "testFile";
        when(dataFabricExportUtil.getNativeScanRequestBuilder(scanParam)).thenReturn(mock(ScanRequestBuilder.class));
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(dfClient.pagedScan(any())).thenReturn(pagedScan);
        when(pagedScan.getRecords()).thenReturn(Collections.singletonList(new Record(new JsonDocument("{\"assetClass\":\"NONE\",\"jurisdiction\":\"testJur\",\"flow\":\"testFlow\",\"reportable\":\"100\",\"complete\":\"50\"}"))));
        when(dataFabricExportUtil.convertScannedRecords(anyList(), anyString(), any())).thenReturn(Collections.singletonList(new HashMap<>()));
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);

        dataFabricExportService.generateMiSnapShotReport(Collections.singletonList(scanParam), scan, fileName);

        verify(csvWriter, times(2)).generateCsvFile(anyList(), anyString(), anyString());
        verify(emailService).sendEmailWithAttachment(any(EmailContent.class));
    }

    // Tests for generateWeeklyKnownMiExport
    @Test
    public void testGenerateWeeklyKnownMiExport_Success() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("testCollection");
        DfExportScan scan = new DfExportScan();
        scan.setRequestedUserId("MI_EXTRACT");
        String fileName = "testFile";
        when(dataFabricExportUtil.getScanRequestBuilder(scanParam)).thenReturn(mock(ScanRequestBuilder.class));
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        ScanResult scanResult = mock(ScanResult.class);
        when(dfClient.scan(any())).thenReturn(scanResult);
        when(scanResult.iterator()).thenReturn(Collections.singletonList(new Record(new JsonDocument("{}"))).iterator());
        when(dataFabricExportUtil.convertScannedRecords(anyList(), anyString(), any())).thenReturn(Collections.singletonList(new HashMap<String, String>() {{
            put("Jira", "JIRA-1");
            put("Count", "1");
        }}));
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);

        boolean result = dataFabricExportService.generateWeeklyKnownMiExport(Collections.singletonList(scanParam), scan, fileName);

        assertTrue(result);
        verify(emailService).sendEmailWithAttachment(any(EmailContent.class));
    }

    @Test
    public void testGenerateWeeklyKnownMiExport_NoRecords() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        DfExportScan scan = new DfExportScan();
        String fileName = "testFile";
        when(dataFabricExportUtil.getScanRequestBuilder(scanParam)).thenReturn(mock(ScanRequestBuilder.class));
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dfClient.scan(any())).thenReturn(null);

        boolean result = dataFabricExportService.generateWeeklyKnownMiExport(Collections.singletonList(scanParam), scan, fileName);

        assertTrue(result);
        verify(csvWriter, never()).generateCsvFile(anyList(), anyString(), anyString());
    }

    // Tests for fetchAndExportRecordsMultiCollection
    @Test
    public void testFetchAndExportRecordsMultiCollection_Success() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("testCollection");
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        String userName = "testUser";
        String fileName = "testFile";
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dataFabricExportUtil.getScanRequestBuilder(scanParam)).thenReturn(mock(ScanRequestBuilder.class));
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(dfClient.pagedScan(any())).thenReturn(pagedScan);
        when(pagedScan.getRecords()).thenReturn(Collections.singletonList(new Record(new JsonDocument("{}"))));
        when(pagedScan.isFinalPage()).thenReturn(true);
        when(dataFabricExportUtil.convertScannedRecords(anyList(), anyString(), any())).thenReturn(Collections.singletonList(new HashMap<>()));
        when(csvWriter.generateCsvFile(anyList(), anyString(), anyString())).thenReturn(true);
        when(dataFabricExportUtil.getAllHeaders()).thenReturn(new LinkedHashSet<>(Arrays.asList("header1")));
        when(dfExportRepository.fetchDfScanById("testScanId")).thenReturn(scan);

        boolean result = dataFabricExportService.fetchAndExportRecordsMultiCollection(Collections.singletonList(scanParam), userName, true, scan, fileName, false);

        assertTrue(result);
        assertEquals("COMPLETED", scan.getExecutionStatus());
        verify(emailService).sendHtmlEmail(any(EmailContent.class));
    }

    @Test
    public void testFetchAndExportRecordsMultiCollection_ThresholdExceeded() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("testCollection");
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        String userName = "testUser";
        String fileName = "testFile";
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dataFabricExportUtil.getScanRequestBuilder(scanParam)).thenReturn(mock(ScanRequestBuilder.class));
        PagedScanResult pagedScan = mock(PagedScanResult.class);
        when(dfClient.pagedScan(any())).thenReturn(pagedScan);
        when(pagedScan.getRecords()).thenReturn(Collections.singletonList(new Record(new JsonDocument("{\"totalCount\":2000}"))));
        when(dfExportRepository.fetchDfScanById("testScanId")).thenReturn(scan);

        boolean result = dataFabricExportService.fetchAndExportRecordsMultiCollection(Collections.singletonList(scanParam), userName, true, scan, fileName, false);

        assertFalse(result);
        assertEquals("SKIPPED", scan.getExecutionStatus());
    }

    @Test
    public void testFetchAndExportRecordsMultiCollection_ScanException() throws Exception {
        DfScanParameters scanParam = new DfScanParameters();
        scanParam.setCollectionName("testCollection");
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        String userName = "testUser";
        String fileName = "testFile";
        when(dataFabricExportUtil.getDataFabricClient()).thenReturn(dfClient);
        when(dataFabricExportUtil.getScanRequestBuilder(scanParam)).thenReturn(mock(ScanRequestBuilder.class));
        when(dfClient.pagedScan(any())).thenThrow(new com.rbs.datafabric.api.exception.ScanException("Test exception"));
        when(dfExportRepository.fetchDfScanById("testScanId")).thenReturn(scan);

        boolean result = dataFabricExportService.fetchAndExportRecordsMultiCollection(Collections.singletonList(scanParam), userName, true, scan, fileName, false);

        assertFalse(result);
        assertEquals("FAILED", scan.getExecutionStatus());
        verifyNoInteractions(emailService);
    }

    // Tests for resumeInQueueScans
    @Test
    public void testResumeInQueueScans() {
        DfExportScan scan = new DfExportScan();
        scan.setScanId("testScanId");
        scan.setRequestedUserId("testUser");
        scan.setBlotterName("testBlotter");
        when(dfExportRepository.fetchScansWithStatus("IN QUEUE")).thenReturn(Collections.singletonList(scan));
        when(dfExportRepository.upsertDfScan(scan)).thenReturn(new RecordId("testId"));
        when(mockQueue.put(any(DfExportJob.class))).thenReturn(null);

        // Invoke via reflection since it's private
        invokePrivateMethod("resumeInQueueScans");

        verify(mockQueue).clear();
        verify(mockQueue).put(any(DfExportJob.class));
    }

    // Tests for getMiFolderPath
    @Test
    public void testGetMiFolderPath() {
        String result = dataFabricExportService.getMiFolderPath();
        assertEquals("/test/path/20230101/MI", result);
    }

    // Utility method to invoke private methods via reflection
    private void invokePrivateMethod(String methodName) {
        try {
            java.lang.reflect.Method method = DataFabricExportServiceImpl.class.getDeclaredMethod(methodName);
            method.setAccessible(true);
            method.invoke(dataFabricExportService);
        } catch (Exception e) {
            throw new RuntimeException("Failed to invoke private method: " + methodName, e);
        }
    }
}
