Could you write all the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

package com.rbs.tntr.business.blotter.web.controllers;

import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.annotation.Secured;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import com.google.common.collect.Sets;
import com.rbs.tntr.business.blotter.security.BlotterSecurityService;
import com.rbs.tntr.business.blotter.security.ISSApiClient;
import com.rbs.tntr.business.blotter.security.TntrRole;
import com.rbs.tntr.domain.blotter.enums.TntrAction;

@RestController
@RequestMapping("api/v1/iss")
@Secured({TntrRole.Name.READONLY})
public class ISSController {

    enum BlotterName{
        unknown,
        futures,
        trade,
        collateral,
        collateralreuse,
        futuresCollateral,
        futuresValuation,
        margin,
        tradereconciliation,
        aggregationreconciliation,
        ratesfxreconciliation,
        creditsreconciliation,
        commodityequityreconciliation,
        etddashboard,
        exception,
        editBlotter,
        autoAssign,
        autoTagging,
        reconciliationBreakManager
    }
    private final ISSApiClient issApiClient;

    private  final BlotterSecurityService blotterSecurityService;

    public ISSController(@Autowired ISSApiClient issApiClient,
                         @Autowired BlotterSecurityService blotterSecurityService) {
        this.issApiClient = issApiClient;
        this.blotterSecurityService = blotterSecurityService;
    }

    @RequestMapping(value="users", method = RequestMethod.GET)
    public List<String> getAllIssUsers() {
          List<String> users=issApiClient.getAllUsers();
          return  users;
    }

    @RequestMapping(value = "actions/{blotterName}", method = RequestMethod.GET)
    public @ResponseBody
    HashSet<String> getUserRoles(@PathVariable String blotterName) {
        List<TntrAction> actions =
                blotterSecurityService.getPermittedActions();

        List<String> actionNames =actions.stream()
                .map(action->action.getValue())
                .collect(Collectors.toList());
        HashSet<String> filteredActions = filterNotApplicableForBlotter(actionNames, blotterName);
        return  filteredActions;
    }

    private HashSet<String> filterNotApplicableForBlotter(List<String> actionNames, String blotterName) {
        HashSet<String> outputActions = new HashSet<String>(actionNames);
        BlotterName blotter = BlotterName.valueOf(blotterName);
        switch (blotter ){
            case trade:
                outputActions.remove(TntrAction.Resubmit.getValue());
                outputActions.remove(TntrAction.AddWorkflow.getValue());
                removeTradeReportActions(outputActions);
                break;
            case reconciliationBreakManager:
            	getReconBreakManagerActions(outputActions);
            	break;
            case futures:
                outputActions.remove(TntrAction.AddWorkflow.getValue());
                removeTradeReportActions(outputActions);
                break;
            case collateral:
            case collateralreuse:
            case futuresCollateral:
            case futuresValuation:
            case margin:
                outputActions.remove(TntrAction.Replay.getValue());
                outputActions.remove(TntrAction.RequestReplay.getValue());
                outputActions.remove(TntrAction.RejectReplay.getValue());
                outputActions.remove(TntrAction.Resubmit.getValue());
                outputActions.remove(TntrAction.AddWorkflow.getValue());
                removeTradeReportActions(outputActions);
                break;
            case tradereconciliation:
            case aggregationreconciliation:
                outputActions.remove(TntrAction.Replay.getValue());
                outputActions.remove(TntrAction.RequestReplay.getValue());
                outputActions.remove(TntrAction.RejectReplay.getValue());
                outputActions.remove(TntrAction.Resubmit.getValue());
                outputActions.remove(TntrAction.CloseException.getValue());
                outputActions.remove(TntrAction.OpenException.getValue());
                outputActions.remove(TntrAction.AddWorkflow.getValue());
                removeTradeReportActions(outputActions);
                break;
            case ratesfxreconciliation:
            case creditsreconciliation:
            case commodityequityreconciliation:
                outputActions.remove(TntrAction.Replay.getValue());
                outputActions.remove(TntrAction.RequestReplay.getValue());
                outputActions.remove(TntrAction.RejectReplay.getValue());
                outputActions.remove(TntrAction.Resubmit.getValue());
                outputActions.remove(TntrAction.CloseException.getValue());
                outputActions.remove(TntrAction.OpenException.getValue());
                removeTradeReportActions(outputActions);
                break;
            case exception:
                outputActions.remove(TntrAction.Assign.getValue());
                outputActions.remove(TntrAction.AddJira.getValue());
                outputActions.remove(TntrAction.RemoveJira.getValue());
                outputActions.remove(TntrAction.Replay.getValue());
                outputActions.remove(TntrAction.CloseException.getValue());
                outputActions.remove(TntrAction.OpenException.getValue());
                outputActions.remove(TntrAction.UpdateRule.getValue());
				outputActions.remove(TntrAction.ExecuteRule.getValue());
                outputActions.remove(TntrAction.EditApprove.getValue());
                break;
            case editBlotter:
                getEditBlotterAction(outputActions);
                break;
            case autoTagging:
            case autoAssign:
                getAutoAssignAction(outputActions);
                break;
            case etddashboard:
            case unknown:
            default:
                outputActions.clear();
        }
        return outputActions;
    }

    private void getReconBreakManagerActions(HashSet<String> outputActions){
    	HashSet<String> totalActions = Sets.newHashSet(outputActions);
    	outputActions.clear();
    	
    	// No Actions to be sent for REFDATAUSER
    	if(blotterSecurityService.checkUserRole(TntrRole.REFDATAUSER.name()))
    		return; 
    	
    	if (totalActions.contains(TntrAction.AddJiraId.getValue()))
			outputActions.add(TntrAction.AddJiraId.getValue());
    	if (totalActions.contains(TntrAction.RemoveJiraId.getValue()))
			outputActions.add(TntrAction.RemoveJiraId.getValue());
    	if (totalActions.contains(TntrAction.AddJiraType.getValue()))
			outputActions.add(TntrAction.AddJiraType.getValue());
    	if (totalActions.contains(TntrAction.RemoveJiraType.getValue()))
			outputActions.add(TntrAction.RemoveJiraType.getValue());
    	if (totalActions.contains(TntrAction.AddComments.getValue()))
			outputActions.add(TntrAction.AddComments.getValue());
    	if (totalActions.contains(TntrAction.AddWorkflow.getValue()))
			outputActions.add(TntrAction.AddWorkflow.getValue());
    	if (totalActions.contains(TntrAction.AssignSelf.getValue()))
			outputActions.add(TntrAction.AssignSelf.getValue());
    	if (totalActions.contains(TntrAction.AssignOther.getValue()))
			outputActions.add(TntrAction.AssignOther.getValue());
    	
    }
    private void getEditBlotterAction(HashSet<String> outputActions){
		if (outputActions.contains(TntrAction.EditApprove.getValue())) {
            outputActions.clear();
			outputActions.add(TntrAction.EditApprove.getValue());
        }else{
            outputActions.clear();
        }
    }

    private void getAutoAssignAction(HashSet<String> outputActions){
		if (outputActions.contains(TntrAction.UpdateRule.getValue())
				|| outputActions.contains(TntrAction.ExecuteRule.getValue())) {
            outputActions.clear();
            outputActions.add(TntrAction.UpdateRule.getValue());
			outputActions.add(TntrAction.ExecuteRule.getValue());
        }else{
            outputActions.clear();
        }
    }

    private void removeTradeReportActions(HashSet<String> outputActions){
        outputActions.remove(TntrAction.RequestOpenException.getValue());
        outputActions.remove(TntrAction.RejectOpenException.getValue());
        outputActions.remove(TntrAction.ApproveOpenException.getValue());
        outputActions.remove(TntrAction.RequestCloseException.getValue());
        outputActions.remove(TntrAction.RejectCloseException.getValue());
        outputActions.remove(TntrAction.ApproveCloseException.getValue());
        outputActions.remove(TntrAction.RequestCancel.getValue());
        outputActions.remove(TntrAction.RejectCancel.getValue());
        outputActions.remove(TntrAction.ApproveCancel.getValue());
        outputActions.remove(TntrAction.RequestRefresh.getValue());
        outputActions.remove(TntrAction.RejectRefresh.getValue());
        outputActions.remove(TntrAction.ApproveRefresh.getValue());
        outputActions.remove(TntrAction.ApproveReplay.getValue());
        outputActions.remove(TntrAction.RequestDummyAmend.getValue());
        outputActions.remove(TntrAction.RejectDummyAmend.getValue());
        outputActions.remove(TntrAction.ApproveDummyAmend.getValue());
        outputActions.remove(TntrAction.RequestEdit.getValue());
        outputActions.remove(TntrAction.RejectEdit.getValue());
		outputActions.remove(TntrAction.EditApprove.getValue());
		outputActions.remove(TntrAction.ApproveEdit.getValue());
        outputActions.remove(TntrAction.UpdateRule.getValue());
		outputActions.remove(TntrAction.ExecuteRule.getValue());
        outputActions.remove(TntrAction.ViewSubmissionPayload.getValue());
        outputActions.remove(TntrAction.ViewResponsePayload.getValue());
        outputActions.remove(TntrAction.AddJiraType.getValue());
        outputActions.remove(TntrAction.RemoveJiraType.getValue());
        outputActions.remove(TntrAction.AssignOther.getValue());
        outputActions.remove(TntrAction.AssignSelf.getValue());
        outputActions.remove(TntrAction.AddJiraId.getValue());
        outputActions.remove(TntrAction.RemoveJiraId.getValue());
        outputActions.remove(TntrAction.ResetAction.getValue());
        outputActions.remove(TntrAction.UserActionType.getValue());
        outputActions.remove(TntrAction.ReplayValuationForBusinessDate.getValue());
        outputActions.remove(TntrAction.UpdateDueDate.getValue());
        outputActions.remove(TntrAction.AssignBreakResolution.getValue());
        outputActions.remove(TntrAction.AssignActualBreakOwner.getValue());
        outputActions.remove(TntrAction.AddCommentType.getValue());
        outputActions.remove(TntrAction.RemoveCommentType.getValue());
        outputActions.remove(TntrAction.ReplayCollateralForDateRange.getValue());
    }

}


Exisitng test class:

package com.rbs.tntr.business.blotter.web.controllers;

import com.rbs.tntr.business.blotter.security.BlotterSecurityService;
import com.rbs.tntr.business.blotter.security.ISSApiClient;
import com.rbs.tntr.business.blotter.security.TntrRole;
import com.rbs.tntr.domain.blotter.enums.TntrAction;
import org.assertj.core.util.Lists;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.HashSet;
import java.util.List;

public class ISSControllerTest {

    ISSController controller;
    BlotterSecurityService bss;
    ISSApiClient issClient;

    @Before
    public void init() {
        bss = Mockito.mock(BlotterSecurityService.class);
        issClient = Mockito.mock(ISSApiClient.class);
        controller = new ISSController(issClient, bss);
    }

    @Test
    public void getAllUsers() {
        List<String> users = Lists.newArrayList("aUserRacf1", "aUserRacf2");
        Mockito.when(issClient.getAllUsers()).thenReturn(users);

        List<String> usersResult = controller.getAllIssUsers();
        Assert.assertEquals(users, usersResult);
    }

    @Test
    public void getUserRoles_Trade() {
        List<TntrAction> actions = Lists.newArrayList(TntrAction.AddComments, TntrAction.AddWorkflow, TntrAction.Resubmit);
        Mockito.when(bss.getPermittedActions()).thenReturn(actions);

        HashSet<String> permittedActions = controller.getUserRoles("trade");

        Assert.assertEquals(1, permittedActions.size());
        Assert.assertTrue(permittedActions.contains(TntrAction.AddComments.getValue()));
    }

    @Test
    public void getUserRoles_Unknown() {
        List<TntrAction> actions = Lists.newArrayList(TntrAction.AddComments, TntrAction.AddJira);
        Mockito.when(bss.getPermittedActions()).thenReturn(actions);

        HashSet<String> permittedActions = controller.getUserRoles("unknown");

        Assert.assertTrue(permittedActions.isEmpty());
    }

    @Test
    public void getUserRoles_ReconciliationBreakManager() {
        Mockito.when(bss.getPermittedActions()).thenReturn(generateFullActionSet());
        Mockito.when(bss.checkUserRole(TntrRole.REFDATAUSER.name())).thenReturn(false);

        HashSet<String> permittedActions = controller.getUserRoles("reconciliationBreakManager");

        Assert.assertFalse(permittedActions.isEmpty());
    }

    @Test
    public void getUserRoles_EmptyForRefDataUser() {
        Mockito.when(bss.getPermittedActions()).thenReturn(generateFullActionSet());
        Mockito.when(bss.checkUserRole(TntrRole.REFDATAUSER.name())).thenReturn(true);

        HashSet<String> permittedActions = controller.getUserRoles("reconciliationBreakManager");

        Assert.assertTrue(permittedActions.isEmpty());
    }

    @Test
    public void getUserRoles_UnknownBlotterName() {
        Mockito.when(bss.getPermittedActions()).thenReturn(generateFullActionSet());

        HashSet<String> permittedActions = controller.getUserRoles("unknown");

        Assert.assertTrue(permittedActions.isEmpty());
    }

    @Test(expected = IllegalArgumentException.class)
    public void getUserRoles_InvalidBlotterName() {
        List<TntrAction> actions = Lists.newArrayList(TntrAction.AddComments, TntrAction.AddJira);
        Mockito.when(bss.getPermittedActions()).thenReturn(actions);

        controller.getUserRoles("nonExistingBlotter");
    }

    // Helper method to create a full set of action names
    private List<TntrAction> generateFullActionSet() {
        return Lists.newArrayList(
                TntrAction.AddComments,
                TntrAction.AddWorkflow,
                TntrAction.Resubmit
        );
    }
}
