package com.rbs.tntr.business.taggingService.repository;

import static com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIConstants.*;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.function.Consumer;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nwm.tntr.commons.domain.persistence.constant.AssetClass;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.nwm.tntr.configuration.ItrConfiguration;
import com.nwm.tntr.itr.IQuery;
import com.nwm.tntr.itr.Itr2ParameterisedQuery;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.OptimisticLockException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.api.exception.UpsertException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.datafabric.domain.client.builder.UpsertRequestBuilder;
import com.rbs.tntr.business.taggingService.service.common.ItrClient;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.*;
import org.junit.Before;
import org.junit.Test;
import org.mockito.*;
import org.springframework.test.util.ReflectionTestUtils;

public class MIAnalyticsDashboardRepositoryImplTest {
    
    @InjectMocks
    MIAnalyticsDashboardRepositoryImpl repo;
    
    @Mock 
    DfConnectionManager dfConn;
    
    @Mock 
    ItrConfiguration itrConfig;
    
    @Mock 
    ItrClient itrClient;
    
    @Mock 
    DataFabricClient dfClient;
    
    @Mock
    ScanResult scanResult;
    
    @Mock
    ObjectMapper objectMapper;
    
    @Captor
    ArgumentCaptor<Consumer<InputStream>> consumerCaptor;
    
    private static final ObjectMapper REAL_OBJECT_MAPPER = new ObjectMapper();
    private static final Date TEST_DATE;
    
    static {
        try {
            TEST_DATE = new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-19");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Set configuration properties via reflection
        ReflectionTestUtils.setField(repo, "databaseName", "testDatabase");
        ReflectionTestUtils.setField(repo, "miCollection", "miCollection");
        ReflectionTestUtils.setField(repo, "foMiCollection", "foMiCollection");
        ReflectionTestUtils.setField(repo, "readTimeOut", 60);
        
        // Set URLs for various endpoints
        ReflectionTestUtils.setField(repo, "foEmirUrl", "emirUrl");
        ReflectionTestUtils.setField(repo, "foEmirParameterisedUrl", "emirParamUrl");
        ReflectionTestUtils.setField(repo, "foMasUrl", "masUrl");
        ReflectionTestUtils.setField(repo, "foMasParameterisedUrl", "masParamUrl");
        ReflectionTestUtils.setField(repo, "foBoiUrl", "boiUrl");
        ReflectionTestUtils.setField(repo, "foMifidUrl", "mifidUrl");
        ReflectionTestUtils.setField(repo, "foSftrUrl", "sftrUrl");
        ReflectionTestUtils.setField(repo, "foSftrAldopUrl", "sftrAldopUrl");
        ReflectionTestUtils.setField(repo, "foCftcUrl", "cftcUrl");
        
        // Mock some common behaviors
        when(itrConfig.getItr2ProtocolScheme()).thenReturn("http");
        when(itrConfig.getItr2ServiceName()).thenReturn("testService");
    }

    @Test
    public void testCreateDfClientConnection_Success() throws StartableException {
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(dfClient).when(spyRepo).getDfClient(any(DfConnectionManager.class));
        
        spyRepo.createDfClientConnection();
        
        verify(spyRepo).getDfClient(dfConn);
    }

    @Test
    public void testCreateDfClientConnection_Exception() throws StartableException {
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doThrow(new StartableException("Test exception")).when(spyRepo).getDfClient(any(DfConnectionManager.class));
        
        spyRepo.createDfClientConnection();
        
        verify(spyRepo).getDfClient(dfConn);
        // Should catch the exception and log it
    }

    @Test
    public void testUpsertMiSnapshot_Success() throws Exception {
        // Create test data
        SubjectIdentifier identifier = new SubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setFlow("testFlow");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setMessageType("testMessage");
        identifier.setBusinessDate(TEST_DATE);
        
        MIDashboardAnalytics analytics = new MIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        RecordId expectedRecordId = new RecordId();
        when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenReturn(expectedRecordId);
        
        // Execute the test
        RecordId result = repo.upsertMiSnapshot(analytics);
        
        // Verify results
        assertEquals(expectedRecordId, result);
        verify(dfClient).upsert(any(UpsertRequestBuilder.class));
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertMiSnapshot_JsonProcessingException() throws Exception {
        // Create test data with problematic data that will cause serialization failure
        SubjectIdentifier identifier = new SubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setBusinessDate(TEST_DATE);
        
        MIDashboardAnalytics analytics = new MIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        // Set up to throw exception
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doThrow(new com.fasterxml.jackson.core.JsonProcessingException("Test JSON exception") {
            private static final long serialVersionUID = 1L;
        }).when(spyRepo).serialize(any());
        
        // This should throw TaggingServiceRunTimeException
        spyRepo.upsertMiSnapshot(analytics);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertMiSnapshot_UpsertException() throws Exception {
        // Create test data
        SubjectIdentifier identifier = new SubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setFlow("testFlow");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setMessageType("testMessage");
        identifier.setBusinessDate(TEST_DATE);
        
        MIDashboardAnalytics analytics = new MIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenThrow(new UpsertException("Test upsert exception"));
        
        // This should throw TaggingServiceRunTimeException
        repo.upsertMiSnapshot(analytics);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertMiSnapshot_OptimisticLockException() throws Exception {
        // Create test data
        SubjectIdentifier identifier = new SubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setFlow("testFlow");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setMessageType("testMessage");
        identifier.setBusinessDate(TEST_DATE);
        
        MIDashboardAnalytics analytics = new MIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenThrow(new OptimisticLockException("Test optimistic lock exception"));
        
        // This should throw TaggingServiceRunTimeException
        repo.upsertMiSnapshot(analytics);
    }

    @Test
    public void testUpsertFoMiSnapshot_Success() throws Exception {
        // Create test data
        FrontOfficeSubjectIdentifier identifier = new FrontOfficeSubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setBusinessDate(TEST_DATE);
        
        FrontOfficeMIDashboardAnalytics analytics = new FrontOfficeMIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        RecordId expectedRecordId = new RecordId();
        when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenReturn(expectedRecordId);
        
        // Execute the test
        RecordId result = repo.upsertFoMiSnapshot(analytics);
        
        // Verify results
        assertEquals(expectedRecordId, result);
        verify(dfClient).upsert(any(UpsertRequestBuilder.class));
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertFoMiSnapshot_JsonProcessingException() throws Exception {
        // Create test data with problematic data that will cause serialization failure
        FrontOfficeSubjectIdentifier identifier = new FrontOfficeSubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setBusinessDate(TEST_DATE);
        
        FrontOfficeMIDashboardAnalytics analytics = new FrontOfficeMIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        // Set up to throw exception
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doThrow(new com.fasterxml.jackson.core.JsonProcessingException("Test JSON exception") {
            private static final long serialVersionUID = 1L;
        }).when(spyRepo).serialize(any());
        
        // This should throw TaggingServiceRunTimeException
        spyRepo.upsertFoMiSnapshot(analytics);
    }

    @Test(expected = TaggingServiceRunTimeException.class)  
    public void testUpsertFoMiSnapshot_UpsertException() throws Exception {
        // Create test data
        FrontOfficeSubjectIdentifier identifier = new FrontOfficeSubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setBusinessDate(TEST_DATE);
        
        FrontOfficeMIDashboardAnalytics analytics = new FrontOfficeMIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenThrow(new UpsertException("Test upsert exception"));
        
        // This should throw TaggingServiceRunTimeException
        repo.upsertFoMiSnapshot(analytics);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertFoMiSnapshot_OptimisticLockException() throws Exception {
        // Create test data
        FrontOfficeSubjectIdentifier identifier = new FrontOfficeSubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setBusinessDate(TEST_DATE);
        
        FrontOfficeMIDashboardAnalytics analytics = new FrontOfficeMIDashboardAnalytics();
        analytics.setSubjectIdentifier(identifier);
        
        when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenThrow(new OptimisticLockException("Test optimistic lock exception"));
        
        // This should throw TaggingServiceRunTimeException
        repo.upsertFoMiSnapshot(analytics);
    }

    @Test
    public void testFetchStatistics_Success() throws Exception {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setCollectionName("testCollection");
        metadata.setStatName("testStat");
        
        // Create mock objects and behavior
        ScanRequestBuilder mockScanRequestBuilder = mock(ScanRequestBuilder.class);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mockScanRequestBuilder).when(spyRepo).getScanRequestBuilder(eq(metadata), anyString(), anyString());
        when(mockScanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(mockScanRequestBuilder);
        
        Record mockRecord = mock(Record.class);
        JsonDocument mockJsonDoc = new JsonDocument().withContents("{\"selectField\":42}");
        when(mockRecord.getDocument()).thenReturn(mockJsonDoc);
        
        Iterator<Record> mockIterator = Collections.singletonList(mockRecord).iterator();
        when(scanResult.iterator()).thenReturn(mockIterator);
        when(dfClient.scan(mockScanRequestBuilder)).thenReturn(scanResult);
        
        // Execute the test
        int result = spyRepo.fetchStatistics(metadata, "selectField");
        
        // Verify results
        assertEquals(42, result);
        verify(dfClient).scan(mockScanRequestBuilder);
        verify(mockScanRequestBuilder).withReadTimeoutSeconds(anyInt());
    }

    @Test
    public void testFetchStatistics_NoResults() throws Exception {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setCollectionName("testCollection");
        metadata.setStatName("testStat");
        
        // Create mock objects and behavior
        ScanRequestBuilder mockScanRequestBuilder = mock(ScanRequestBuilder.class);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mockScanRequestBuilder).when(spyRepo).getScanRequestBuilder(eq(metadata), anyString(), anyString());
        when(mockScanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(mockScanRequestBuilder);
        
        when(dfClient.scan(mockScanRequestBuilder)).thenReturn(null);
        
        // Execute the test
        int result = spyRepo.fetchStatistics(metadata, "selectField");
        
        // Verify results
        assertEquals(0, result);
        verify(dfClient).scan(mockScanRequestBuilder);
    }

    @Test
    public void testFetchStatistics_NoDocuments() throws Exception {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setCollectionName("testCollection");
        metadata.setStatName("testStat");
        
        // Create mock objects and behavior
        ScanRequestBuilder mockScanRequestBuilder = mock(ScanRequestBuilder.class);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mockScanRequestBuilder).when(spyRepo).getScanRequestBuilder(eq(metadata), anyString(), anyString());
        when(mockScanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(mockScanRequestBuilder);
        
        Record mockRecord = mock(Record.class);
        when(mockRecord.getDocument()).thenReturn(null);
        
        Iterator<Record> mockIterator = Collections.singletonList(mockRecord).iterator();
        when(scanResult.iterator()).thenReturn(mockIterator);
        when(dfClient.scan(mockScanRequestBuilder)).thenReturn(scanResult);
        
        // Execute the test
        int result = spyRepo.fetchStatistics(metadata, "selectField");
        
        // Verify results
        assertEquals(0, result);
        verify(dfClient).scan(mockScanRequestBuilder);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testFetchStatistics_IOException() throws Exception {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setCollectionName("testCollection");
        metadata.setStatName("testStat");
        
        // Create mock objects and behavior
        ScanRequestBuilder mockScanRequestBuilder = mock(ScanRequestBuilder.class);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mockScanRequestBuilder).when(spyRepo).getScanRequestBuilder(eq(metadata), anyString(), anyString());
        when(mockScanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(mockScanRequestBuilder);
        
        Record mockRecord = mock(Record.class);
        JsonDocument mockJsonDoc = new JsonDocument().withContents("invalid json"); // This will cause a parse error
        when(mockRecord.getDocument()).thenReturn(mockJsonDoc);
        
        Iterator<Record> mockIterator = Collections.singletonList(mockRecord).iterator();
        when(scanResult.iterator()).thenReturn(mockIterator);
        when(dfClient.scan(mockScanRequestBuilder)).thenReturn(scanResult);
        
        // Execute the test - should throw exception
        spyRepo.fetchStatistics(metadata, "selectField");
    }

    @Test
    public void testCalculateMiSnapshotKey() throws Exception {
        // Create test data
        SubjectIdentifier identifier = new SubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setFlow("testFlow");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setMessageType("testMessage");
        identifier.setBusinessDate(TEST_DATE);
        
        // Execute the test
        String key = ReflectionTestUtils.invokeMethod(repo, "calculateMiSnapshotKey", identifier);
        
        // Verify results - can't check exact hash, but should be non-null
        assertNotNull(key);
        assertTrue(key.length() > 0);
    }

    @Test
    public void testCalculateFoMiSnapshotKey() throws Exception {
        // Create test data
        FrontOfficeSubjectIdentifier identifier = new FrontOfficeSubjectIdentifier();
        identifier.setLei("testLei");
        identifier.setEntity("testEntity");
        identifier.setRegulation("testRegulation");
        identifier.setAssetClass("testAsset");
        identifier.setBusinessDate(TEST_DATE);
        
        // Execute the test
        String key = ReflectionTestUtils.invokeMethod(repo, "calculateFoMiSnapshotKey", identifier);
        
        // Verify results - can't check exact hash, but should be non-null
        assertNotNull(key);
        assertTrue(key.length() > 0);
    }

    @Test
    public void testFetchRecordsFromDf_Success() throws Exception {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setCollectionName("testCollection");
        metadata.setStatName("testStat");
        
        // Create mock objects and behavior
        ScanRequestBuilder mockScanRequestBuilder = mock(ScanRequestBuilder.class);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mockScanRequestBuilder).when(spyRepo).getScanRequestBuilder(eq(metadata), anyString(), anyString());
        when(mockScanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(mockScanRequestBuilder);
        
        Record mockRecord = mock(Record.class);
        JsonDocument mockJsonDoc = new JsonDocument().withContents("{\"data\":\"value\"}");
        when(mockRecord.getDocument()).thenReturn(mockJsonDoc);
        
        Iterator<Record> mockIterator = Arrays.asList(mockRecord, null, mockRecord).iterator();
        when(scanResult.iterator()).thenReturn(mockIterator);
        when(dfClient.scan(mockScanRequestBuilder)).thenReturn(scanResult);
        
        // Execute the test
        List<Record> results = spyRepo.fetchRecordsFromDf(metadata);
        
        // Verify results
        assertEquals(2, results.size());
        verify(dfClient).scan(mockScanRequestBuilder);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testFetchRecordsFromDf_Exception() throws Exception {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setCollectionName("testCollection");
        metadata.setStatName("testStat");
        
        // Create mock objects and behavior
        ScanRequestBuilder mockScanRequestBuilder = mock(ScanRequestBuilder.class);
        MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
        doReturn(mockScanRequestBuilder).when(spyRepo).getScanRequestBuilder(eq(metadata), anyString(), anyString());
        when(mockScanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(mockScanRequestBuilder);
        
        when(dfClient.scan(mockScanRequestBuilder)).thenThrow(new RuntimeException("Test scan exception"));
        
        // Execute the test - should throw exception
        spyRepo.fetchRecordsFromDf(metadata);
    }

    @Test
    public void testSerialize() throws Exception {
        // Create test data
        MIDashboardAnalytics analytics = new MIDashboardAnalytics();
        
        // Execute the test
        Document result = repo.serialize(analytics);
        
        // Verify results
        assertNotNull(result);
        assertTrue(result instanceof JsonDocument);
        String content = ((JsonDocument) result).getContents();
        assertTrue(content.contains("miAnalyticsState"));
    }

    @Test
    public void testDeserialize() throws Exception {
        // Create test data
        JsonDocument doc = new JsonDocument().withContents("{\"miAnalyticsState\":{\"totalRecordCount\":0}}");
        
        // Execute the test
        MIDashboardAnalytics result = repo.deserailze(doc);
        
        // Verify results
        assertNotNull(result);
        assertNotNull(result.getMiAnalyticsState());
        assertEquals(0, result.getMiAnalyticsState().getTotalRecordCount());
    }

    @Test
    public void testGetURL() {
        String result = repo.getURL("testEndpoint");
        assertEquals("http://testService/testEndpoint", result);
    }

    @Test
    public void testItrQueryForFO_WithSelectAndWhere() {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setSelect("select field");
        metadata.setWhere("where condition");
        
        // Execute the test
        Itr2Query result = repo.itrQueryForFO(metadata);
        
        // Verify results
        assertNotNull(result);
        assertEquals("select field", result.getSelect());
        assertEquals("where condition", result.getWhere());
    }

    @Test
    public void testItrQueryForFO_EmptySelectAndWhere() {
        // Set up test data
        DFQueryMetaData metadata = new DFQueryMetaData();
        metadata.setSelect("");
        metadata.setWhere("");
        
        // Execute the test
        Itr2Query result = repo.itrQueryForFO(metadata);
        
        // Verify results
        assertNotNull(result);
    }

    @Test
    public void testParseRecord() throws Exception {
        // Set up test data
        String json = "{\"key\":\"value\",\"nested\":{\"nestedKey\":\"nestedValue\"}}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        
        // Execute the test
        Map<String, Object> result = repo.parseRecord(parser);
        
        // Verify results
        assertNotNull(result);
        assertEquals("value", result.get("key"));
        assertEquals("nestedValue", result.get("nested.nestedKey"));
    }

    @Test
    public void testParseItrRecord_ForeignExchange() throws Exception {
        // Set up test data
        String json = "{\"tradingPartyLei\":\"" + LEI_NWM_PLC + "\",\"transactionReportable\":true,\"versionReportable\":true}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        
        // Execute the test
        Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, AssetClass.FOREIGN_EXCHANGE.value(), "EMIR");
        
        // Verify results
        assertNotNull(result);
        assertNotNull(result.get("EMIR"));
        assertEquals(LEI_NWM_PLC, result.get("EMIR").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("EMIR").get(TRANSACTION_REPORTABLE));
        assertEquals(true, result.get("EMIR").get(VERSION_REPORTABLE));
    }

    @Test
    public void testParseItrRecord_InterestRate() throws Exception {
        // Set up test data
        String json = "{\"partyLeiCode\":\"" + LEI_NWM_NV + "\",\"isEligible\":true,\"versionReportable\":true}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        
        // Execute the test
        Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, AssetClass.INTEREST_RATE.value(), "EMIR");
        
        // Verify results
        assertNotNull(result);
        assertNotNull(result.get("EMIR"));
        assertEquals(LEI_NWM_NV, result.get("EMIR").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("EMIR").get(TRANSACTION_REPORTABLE));
        assertEquals(true, result.get("EMIR").get(VERSION_REPORTABLE));
    }

    @Test
    public void testParseItrRecord_Credit() throws Exception {
        // Set up test data
        String json = "{\"partyLeiCode\":\"" + LEI_NWM_PLC + "\",\"emir.isEligible\":true,\"emir.isVersionReportable\":true}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        
        // Execute the test
        Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, AssetClass.CREDIT.value(), "EMIR");
        
        // Verify results
        assertNotNull(result);
        assertNotNull(result.get("EMIR"));
        assertEquals(LEI_NWM_PLC, result.get("EMIR").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("EMIR").get(TRANSACTION_REPORTABLE));
        assertEquals(true, result.get("EMIR").get(VERSION_REPORTABLE));
    }

    @Test
    public void testParseItrRecord_CFTC_CSA_FX() throws Exception {
        // Set up test data
        String json = "{\"tradingPartyLei\":\"" + LEI_NWM_PLC + "\",\"cftc\":{transactionReportable=true, versionReportable=true},\"canada\":{transactionReportable=false, versionReportable=false}}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        
        // Execute the test
        Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, AssetClass.FOREIGN_EXCHANGE.value(), "CFTC_CSA");
        
        // Verify results
        assertNotNull(result);
        assertNotNull(result.get("DF"));
        assertNotNull(result.get("CSA"));
        
        assertEquals(LEI_NWM_PLC, result.get("DF").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("DF").get(TRANSACTION_REPORTABLE));
        assertEquals(true, result.get("DF").get(VERSION_REPORTABLE));
        
        assertEquals(LEI_NWM_PLC, result.get("CSA").get(TRADING_PARTY_LEI));
        assertEquals(false, result.get("CSA").get(TRANSACTION_REPORTABLE));
        assertEquals(false, result.get("CSA").get(VERSION_REPORTABLE));
    }

    @Test
    public void testParseItrRecord_CFTC_CSA_IR() throws Exception {
        // Set up test data
        String json = "{\"partyLeiCode\":\"" + LEI_NWM_NV + "\",\"cftc\":{transactionReportable=true, versionReportable=true},\"canada\":{transactionReportable=false, versionReportable=false}}";
        JsonParser parser = REAL_OBJECT_MAPPER.getFactory().createParser(json);
        
        // Execute the test
        Map
