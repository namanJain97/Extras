@Test
public void testAddComment_MAS755ValidationFailure() {
    // Setup
    AddTradeCommentRequest request = new AddTradeCommentRequest();
    request.setDocumentId(new ActionDocumentId("key", 1L));
    List<AddTradeCommentRequest> requests = Collections.singletonList(request);
    
    TradeReportDocument doc = mock(TradeReportDocument.class);
    when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
    TradeReport report = mock(TradeReport.class);
    when(doc.getTradeReport()).thenReturn(report);
    
    List<ActionUpdateResult> validationFailures = new ArrayList<>();
    validationFailures.add(ActionUpdateResult.createWithError(
        new ActionDocumentId("key", 1L), "MAS755 validation failed"
    ));
    
    when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
    doAnswer(invocation -> {
        List<ActionUpdateResult> results = invocation.getArgument(1);
        results.addAll(validationFailures);
        return null;
    }).when(requestValidator).validateMAS755Trades(anyList(), anyList());
    
    // Execute
    List<ActionUpdateResult> results = tradeActionService.addComment(requests, "username");
    
    // Verify
    assertEquals(1, results.size());
    assertTrue(results.get(0).getError().contains("MAS755 validation failed"));
}

@Test
public void testUpdateExceptionStatus_RollbackOnEditRejected() {
    // Setup Edit_Rejected status
    UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
    request.setDocumentId(new ActionDocumentId("key", 1L));
    List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);
    
    TradeReportDocument doc = mock(TradeReportDocument.class);
    when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
    TradeReport report = mock(TradeReport.class);
    when(report.getTransactionReportingStatus()).thenReturn(mock(TradeReport.TransactionReportingStatus.class));
    ExceptionManagement em = mock(ExceptionManagement.class);
    when(em.getApprovalStatus()).thenReturn(ExceptionStatus.Edit_Requested);
    when(report.getExceptionManagement()).thenReturn(em);
    when(doc.getTradeReport()).thenReturn(report);
    
    when(dfTradePersistManager.getAllRecordsById(anyList()))
        .thenReturn(Collections.singletonList(doc))  // First call
        .thenReturn(Collections.singletonList(doc)); // Rollback call
    
    // Execute with Edit_Rejected
    List<ActionUpdateResult> results = tradeActionService.updateExceptionStatus(
        requests, ExceptionStatus.Edit_Rejected, "username"
    );
    
    // Verify rollback was triggered
    verify(dfTradePersistManager, times(1)).upsertAllRecords(anyList());
    assertEquals(1, results.size());
}

@Test
public void testSaveAllRecords_ErrorHandling() throws Exception {
    // Use reflection to test private method
    List<TradeReportDocument> docs = new ArrayList<>();
    TradeReportDocument doc = mock(TradeReportDocument.class);
    DocumentId docId = DocumentId.from("key", 1L);
    when(doc.getDocumentId()).thenReturn(docId);
    docs.add(doc);
    
    List<WriteResult<TradeReport>> writeResults = new ArrayList<>();
    WriteResult<TradeReport> errorResult = mock(WriteResult.class);
    when(errorResult.isSuccess()).thenReturn(false);
    when(errorResult.getErrorDetail()).thenReturn(new WriteResult.ErrorDetail("DB Error", new RuntimeException("Cause")));
    writeResults.add(errorResult);
    
    when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(writeResults);
    
    // Invoke private method via reflection
    Method saveAllRecords = TradeActionService.class.getDeclaredMethod(
        "saveAllRecords", List.class, List.class
    );
    saveAllRecords.setAccessible(true);
    List<ActionUpdateResult> results = (List<ActionUpdateResult>) saveAllRecords.invoke(
        tradeActionService, docs, Collections.singletonList(Pair.of(mock(TradeReport.class), 1L))
    );
    
    // Verify error handling
    assertEquals(1, results.size());
    assertTrue(results.get(0).getError().contains("DB Error"));
}

@Test
public void testUpdateExceptionStatus_CancelTradeValidationFailure() {
    // Setup
    UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
    request.setDocumentId(new ActionDocumentId("key", 1L));
    List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);
    
    TradeReportDocument doc = mock(TradeReportDocument.class);
    when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
    TradeReport report = mock(TradeReport.class);
    when(report.getTransactionReportingStatus()).thenReturn(mock(TradeReport.TransactionReportingStatus.class));
    when(report.getTransactionReportingStatus().getTransactionStateValue()).thenReturn("ACKED");
    when(doc.getTradeReport()).thenReturn(report);
    
    when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
    
    // Execute with Cancel Requested
    List<ActionUpdateResult> results = tradeActionService.updateExceptionStatus(
        requests, ExceptionStatus.Cancel_Requested, "username"
    );
    
    // Verify validation failure
    assertEquals(1, results.size());
    assertTrue(results.get(0).getError().contains(TradeActionService.CANCEL_TRADE_ACKED_ERROR));
}

@Test
public void testPerformResetAction_ValidationFailure() {
    // Setup
    UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
    request.setDocumentId(new ActionDocumentId("key", 1L));
    List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);
    
    TradeReportDocument doc = mock(TradeReportDocument.class);
    when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
    TradeReport report = mock(TradeReport.class);
    ExceptionManagement em = mock(ExceptionManagement.class);
    when(em.getApprovalStatus()).thenReturn(ExceptionStatus.Approved); // Invalid status for reset
    when(report.getExceptionManagement()).thenReturn(em);
    when(doc.getTradeReport()).thenReturn(report);
    
    when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
    
    // Execute
    List<ActionUpdateResult> results = tradeActionService.performResetAction(requests, "username");
    
    // Verify validation failure
    assertEquals(1, results.size());
    assertTrue(results.get(0).getError().contains(ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
}

@Test
public void testRemoveJiraType_ValidationFailure() {
    // Setup
    AddTradeJiraTypeRequest request = new AddTradeJiraTypeRequest();
    request.setDocumentId(new ActionDocumentId("key", 1L));
    List<AddTradeJiraTypeRequest> requests = Collections.singletonList(request);
    
    TradeReportDocument doc = mock(TradeReportDocument.class);
    when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
    TradeReport report = mock(TradeReport.class);
    ExceptionManagement em = mock(ExceptionManagement.class);
    when(em.getIssueType()).thenReturn(new ExceptionManagement.IssueType("TYPE_A"));
    when(report.getExceptionManagement()).thenReturn(em);
    when(doc.getTradeReport()).thenReturn(report);
    
    when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
    
    // Set different Jira type in request
    AddTradeJiraTypeRequest.JiraType jiraType = new AddTradeJiraTypeRequest.JiraType();
    jiraType.setIssueType("TYPE_B");
    request.setJiraType(jiraType);
    
    // Execute
    List<ActionUpdateResult> results = tradeActionService.removeJiraType(requests, "username");
    
    // Verify validation failure
    assertEquals(1, results.size());
    assertTrue(results.get(0).getError().contains(ActionRequestValidator.JIRA_TYPE_NOT_PRESENT));
}

@Test
    public void testAddComment_ApprovalStatusValidationFailure() {
        AddTradeCommentRequest request = new AddTradeCommentRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeCommentRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(true);

        List<ActionUpdateResult> results = tradeActionService.addComment(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
    }

    @Test
    public void testAddComment_PartialSaveSuccess() {
        AddTradeCommentRequest req1 = new AddTradeCommentRequest();
        req1.setDocumentId(new ActionDocumentId("key1", 1L));
        AddTradeCommentRequest req2 = new AddTradeCommentRequest();
        req2.setDocumentId(new ActionDocumentId("key2", 1L));
        List<AddTradeCommentRequest> requests = Arrays.asList(req1, req2);

        TradeReportDocument doc1 = mock(TradeReportDocument.class);
        TradeReport report1 = mock(TradeReport.class);
        ExceptionManagement em1 = mock(ExceptionManagement.class);
        when(doc1.getDocumentId()).thenReturn(DocumentId.from("key1", 1L));
        when(doc1.getTradeReport()).thenReturn(report1);
        when(report1.getExceptionManagement()).thenReturn(em1);

        TradeReportDocument doc2 = mock(TradeReportDocument.class);
        TradeReport report2 = mock(TradeReport.class);
        ExceptionManagement em2 = mock(ExceptionManagement.class);
        when(doc2.getDocumentId()).thenReturn(DocumentId.from("key2", 1L));
        when(doc2.getTradeReport()).thenReturn(report2);
        when(report2.getExceptionManagement()).thenReturn(em2);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Arrays.asList(doc1, doc2));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(dataUpdater.addCommentsToException(any(), any(), anyString())).thenReturn(em1, em2);

        WriteResult<TradeReport> success = WriteResult.success(DocumentId.from("key1", 2L), report1);
        WriteResult<TradeReport> failure = WriteResult.failure(DocumentId.from("key2", 1L), new RuntimeException("Save failed"));
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Arrays.asList(success, failure));

        List<ActionUpdateResult> results = tradeActionService.addComment(requests, "username");

        assertEquals(2, results.size());
        assertTrue(results.get(0).isSuccess());
        assertTrue(results.get(1).getError().contains("Save failed"));
    }

    @Test
    public void testRemoveComment_DataUpdaterThrowsException() {
        AddTradeCommentRequest request = new AddTradeCommentRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeCommentRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(dataUpdater.removeCommentsToException(any(), any(), anyString())).thenThrow(new RuntimeException("Update error"));

        List<ActionUpdateResult> results = tradeActionService.removeComment(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains("Update error"));
    }

    @Test
    public void testAddCommentType_UserValidationFailure() {
        AddTradeCommentTypeRequest request = new AddTradeCommentTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeCommentTypeRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(false);

        List<ActionUpdateResult> results = tradeActionService.addCommentType(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.USER_VALIDATION_ERROR));
    }

    @Test
    public void testRemoveCommentType_Success() {
        AddTradeCommentTypeRequest request = new AddTradeCommentTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeCommentTypeRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(dataUpdater.removeCommentTypeToException(any(), any(), anyString())).thenReturn(em);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(
            WriteResult.success(DocumentId.from("key", 2L), report)
        ));

        List<ActionUpdateResult> results = tradeActionService.removeCommentType(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    @Test
    public void testUpdateExceptionStatus_MixedValidations() {
        UpdateExceptionStatusRequest req1 = new UpdateExceptionStatusRequest();
        req1.setDocumentId(new ActionDocumentId("key1", 1L));
        UpdateExceptionStatusRequest req2 = new UpdateExceptionStatusRequest();
        req2.setDocumentId(new ActionDocumentId("key2", 1L));
        List<UpdateExceptionStatusRequest> requests = Arrays.asList(req1, req2);

        TradeReportDocument doc1 = mock(TradeReportDocument.class);
        TradeReport report1 = mock(TradeReport.class);
        ExceptionManagement em1 = mock(ExceptionManagement.class);
        when(doc1.getDocumentId()).thenReturn(DocumentId.from("key1", 1L));
        when(doc1.getTradeReport()).thenReturn(report1);
        when(report1.getExceptionManagement()).thenReturn(em1);

        TradeReportDocument doc2 = mock(TradeReportDocument.class);
        TradeReport report2 = mock(TradeReport.class);
        ExceptionManagement em2 = mock(ExceptionManagement.class);
        when(doc2.getDocumentId()).thenReturn(DocumentId.from("key2", 1L));
        when(doc2.getTradeReport()).thenReturn(report2);
        when(report2.getExceptionManagement()).thenReturn(em2);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Arrays.asList(doc1, doc2));
        when(requestValidator.validateUser(eq("username"), eq(em1))).thenReturn(false);
        when(requestValidator.validateUser(eq("username"), eq(em2))).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(requestValidator.validateExceptionStatus(any(), any())).thenReturn(true);
        when(requestValidator.validateApprover(any(), any(), any(), any())).thenReturn(false);
        when(dataUpdater.addExceptionStatus(any(), any(), any(), anyString())).thenReturn(em2);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(
            WriteResult.success(DocumentId.from("key2", 2L), report2)
        ));

        List<ActionUpdateResult> results = tradeActionService.updateExceptionStatus(requests, ExceptionStatus.Edit_Requested, "username");

        assertEquals(2, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.USER_VALIDATION_ERROR));
        assertTrue(results.get(1).isSuccess());
    }

    @Test
    public void testUpdateExceptionStatus_CancelTradeAckedError() {
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);
        when(report.getTransactionReportingStatus()).thenReturn(mock(com.nwm.tntr.commons.domain.persistence.entity.trade.TransactionReportingStatus.class));

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(requestValidator.validateAckedCancleTrade(any(), any())).thenReturn(true);

        List<ActionUpdateResult> results = tradeActionService.updateExceptionStatus(requests, ExceptionStatus.Edit_Requested, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(TradeActionService.CANCEL_TRADE_ACKED_ERROR));
    }

    @Test
    public void testPerformResetAction_NotAllowed() {
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateResetActionApprovalStatus(any(), any())).thenReturn(false);

        List<ActionUpdateResult> results = tradeActionService.performResetAction(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
    }

    @Test
    public void testAssignExceptionToUser_Success() {
        AssignTradeRequest request = new AssignTradeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AssignTradeRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(dataUpdater.assignException(any(), any(), anyString())).thenReturn(em);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(
            WriteResult.success(DocumentId.from("key", 2L), report)
        ));

        List<ActionUpdateResult> results = tradeActionService.assignExceptionToUser(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    @Test
    public void testAddJiraId_JiraIdPresent() {
        AddTradeJiraReferenceRequest request = new AddTradeJiraReferenceRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraReferenceRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(requestValidator.isJiraIdPresent(any(), anyString())).thenReturn(true);

        List<ActionUpdateResult> results = tradeActionService.addJiraId(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.JIRA_ID_PRESENT));
    }

    @Test
    public void testRemoveJiraId_JiraIdNotPresent() {
        AddTradeJiraReferenceRequest request = new AddTradeJiraReferenceRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraReferenceRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(requestValidator.isJiraIdPresent(any(), anyString())).thenReturn(false);

        List<ActionUpdateResult> results = tradeActionService.removeJiraId(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.JIRA_ID_NOT_PRESENT));
    }

    @Test
    public void testAddJiraType_Success() {
        AddTradeJiraTypeRequest request = new AddTradeJiraTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraTypeRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(dataUpdater.addJiraTypeToException(any(), any(), anyString())).thenReturn(em);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(
            WriteResult.success(DocumentId.from("key", 2L), report)
        ));

        List<ActionUpdateResult> results = tradeActionService.addJiraType(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    @Test
    public void testRemoveJiraType_JiraTypeNotPresent() {
        AddTradeJiraTypeRequest request = new AddTradeJiraTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraTypeRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);
        when(em.getIssueType()).thenReturn(mock(com.nwm.tntr.commons.domain.persistence.entity.IssueType.class));

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(em.getIssueType().value()).thenReturn("DifferentType");
        when(request.getJiraType()).thenReturn(mock(AddTradeJiraTypeRequest.JiraType.class));
        when(request.getJiraType().getIssueType()).thenReturn("TestType");

        List<ActionUpdateResult> results = tradeActionService.removeJiraType(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains(ActionRequestValidator.JIRA_TYPE_NOT_PRESENT));
    }

    @Test
    public void testUpdateEditedFields_EditFailure() {
        EditRequest request = new EditRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<EditRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(dataUpdater.updateTradeReportData(any(), any(), anyString(), any())).thenThrow(new BlotterRunTimeException("Edit failed"));

        List<ActionUpdateResult> results = tradeActionService.updateEditedFields(requests, "username", ExceptionStatus.Edit_Requested);

        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains("Edit failed"));
    }

    @Test
    public void testUpdateUserActionType_Success() {
        UpdateUserActionTypeRequest request = new UpdateUserActionTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        request.setUserActionType("TEST_ACTION");
        request.setComment(new UpdateUserActionTypeRequest.Comment("Test comment"));
        List<UpdateUserActionTypeRequest> requests = Collections.singletonList(request);

        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(doc.getTradeReport()).thenReturn(report);
        when(report.getExceptionManagement()).thenReturn(em);
        when(report.getNonReportableData()).thenReturn(mock(NonReportableData.class));

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(dataUpdater.addComments(any(), anyString(), anyString(), any())).thenReturn(em);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(
            WriteResult.success(DocumentId.from("key", 2L), report)
        ));

        List<ActionUpdateResult> results = tradeActionService.updateUserActionType(requests, "username");

        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    @Test
    public void testRollBackRejectedRecords_UsingReflection() throws Exception {
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        request.setDocumentId(new ActionDocumentId("key", 3L));
        Map<DocumentId, UpdateRequest> tradeRequestMap = Collections.singletonMap(
            DocumentId.from("key", 3L), request
        );

        TradeReportDocument prevDoc = mock(TradeReportDocument.class);
        TradeReport prevReport = mock(TradeReport.class);
        when(prevDoc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        when(prevDoc.getTradeReport()).thenReturn(prevReport);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(prevDoc));
        when(dfTradePersistManager.upsertAllRecords(anyList())).thenReturn(Collections.singletonList(
            WriteResult.success(DocumentId.from("key", 1L), prevReport)
        ));

        Method method = TradeActionService.class.getDeclaredMethod("rollBackRejectedRecords", Map.class);
        method.setAccessible(true);
        List<ActionUpdateResult> results = (List<ActionUpdateResult>) method.invoke(tradeActionService, tradeRequestMap);

        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    @Test
    public void testGetResult_NullWriteResults_UsingReflection() throws Exception {
        TradeReportDocument doc = mock(TradeReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        List<TradeReportDocument> docs = Collections.singletonList(doc);

        Method method = TradeActionService.class.getDeclaredMethod("getResult", List.class, List.class);
        method.setAccessible(true);
        List<ActionUpdateResult> results = (List<ActionUpdateResult>) method.invoke(tradeActionService, docs, null);

        assertTrue(results.isEmpty());
    }

    @Test
    public void testPopulateTradeRequestMap_UsingReflection() throws Exception {
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        Map<DocumentId, UpdateRequest> map = new HashMap<>();

        Method method = TradeActionService.class.getDeclaredMethod("populateTradeRequestMap", UpdateRequest.class, Map.class);
        method.setAccessible(true);
        method.invoke(tradeActionService, request, map);

        assertEquals(1, map.size());
        assertEquals(request, map.get(DocumentId.from("key", 1L)));
    }

    @Test
    public void testGetTradeReport_UsingReflection() throws Exception {
        TradeReport tradeReport = mock(TradeReport.class);
        ExceptionManagement em = mock(ExceptionManagement.class);
        NonReportableData nrd = mock(NonReportableData.class);
        when(tradeReport.getNonReportableData()).thenReturn(nrd);

        Method method = TradeActionService.class.getDeclaredMethod("getTradeReport", TradeReport.class, ExceptionManagement.class);
        method.setAccessible(true);
        TradeReport result = (TradeReport) method.invoke(tradeActionService, tradeReport, em);

        verify(tradeReport).newBuilder(tradeReport);
    }

    @Test
    public void testGetReportsWithExpectedBaseVersion_UsingReflection() throws Exception {
        TradeReportDocument doc = mock(TradeReportDocument.class);
        TradeReport report = mock(TradeReport.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));

        Method method = TradeActionService.class.getDeclaredMethod("getReportsWithExpectedBaseVersion", TradeReportDocument.class, TradeReport.class);
        method.setAccessible(true);
        Pair<TradeReport, Long> result = (Pair<TradeReport, Long>) method.invoke(tradeActionService, doc, report);

        assertEquals(report, result.getLeft());
        assertEquals(Long.valueOf(1L), result.getRight());
    }

    @Test
    public void testGetTradePrimaryKey_UsingReflection() throws Exception {
        DocumentId docId = DocumentId.from("key", 1L);

        Method method = TradeActionService.class.getDeclaredMethod("getTradePrimaryKey", DocumentId.class);
        method.setAccessible(true);
        ActionDocumentId result = (ActionDocumentId) method.invoke(tradeActionService, docId);

        assertEquals("key", result.getKey());
        assertEquals(Long.valueOf(1L), result.getVersion());
    }
