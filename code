@Test
public void testDeserialize_ValidDocument() throws Exception {
    MIDashboardAnalytics expected = new MIDashboardAnalytics();
    JsonDocument document = new JsonDocument();
    document.setContents(objectMapper.writeValueAsString(expected));

    MIDashboardAnalytics result = repo.deserailze(document);
    assertNotNull(result);
}

@Test
public void testFlattenMap() throws Exception {
    Map<String, Object> nestedMap = new HashMap<>();
    nestedMap.put("nestedKey", "nestedValue");
    Map<String, Object> inputMap = new HashMap<>();
    inputMap.put("key", "value");
    inputMap.put("nested", nestedMap);

    Map<String, Object> result = (Map<String, Object>) invokePrivateMethod("flattenMap", 
        new Class<?>[]{Map.class}, inputMap);

    assertEquals("value", result.get("key"));
    assertEquals("nestedValue", result.get("nested.nestedKey"));
}

@Test
public void testRenderCftcDataBlock() throws Exception {
    Map<String, Object> inputMap = new HashMap<>();
    inputMap.put("canada", "VERSION_REPORTABLE=true, TRANSACTION_REPORTABLE=false");
    
    Map<String, Object> result = (Map<String, Object>) invokePrivateMethod("renderCftcDataBlock", 
        new Class<?>[]{Map.class, String.class}, inputMap, "canada");
    
    assertEquals("true", result.get("VERSION_REPORTABLE"));
    assertEquals("false", result.get("TRANSACTION_REPORTABLE"));
}

@Test
public void testItrParameterizedQueryForFo() throws Exception {
    Date testDate = new Date();
    IQuery query = (IQuery) invokePrivateMethod("itrParameterizedQueryForFo", 
        new Class<?>[]{Date.class, String.class, String.class}, testDate, "queryId", "selectClause");
    
    assertTrue(query instanceof Itr2ParameterisedQuery);
}

@Test
public void testProcessFoMiData_EmirEtd() {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    doReturn(new HashMap<>()).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.ETD.value());
    verify(spyRepo, atLeastOnce()).persistFoJurisdictionDetermined(eq(AssetClass.ETD.value()), anyString(), any(Date.class), anyMap());
}

@Test
public void testProcessFoMiData_MasInterestRate() {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    doReturn(new HashMap<>()).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.INTEREST_RATE.value());
    verify(spyRepo, atLeastOnce()).persistFoJurisdictionDetermined(eq(AssetClass.INTEREST_RATE.value()), anyString(), any(Date.class), anyMap());
}

@Test
public void testParseItrRecord_UnknownLei() throws Exception {
    String jsonContent = "{\"TRADING_PARTY_LEI\":\"UNKNOWN_LEI\",\"transactionReportable\":true,\"versionReportable\":true}";
    JsonParser parser = objectMapper.getFactory().createParser(jsonContent);
    parser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, AssetClass.FX.value(), EMIR);
    assertTrue(result.get(EMIR).isEmpty());
}

@Test
public void testParseItrRecord_MissingFields() throws Exception {
    String jsonContent = "{}";
    JsonParser parser = objectMapper.getFactory().createParser(jsonContent);
    parser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(parser, AssetClass.FX.value(), EMIR);
    assertEquals("", result.get(EMIR).get(TRADING_PARTY_LEI));
}

@Test
public void testPersistFoJurisdictionDetermined() throws Exception {
    Map<String, Integer> data = new HashMap<>();
    data.put(PLC_REPORTABLE, 5);
    data.put(PLC_NONREPORTABLE, 3);
    
    invokePrivateMethod("persistFoJurisdictionDetermined", 
        new Class<?>[]{String.class, String.class, Date.class, Map.class}, 
        AssetClass.FX.value(), EMIR, new Date(), data);
    
    verify(repo, times(2)).upsertFoMiSnapshot(any());
}

@Test
public void testGenerateFoMap() {
    Map<String, Integer> result = ReflectionTestUtils.invokeMethod(repo, "generateFoMap");
    assertEquals(0, result.get(PLC_REPORTABLE).intValue());
    assertEquals(0, result.get(NV_NOTFOUND).intValue());
}

@Test
public void testFetchFromItrWithParamQuery_SFTR() {
    DFQueryMetaData meta = new DFQueryMetaData();
    Map<String, Map<String, Integer>> dataMap = new HashMap<>();
    dataMap.put(SFTR, new HashMap<>());
    
    ReflectionTestUtils.invokeMethod(repo, "fetchFromItrWithParamQuery", 
        meta, dataMap, "url", SFTR, new Date(), AssetClass.ETD.value());
    
    verify(repo).fetchData(any(), any(), anyString(), anyString(), any());
}

@Test
public void testFetchData_IOExceptionHandling() {
    IQuery query = mock(IQuery.class);
    DFQueryMetaData meta = new DFQueryMetaData();
    Map<String, Map<String, Integer>> dataMap = new HashMap<>();
    dataMap.put(EMIR, new HashMap<>());
    
    repo.fetchData(query, dataMap, "url", EMIR, meta);
    // Verify error logging occurs
}
