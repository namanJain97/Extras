Could you write the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8:/**
 * 
 */
package com.rbs.tntr.business.taggingService.repository;

import static com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIConstants.*;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

import com.rbs.datafabric.shaded.com.google.common.collect.Lists;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.hash.Hashing;
import com.nwm.tntr.commons.domain.persistence.constant.AssetClass;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.nwm.tntr.configuration.ItrConfiguration;
import com.nwm.tntr.itr.IQuery;
import com.nwm.tntr.itr.Itr2ParameterisedQuery;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.OptimisticLockException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.api.exception.UpsertException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.datafabric.domain.client.builder.UpsertRequestBuilder;
import com.rbs.datafabric.shaded.com.google.common.collect.Maps;
import com.rbs.tntr.business.taggingService.service.common.DateTimeService;
import com.rbs.tntr.business.taggingService.service.common.ItrClient;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.DFQueryMetaData;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeMIAalyticsState;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeMIDashboardAnalytics;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeSubjectIdentifier;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIDashboardAnalytics;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.SubjectIdentifier;

/**
 * Description : Repository class for MI Analytics
 *
 * @author agrakit
 * 
 * Created By: Niket Agrawal
 * 
 * Created On 18-10-2021
 * 
 */
@Component
public class MIAnalyticsDashboardRepositoryImpl extends ScanExpressionUtility
		implements MIAnalyticsDashboardRepository {

	private static final String ERROR_INSERT_DF = "Error while inserting export scan into DF";
	private static final Logger LOGGER = LoggerFactory.getLogger(MIAnalyticsDashboardRepositoryImpl.class);
	private static final ObjectMapper objectMapper = new ObjectMapper();
	private final ItrConfiguration itrConfiguration;
	private final ItrClient itrClient;
	private DataFabricClient dfClient;
	final DfConnectionManager dfConnectionManager;

	@Autowired
	public MIAnalyticsDashboardRepositoryImpl(DfConnectionManager dfConnectionManager,
			ItrConfiguration itrConfiguration, ItrClient itrClient) {
		this.dfConnectionManager = dfConnectionManager;
		this.itrConfiguration = itrConfiguration;
		this.itrClient = itrClient;
	}

	@Value("${tntr.df.database.name}")
	private String databaseName;

	@Value("${tntr.df.database.readTimeout}")
	private int readTimeOut;

	@Value("${df.mi.analytics.dashboard.mi.collectionName}")
	private String miCollection;

	@Value("${df.mi.analytics.dashboard.fo.mi.collectionName}")
	private String foMiCollection;

	@Value("${df.mi.analytics.dashboard.fo.mi.emir.endpoint}")
	private String foEmirUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.emir.parameterised.endpoint}")
	private String foEmirParameterisedUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.mas.endpoint}")
	private String foMasUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.mas.parameterised.endpoint}")
	private String foMasParameterisedUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.boi.endpoint}")
	private String foBoiUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.mifid.endpoint}")
	private String foMifidUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.sftr.endpoint}")
	private String foSftrUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.sftr.aldop.endpoint}")
	private String foSftrAldopUrl;

	@Value("${df.mi.analytics.dashboard.fo.mi.cftc.endpoint}")
	private String foCftcUrl;

	@Override
	public void createDfClientConnection() {
		try {
			dfClient = getDfClient(dfConnectionManager);
			LOGGER.info("DF Client connection created");
		} catch (StartableException e) {
			LOGGER.error("Error while creating df client connection", e);
		}
	}

	Document serialize(Object stats) throws JsonProcessingException {
		return (new JsonDocument()).withContents(objectMapper.writeValueAsString(stats));
	}

	MIDashboardAnalytics deserailze(Document document) throws IOException {
		return objectMapper.readValue(((JsonDocument) document).getContents(), MIDashboardAnalytics.class);
	}

	/**
	 * Description : Method to save MI Snapshot
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 18-10-2021
	 * @param stats
	 * @return
	 */
	@Override
	public RecordId upsertMiSnapshot(MIDashboardAnalytics stats) {
		try {
			Document document = serialize(stats);
			LOGGER.info(((JsonDocument) document).getContents());
			String key = calculateMiSnapshotKey(stats.getSubjectIdentifier());
			LOGGER.info("Generated Key is : {}", key);
			UpsertRequestBuilder upsertRequestBuilder = UpsertRequestBuilder.create(databaseName, miCollection)
					.withDocument(document).withKey(key);
			return dfClient.upsert(upsertRequestBuilder);

		} catch (JsonProcessingException | UpsertException | OptimisticLockException e) {
			LOGGER.error(ERROR_INSERT_DF, e);
			throw new TaggingServiceRunTimeException(ERROR_INSERT_DF, e);
		}
	}

	/**
	 * Description : Method to save FO MI Snapshot
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 18-10-2021
	 * @param stats
	 * @return
	 */
	@Override
	public RecordId upsertFoMiSnapshot(FrontOfficeMIDashboardAnalytics stats) {
		try {
			Document document = serialize(stats);
			String key = calculateFoMiSnapshotKey(stats.getSubjectIdentifier());
			LOGGER.info("Generated FO Key is : {}", key);
			LOGGER.info("FO Stat to be persisted with data : {}", ((JsonDocument) document).getContents());
			UpsertRequestBuilder upsertRequestBuilder = UpsertRequestBuilder.create(databaseName, foMiCollection)
					.withDocument(document).withKey(key);
			return dfClient.upsert(upsertRequestBuilder);

		} catch (JsonProcessingException | UpsertException | OptimisticLockException e) {
			LOGGER.error(ERROR_INSERT_DF, e);
			throw new TaggingServiceRunTimeException(ERROR_INSERT_DF, e);
		}
	}

	/**
	 * Description : Method to fetch statistics count from DF
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 17-11-2021
	 * @param dfScanParameters
	 * @param selectField
	 * @return
	 * @throws ScanException 
	 */
	@Override
	public int fetchStatistics(DFQueryMetaData dfScanParameters, String selectField) throws ScanException {
		ScanRequestBuilder scanRequestBuilder = getScanRequestBuilder(dfScanParameters, databaseName,
				dfScanParameters.getCollectionName());
		scanRequestBuilder.withReadTimeoutSeconds(readTimeOut);
		try {
			ScanResult records = dfClient.scan(scanRequestBuilder);

			if (null != records) {
				Iterator<Record> iterator = records.iterator();
				while (iterator.hasNext()) {
					Record dfRecord = iterator.next();
					if (dfRecord != null && dfRecord.getDocument() != null) {
						Document document = dfRecord.getDocument();
						JsonDocument jsonDocument = ((JsonDocument) document);
						if (jsonDocument != null) {
							String resVal = jsonDocument.getContents();
							JsonNode resNode;
							resNode = objectMapper.readTree(resVal);
							return resNode.get(selectField).asInt();
						}
					}
				}
			}

		} catch (IOException e) {
			LOGGER.error("Error while fetching data from DF", e);
			throw new TaggingServiceRunTimeException("Error while fetching data from DF", e);
		}
		return 0;
	}

	@Override
	public List<Record> fetchRecordsFromDf(DFQueryMetaData dfScanParameters) {
		List<Record> results = Lists.newArrayList();
		ScanRequestBuilder scanRequestBuilder = getScanRequestBuilder(dfScanParameters, databaseName,
				dfScanParameters.getCollectionName());
		scanRequestBuilder.withReadTimeoutSeconds(readTimeOut);
		try {
			ScanResult records = dfClient.scan(scanRequestBuilder);
			if (null != records) {
				Iterator<Record> iterator = records.iterator();
				while (iterator.hasNext()) {
					Record dfRecord = iterator.next();
					if (dfRecord != null && dfRecord.getDocument() != null) {
						results.add(dfRecord);
					}
				}
			}

		} catch (Exception e) {
			LOGGER.error("Error while fetching data from DF", e);
			throw new TaggingServiceRunTimeException("Error while fetching data from DF", e);
		}
		return results;
	}

	private String calculateMiSnapshotKey(SubjectIdentifier subjectIdentifier) {
		String encodedKey = (new SimpleDateFormat("ddMMyyyy").format(subjectIdentifier.getBusinessDate())
				.concat(subjectIdentifier.getLei()).concat(subjectIdentifier.getAssetClass())
				.concat(subjectIdentifier.getEntity()).concat(subjectIdentifier.getFlow())
				.concat(subjectIdentifier.getRegulation()).concat(subjectIdentifier.getMessageType())).replaceAll("\\s",
						"");
		encodedKey = Hashing.sha1().hashString(encodedKey, StandardCharsets.UTF_8).toString();
		return encodedKey;
	}

	private String calculateFoMiSnapshotKey(FrontOfficeSubjectIdentifier subjectIdentifier) {
		String encodedKey = (new SimpleDateFormat("ddMMyyyy").format(subjectIdentifier.getBusinessDate())
				.concat(subjectIdentifier.getAssetClass()).concat(subjectIdentifier.getEntity())
				.concat(subjectIdentifier.getLei())
				.concat(subjectIdentifier.getRegulation())).replaceAll("\\s", "");
		encodedKey = Hashing.sha1().hashString(encodedKey, StandardCharsets.UTF_8).toString();
		return encodedKey;
	}

	/**
	 * Description : Method to query on ITR
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 27-01-2022
	 */
	private Map<String, Map<String, Integer>> fetchFromItr(DFQueryMetaData dFQueryMetaData,
			Map<String, Map<String, Integer>> foMiDataMap, String itrUrl, String jurisdiction, Date businessDate,
			String assetClass) {
		try {
            if (BOI.equals(jurisdiction) || MIFID.equals(jurisdiction) || SFTR.equals(jurisdiction)
					|| (EMIR.equals(jurisdiction) && AssetClass.ETD.equals(AssetClass.fromValue(assetClass)))
					|| (MAS.equals(jurisdiction) && AssetClass.INTEREST_RATE.equals(AssetClass.fromValue(assetClass)))) {
				fetchFromItrWithParamQuery(dFQueryMetaData, foMiDataMap, itrUrl, jurisdiction, businessDate, assetClass);
			} else {
				fetchFromItrWithoutParamQuery(dFQueryMetaData, foMiDataMap, itrUrl, jurisdiction);
			}
		} catch (Exception ex) {
			LOGGER.error("Error while processing FO for Jurisdiction :{} and Asset Class : {}", jurisdiction,
					assetClass);
		}

		return foMiDataMap;
	}

	private void fetchFromItrWithParamQuery(DFQueryMetaData dFQueryMetaData, Map<String, Map<String, Integer>> foMiDataMap, String itrUrl,
											String jurisdiction, Date businessDate, String assetClass) {
		String selectClause;
		switch (jurisdiction) {
			case BOI :
				for (String queryId: BOI_ASSETWISE_QUERY_IDS.get(assetClass)) {
					IQuery iQuery  = itrParameterizedQueryForFo(businessDate, queryId,BOI_PARAM_QUERY_SELECT);
					String url = getURL(itrUrl);
					fetchData(iQuery,foMiDataMap,url,jurisdiction,dFQueryMetaData);
				}
				break;
			case MIFID :
				selectClause = MIFID_ASSETWISE_SELECT.get(assetClass);
				for (String queryId: MIFID_ASSETWISE_QUERY_IDS.get(assetClass)) {
					IQuery iQuery  = itrParameterizedQueryForFo(businessDate, queryId,selectClause);
					String url = getURL(itrUrl);
					fetchData(iQuery,foMiDataMap,url,jurisdiction,dFQueryMetaData);
				}
				break;
			case EMIR:
				selectClause = EMIR_ASSETWISE_SELECT.get(assetClass);
				for (String queryId: EMIR_ASSETWISE_QUERY_IDS.get(assetClass)) {
					IQuery iQuery  = itrParameterizedQueryForFo(businessDate, queryId,selectClause);
					String url = getURL(itrUrl);
					fetchData(iQuery,foMiDataMap,url,jurisdiction,dFQueryMetaData);
				}
				break;
			case MAS:
				selectClause = MAS_ASSETWISE_SELECT.get(assetClass);
				for (String queryId: MAS_ASSETWISE_QUERY_IDS.get(assetClass)) {
					IQuery iQuery  = itrParameterizedQueryForFo(businessDate, queryId,selectClause);
					String url = getURL(itrUrl);
					fetchData(iQuery,foMiDataMap,url,jurisdiction,dFQueryMetaData);
				}
				break;
			case SFTR:
				selectClause = SFTR_ASSETWISE_SELECT.get(assetClass);
				for (String queryId: SFTR_ASSETWISE_QUERY_IDS.get(assetClass)) {
					IQuery iQuery  = itrParameterizedQueryForFo(businessDate, queryId,selectClause);
					if (queryId.equals(SFTR_ALDOP_QUERY_ID))
						itrUrl = foSftrAldopUrl;
					String url = getURL(itrUrl);
					fetchData(iQuery,foMiDataMap,url,jurisdiction,dFQueryMetaData);
				}
				break;
		}
	}

	private void fetchData(IQuery iQuery, Map<String, Map<String, Integer>> foMiDataMap, String url, String jurisdiction, DFQueryMetaData dFQueryMetaData) {
		itrClient.fetch(url, iQuery, inputStream -> {
			try (JsonParser jsonParser = objectMapper.getFactory().createParser(inputStream)) {
				if (jsonParser.nextToken() != JsonToken.START_ARRAY) {
					LOGGER.error("Expected {} Array at location {} , token {}", JsonToken.START_ARRAY,
							jsonParser.getCurrentLocation(), jsonParser.getCurrentValue());
					throw new IllegalStateException("Expected content to be start of array");
				}
				while (jsonParser.nextToken() != JsonToken.END_ARRAY) {
					processFoDataMap(parseItrRecord(jsonParser, dFQueryMetaData.getStatName(), jurisdiction),
							foMiDataMap);
				}
			} catch (IOException e) {
				LOGGER.error("Error while processing FO Snapshot for : {}", dFQueryMetaData.getStatName());
			}
		});
	}

	private IQuery itrParameterizedQueryForFo(Date businessDate, String queryId, String selectClause) {

		Itr2ParameterisedQuery.Builder builder = new Itr2ParameterisedQuery.Builder();

		builder.withQueryId(queryId).withQueryPlanLoggingEnabled(true).withStreamResultsEnabled(true)
				.withParams(populateFoLifeTimeParams(businessDate)).withSelect(selectClause);

		return builder.build();
	}

	private Map<String, String> populateFoLifeTimeParams(Date businessDate) {
		Map<String,String> params = Maps.newHashMap();
		DateTime currentDate = new DateTime(businessDate).withZone(DateTimeZone.UTC);
		String startOfDay = DateTimeService
				.asString(DateTimeService.getCurrentStartDateTime(currentDate));
		String endOfDay =  DateTimeService
				.asString(DateTimeService.getCurrentEndDateTime(currentDate));
		params.put(DATETIME_FROM,startOfDay);
		params.put(DATETIME_TO,endOfDay);
		return params;
	}

	private void fetchFromItrWithoutParamQuery(DFQueryMetaData dFQueryMetaData, Map<String, Map<String, Integer>> foMiDataMap, String itrUrl, String jurisdiction) {
		Itr2Query itr2Query = itrQueryForFO(dFQueryMetaData);
		String url = getURL(itrUrl);
		itrClient.fetch(url, itr2Query, inputStream -> {
			try (JsonParser jsonParser = objectMapper.getFactory().createParser(inputStream)) {
				if (jsonParser.nextToken() != JsonToken.START_ARRAY) {
					LOGGER.error("Expected {} Array at location {} , token {}", JsonToken.START_ARRAY,
							jsonParser.getCurrentLocation(), jsonParser.getCurrentValue());
					throw new IllegalStateException("Expected content to be start of array");
				}
				while (jsonParser.nextToken() != JsonToken.END_ARRAY) {
					processFoDataMap(parseItrRecord(jsonParser, dFQueryMetaData.getStatName(), jurisdiction),
							foMiDataMap);
				}
			} catch (IOException e) {
				LOGGER.error("Error while processing FO Snapshot for : {}", dFQueryMetaData.getStatName());
			}
		});
	}

	/**
	 * Description : Method to convert parsed ITR Record
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 31-01-2022
	 * @param parsedRecord
	 */
	private void processFoDataMap(Map<String, Map<String, Object>> parsedRecord,
			Map<String, Map<String, Integer>> foMiData) {

		for (Entry<String, Map<String, Object>> entry : parsedRecord.entrySet()) {
			String jurisdiction = entry.getKey();
			Map<String, Object> parsedItrRecord = entry.getValue();

			String tradingPartyLei = parsedItrRecord.get(TRADING_PARTY_LEI).toString();
			boolean isTransactionReportable = (boolean) parsedItrRecord.get(TRANSACTION_REPORTABLE);
			boolean isVersionReportable = (boolean) parsedItrRecord.get(VERSION_REPORTABLE);
			String lieName;
			String statName = EMPTY;

			switch (tradingPartyLei) {
			case LEI_NWM_PLC:
				lieName = NWM_PLC;
				break;
			case LEI_NWM_NV:
				lieName = NWM_NV;
				break;
			default:
				return;
			}

			if (isTransactionReportable && isVersionReportable) {
				statName = "REPORTABLE";
			} else if (isTransactionReportable && !isVersionReportable) {
				statName = "NONREPORTABLE";
			} else if (!isTransactionReportable && !isVersionReportable) {
				statName = "NOTFOUND";
			}

			String key = lieName.concat("_").concat(statName);
			if (foMiData.get(jurisdiction).containsKey(key)) {
				foMiData.get(jurisdiction).put(key, (foMiData.get(jurisdiction).get(key) + 1));
			}
		}

	}

	String getURL(String queryEndpoint) {
		return String.format("%s://%s/%s", itrConfiguration.getItr2ProtocolScheme(),
				itrConfiguration.getItr2ServiceName(), queryEndpoint);
	}

	Itr2Query itrQueryForFO(DFQueryMetaData queryMeta) {
		Itr2Query.Builder builder = new Itr2Query.Builder();
		if (!StringUtils.isEmpty(queryMeta.getSelect()))
			builder.setSelect(queryMeta.getSelect());
		if (!StringUtils.isEmpty(queryMeta.getWhere()))
			builder.setWhere(queryMeta.getWhere());
		return builder.createItr2Query();
	}

	/**
	 * Description : Method to Parse individual ITR records
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 31-01-2022
	 * @param jsonParser
	 * @param assetClass
	 * @return
	 * @throws IOException
	 */
	Map<String, Map<String, Object>> parseItrRecord(JsonParser jsonParser, String assetClass, String jurisdiction)
			throws IOException {
		Map<String, Object> jsonMap = parseRecord(jsonParser);
		Map<String, Map<String, Object>> result = new HashMap<>();
		String tradingPartyLei = EMPTY;
		boolean isVersionReportable = false;
		boolean isTransactionReportable = false;

		if (CFTC_CSA.equals(jurisdiction) && (AssetClass.FOREIGN_EXCHANGE.value().equals(assetClass) || AssetClass.INTEREST_RATE.value().equals(assetClass))) {
			if (jsonMap.containsKey("canada")) {
				Map<String, Object> itrData = new HashMap<>();
				Map<String, Object> csaDataMap = renderCftcDataBlock(jsonMap, "canada");
				if (AssetClass.FOREIGN_EXCHANGE.value().equals(assetClass) && jsonMap.containsKey(TRADING_PARTY_LEI))
					tradingPartyLei = jsonMap.get(TRADING_PARTY_LEI).toString();
				if (AssetClass.INTEREST_RATE.value().equals(assetClass) && jsonMap.containsKey(PARTY_LEI_CODE))
					tradingPartyLei = jsonMap.get(PARTY_LEI_CODE).toString();
				if (csaDataMap.containsKey(VERSION_REPORTABLE))
					isVersionReportable = Boolean.valueOf(csaDataMap.get(VERSION_REPORTABLE).toString());
				if (csaDataMap.containsKey(TRANSACTION_REPORTABLE))
					isTransactionReportable = Boolean.valueOf(csaDataMap.get(TRANSACTION_REPORTABLE).toString());
				itrData.put(TRANSACTION_REPORTABLE, isTransactionReportable);
				itrData.put(VERSION_REPORTABLE, isVersionReportable);
				itrData.put(TRADING_PARTY_LEI, tradingPartyLei);
				result.put(CSA, itrData);
			}

			if (jsonMap.containsKey("cftc")) {
				Map<String, Object> itrData = new HashMap<>();
				Map<String, Object> cftcDataMap = renderCftcDataBlock(jsonMap, "cftc");
				if (AssetClass.FOREIGN_EXCHANGE.value().equals(assetClass) && jsonMap.containsKey(TRADING_PARTY_LEI))
					tradingPartyLei = jsonMap.get(TRADING_PARTY_LEI).toString();
				if (AssetClass.INTEREST_RATE.value().equals(assetClass) && jsonMap.containsKey(PARTY_LEI_CODE))
					tradingPartyLei = jsonMap.get(PARTY_LEI_CODE).toString();
				if (cftcDataMap.containsKey(VERSION_REPORTABLE))
					isVersionReportable = Boolean.valueOf(cftcDataMap.get(VERSION_REPORTABLE).toString());
				if (cftcDataMap.containsKey(TRANSACTION_REPORTABLE))
					isTransactionReportable = Boolean.valueOf(cftcDataMap.get(TRANSACTION_REPORTABLE).toString());
				itrData.put(TRANSACTION_REPORTABLE, isTransactionReportable);
				itrData.put(VERSION_REPORTABLE, isVersionReportable);
				itrData.put(TRADING_PARTY_LEI, tradingPartyLei);
				result.put(DF, itrData);
			}

		}
		else if(BOI.equals(jurisdiction)) {
			Map<String, Object> itrData = new HashMap<>();
			if (jsonMap.containsKey(TRADING_PARTY_LEI))
				tradingPartyLei = jsonMap.get(TRADING_PARTY_LEI).toString();
			if (jsonMap.containsKey(VERSION_REPORTABLE))
				isVersionReportable = (boolean) jsonMap.get(VERSION_REPORTABLE);
			if (jsonMap.containsKey(TRANSACTION_REPORTABLE))
				isTransactionReportable = (boolean) jsonMap.get(TRANSACTION_REPORTABLE);
			itrData.put(TRANSACTION_REPORTABLE, isTransactionReportable);
			itrData.put(VERSION_REPORTABLE, isVersionReportable);
			itrData.put(TRADING_PARTY_LEI, tradingPartyLei);
			result.put(jurisdiction, itrData);
		} else if(MIFID.equals(jurisdiction)) {
			if (assetClass.equals(AssetClass.ETD.value())){
				Map<String, Object> itrData = new HashMap<>();
				String tradeingCapacity=EMPTY, reportingPartyBookId=EMPTY;
				if (jsonMap.containsKey("tradingCapacity"))
					tradeingCapacity = jsonMap.get("tradingCapacity").toString();
				if (jsonMap.containsKey("reportingPartyBookId"))
					reportingPartyBookId = jsonMap.get("reportingPartyBookId").toString();
				if (tradeingCapacity.equals("Dealing On Own Account") || tradeingCapacity.equals("Matched Principal")
						|| tradeingCapacity.equals("Any Other Capacity")){
						if (reportingPartyBookId.equals("RANL01") ||reportingPartyBookId.equals("RANL00"))
							tradingPartyLei = LEI_NWM_PLC;
						else if (reportingPartyBookId.equals("RANLNV"))
							tradingPartyLei = LEI_NWM_NV;
				}
				if (jsonMap.containsKey(VERSION_REPORTABLE))
					isVersionReportable = (boolean) jsonMap.get(VERSION_REPORTABLE);
				if (jsonMap.containsKey(TRANSACTION_REPORTABLE))
					isTransactionReportable = (boolean) jsonMap.get(TRANSACTION_REPORTABLE);
				itrData.put(TRANSACTION_REPORTABLE, isTransactionReportable);
				itrData.put(VERSION_REPORTABLE, isVersionReportable);
				itrData.put(TRADING_PARTY_LEI, tradingPartyLei);
				result.put(jurisdiction, itrData);
			} else {
				Map<String, Object> itrData = new HashMap<>();
				fetchItrData(itrData, jsonMap, MIFID_ASSETWISE_PARSE_DATA.get(assetClass));
				result.put(jurisdiction, itrData);
			}
		} else if (EMIR.equals(jurisdiction) && AssetClass.ETD.equals(AssetClass.fromValue(assetClass))) {
			Map<String, Object> itrData = new HashMap<>();
			fetchItrData(itrData, jsonMap, EMIR_ASSETWISE_PARSE_DATA.get(assetClass));
			result.put(jurisdiction, itrData);
		} else if (MAS.equals(jurisdiction) && AssetClass.INTEREST_RATE.equals(AssetClass.fromValue(assetClass))) {
			Map<String, Object> itrData = new HashMap<>();
			fetchItrData(itrData, jsonMap, MAS_ASSETWISE_PARSE_DATA.get(assetClass));
			result.put(jurisdiction, itrData);
		} else if (SFTR.equals(jurisdiction)) {
			Map<String, Object> itrData = new HashMap<>();
			fetchItrData(itrData, jsonMap, SFTR_ASSETWISE_PARSE_DATA.get(assetClass));
			result.put(jurisdiction, itrData);
		} else {
			Map<String, Object> itrData = new HashMap<>();
			if (AssetClass.FOREIGN_EXCHANGE.value().equals(assetClass)) {
				if (jsonMap.containsKey(TRADING_PARTY_LEI))
					tradingPartyLei = jsonMap.get(TRADING_PARTY_LEI).toString();
				if (jsonMap.containsKey(VERSION_REPORTABLE))
					isVersionReportable = (boolean) jsonMap.get(VERSION_REPORTABLE);
				if (jsonMap.containsKey(TRANSACTION_REPORTABLE))
					isTransactionReportable = (boolean) jsonMap.get(TRANSACTION_REPORTABLE);
			} else if (AssetClass.CREDIT.value().equals(assetClass)) {
				if (jsonMap.containsKey(PARTY_LEI_CODE))
					tradingPartyLei = jsonMap.get(PARTY_LEI_CODE).toString();
				if (jsonMap.containsKey("emir.isVersionReportable"))
					isVersionReportable = (boolean) jsonMap.get("emir.isVersionReportable");
				if (jsonMap.containsKey("emir.isEligible"))
					isTransactionReportable = (boolean) jsonMap.get("emir.isEligible");
			} else if (AssetClass.INTEREST_RATE.value().equals(assetClass)) {
				if (jsonMap.containsKey(PARTY_LEI_CODE))
					tradingPartyLei = jsonMap.get(PARTY_LEI_CODE).toString();
				if (jsonMap.containsKey(VERSION_REPORTABLE))
					isVersionReportable = (boolean) jsonMap.get(VERSION_REPORTABLE);
				if (jsonMap.containsKey("isEligible"))
					isTransactionReportable = (boolean) jsonMap.get("isEligible");
			}
			itrData.put(TRANSACTION_REPORTABLE, isTransactionReportable);
			itrData.put(VERSION_REPORTABLE, isVersionReportable);
			itrData.put(TRADING_PARTY_LEI, tradingPartyLei);
			result.put(jurisdiction, itrData);
		}
		return result;
	}

	private void fetchItrData(Map<String, Object> itrData, Map<String, Object> jsonMap,  Map<String, String> fieldMap) {
		String tradingPartyLei = EMPTY;
		boolean isVersionReportable = false;
		boolean isTransactionReportable = false;
		if (jsonMap.containsKey(fieldMap.get(TRADING_PARTY_LEI)))
			tradingPartyLei = jsonMap.get(fieldMap.get(TRADING_PARTY_LEI)).toString();
		if (jsonMap.containsKey(fieldMap.get(VERSION_REPORTABLE)))
			isVersionReportable = (boolean) jsonMap.get(fieldMap.get(VERSION_REPORTABLE));
		if (jsonMap.containsKey(fieldMap.get(TRANSACTION_REPORTABLE)))
			isTransactionReportable = (boolean) jsonMap.get(fieldMap.get(TRANSACTION_REPORTABLE));
		itrData.put(TRANSACTION_REPORTABLE, isTransactionReportable);
		itrData.put(VERSION_REPORTABLE, isVersionReportable);
		itrData.put(TRADING_PARTY_LEI, tradingPartyLei);
	}

	/**
	 * Description : Method to read JSON block of CFTC & CSA
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 03-10-2022
	 * @param jsonMap
	 * @return
	 */
	private Map<String, Object> renderCftcDataBlock(Map<String, Object> jsonMap, String jurisdictionBlockName) {
		String inputString = jsonMap.get(jurisdictionBlockName).toString();
		inputString = inputString.replace("{", "");
		inputString = inputString.replace("}", "");
		return Arrays.stream(inputString.split(",")).map(s -> s.trim().split("="))
				.collect(Collectors.toMap(s -> s[0], s -> s[1]));
	}

	@SuppressWarnings("unchecked")
	Map<String, Object> parseRecord(JsonParser jsonParser) throws IOException {
		Map<String, Object> jsonMap = objectMapper.readValue(jsonParser, Map.class);
		return flattenMap(jsonMap);
	}

	private Map<String, Object> flattenMap(Map<String, Object> jsonMap) {
			Map<String, Object> flatenedMap = new HashMap<>();
			jsonMap.forEach((key, value) -> {
				if(value instanceof Map) {
					flattenMap((Map) value).forEach((key1,value1)->{
						flatenedMap.put(key+"."+key1,value1);
					});
				} else {
					flatenedMap.put(key, value);
				}
			});
			return flatenedMap;
	}

	/**
	 * Description : Method to process FO MI Data
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 31-01-2022
	 * @param dFQueryMetaData
	 * @param businessDate
	 */
	@Override
	public void processFoMiData(DFQueryMetaData dFQueryMetaData, Date businessDate, String assetClass) {
		String itrUrl;
		Integer plcNotFound = 0;
		Integer nvNotFound = 0;
		for (String jurisdiction : FO_ASSETWISE_MAP.get(assetClass)) {
			long startTime = System.currentTimeMillis();
			Map<String, Map<String, Integer>> baseDataMap;
			switch (jurisdiction) {
			case EMIR:
				if (AssetClass.ETD.equals(AssetClass.fromValue(assetClass)))
					itrUrl = foEmirParameterisedUrl;
				else
					itrUrl = foEmirUrl;
				baseDataMap = Collections.singletonMap(EMIR, generateFoMap());
				break;
			case MAS:
				if (AssetClass.INTEREST_RATE.equals(AssetClass.fromValue(assetClass)))
					itrUrl = foMasParameterisedUrl;
				else
					itrUrl = foMasUrl;
				baseDataMap = Collections.singletonMap(MAS, generateFoMap());
				break;
			case BOI:
				itrUrl = foBoiUrl;
				baseDataMap = Collections.singletonMap(BOI, generateFoMap());
				break;
			case MIFID:
				itrUrl = foMifidUrl;
				baseDataMap = Collections.singletonMap(MIFID, generateFoMap());
				break;
				case SFTR:
				itrUrl = foSftrUrl;
				baseDataMap = Collections.singletonMap(SFTR, generateFoMap());
				break;
			case CFTC_CSA:
				itrUrl = foCftcUrl;
				if (AssetClass.FOREIGN_EXCHANGE.value().equals(assetClass))
					dFQueryMetaData.setSelect(CFTC_CSA_FX_SELECT);
				if (AssetClass.INTEREST_RATE.value().equals(assetClass))
					dFQueryMetaData.setSelect(CFTC_CSA_IR_SELECT);
				baseDataMap = new HashMap<>();
				baseDataMap.put(DF, generateFoMap());
				baseDataMap.put(CSA, generateFoMap());
				break;
			default:
				LOGGER.error("No setup found for assetClass : {} and jurisdiction : {}", assetClass, jurisdiction);
				throw new TaggingServiceRunTimeException(
						"No Fo Setup Found for assetClass: " + assetClass + " and jurisdiction : " + jurisdiction);
			}

			Map<String, Map<String, Integer>> jurisdictionWiseFoData = fetchFromItr(dFQueryMetaData, baseDataMap, itrUrl,
						jurisdiction, businessDate,assetClass);
			for (Entry<String, Map<String, Integer>> entry : jurisdictionWiseFoData.entrySet()) {
				LOGGER.info("Processing FO MI For AssetClass : {} & Jurisdiction : {}", assetClass, jurisdiction);
				Map<String, Integer> jurisdictionFoData = entry.getValue();
				String jurisdictionName = entry.getKey();
				persistFoJurisdictionDetermined(assetClass, jurisdictionName, businessDate, jurisdictionFoData);
				plcNotFound += jurisdictionFoData.get(PLC_NOTFOUND);
				nvNotFound += jurisdictionFoData.get(NV_NOTFOUND);
				}

				long executionTime = (System.currentTimeMillis() - startTime) / 1000;
				LOGGER.info("Time taken For AssetClass : {} & Jurisdiction : {} calculation is : {} seconds",
						assetClass, jurisdiction, executionTime);
			}

			persistFoJurisdictionNotDetermined(assetClass, businessDate, plcNotFound, nvNotFound);

	}

	/**
	 * Description : Method to Persist PLC & NV FO Snapshot for jurisdiction determined
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 30-09-2022
	 * @param assetClass
	 * @param businessDate
	 * @param itrMiData
	 */
	private void persistFoJurisdictionDetermined(String assetClass, String jurisdiction, Date businessDate,
			Map<String, Integer> itrMiData) {
		persistFoMiData(NWM_PLC, LEI_NWM_PLC, assetClass, jurisdiction, businessDate, itrMiData.get(PLC_REPORTABLE),
				itrMiData.get(PLC_NONREPORTABLE));
		persistFoMiData(NWM_NV, LEI_NWM_NV, assetClass, jurisdiction, businessDate, itrMiData.get(NV_REPORTABLE),
				itrMiData.get(NV_NONREPORTABLE));
	}

	/**
	 * Description :  Method to Persist PLC & NV FO Snapshot for jurisdiction not determined
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 30-09-2022
	 * @param assetClass
	 * @param businessDate
	 */
	private void persistFoJurisdictionNotDetermined(String assetClass, Date businessDate,
			Integer plcNotFound, Integer nvNotFound) {
		persistFoMiData(NWM_PLC, LEI_NWM_PLC, assetClass, JND, businessDate, 0, plcNotFound);
		persistFoMiData(NWM_NV, LEI_NWM_NV, assetClass, JND, businessDate, 0, nvNotFound);
	}

	private Map<String, Integer> generateFoMap() {
		Map<String, Integer> foDataMap = new HashMap<>();
		foDataMap.put(PLC_REPORTABLE, 0);
		foDataMap.put(PLC_NONREPORTABLE, 0);
		foDataMap.put(PLC_NOTFOUND, 0);
		foDataMap.put(NV_REPORTABLE, 0);
		foDataMap.put(NV_NONREPORTABLE, 0);
		foDataMap.put(NV_NOTFOUND, 0);
		return foDataMap;
	}

	/**
	 * Description : Method to prepare FO MI snapshot for DF
	 * @author agrakit
	 * Created By: Niket Agrawal
	 * Created On 31-01-2022
	 * @param entity
	 * @param assetClass
	 * @param regulation
	 * @param businessDate
	 * @param reportable
	 * @param nonReportable
	 */
	private void persistFoMiData(String entity,String lei, String assetClass, String regulation, Date businessDate,
			Integer reportable, Integer nonReportable) {
		FrontOfficeSubjectIdentifier subjectIdentifier = new FrontOfficeSubjectIdentifier(entity, lei, assetClass,
				regulation, businessDate);
		FrontOfficeMIAalyticsState state = new FrontOfficeMIAalyticsState();
		state.setReportableCount(reportable);
		state.setNonReportableCount(nonReportable);
		state.setTotalRecordCount(state.getReportableCount() + state.getNonReportableCount());
		FrontOfficeMIDashboardAnalytics foAnalytics = new FrontOfficeMIDashboardAnalytics();
		foAnalytics.setMiAnalyticsState(state);
		foAnalytics.setSubjectIdentifier(subjectIdentifier);
		upsertFoMiSnapshot(foAnalytics);

	}
}

Remember not to use power mockito as i m using older mockito version. Also we can't change or modify any other file apart from this above test class. If there is any private method then try to use reflection for that. 
