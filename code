// Add these additional test methods to your existing MIAnalyticsDashboardRepositoryImplTest class

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchStatistics_IOException() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");

    ScanResult scanResult = mock(ScanResult.class);
    Record record = mock(Record.class);
    JsonDocument document = mock(JsonDocument.class);
    when(record.getDocument()).thenReturn(document);
    when(document.getContents()).thenReturn("invalid json");
    Iterator<Record> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(record);
    when(scanResult.iterator()).thenReturn(iterator);
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(scanResult);

    repo.fetchStatistics(dfScanParameters, "count");
}

@Test
public void testFetchStatistics_NullScanResult() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(null);

    int result = repo.fetchStatistics(dfScanParameters, "count");
    assertEquals(0, result);
}

@Test
public void testFetchStatistics_NullRecord() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");

    ScanResult scanResult = mock(ScanResult.class);
    Iterator<Record> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(null);
    when(scanResult.iterator()).thenReturn(iterator);
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(scanResult);

    int result = repo.fetchStatistics(dfScanParameters, "count");
    assertEquals(0, result);
}

@Test
public void testFetchStatistics_NullDocument() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");

    ScanResult scanResult = mock(ScanResult.class);
    Record record = mock(Record.class);
    when(record.getDocument()).thenReturn(null);
    Iterator<Record> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(record);
    when(scanResult.iterator()).thenReturn(iterator);
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(scanResult);

    int result = repo.fetchStatistics(dfScanParameters, "count");
    assertEquals(0, result);
}

@Test
public void testFetchStatistics_NullJsonDocument() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");

    ScanResult scanResult = mock(ScanResult.class);
    Record record = mock(Record.class);
    Document document = mock(Document.class); // Not JsonDocument
    when(record.getDocument()).thenReturn(document);
    Iterator<Record> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(record);
    when(scanResult.iterator()).thenReturn(iterator);
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(scanResult);

    int result = repo.fetchStatistics(dfScanParameters, "count");
    assertEquals(0, result);
}

@Test
public void testFetchRecordsFromDf_NullScanResult() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(null);

    List<Record> results = repo.fetchRecordsFromDf(dfScanParameters);
    assertTrue(results.isEmpty());
}

@Test
public void testFetchRecordsFromDf_NullRecord() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");

    ScanResult scanResult = mock(ScanResult.class);
    Iterator<Record> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(null);
    when(scanResult.iterator()).thenReturn(iterator);
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(scanResult);

    List<Record> results = repo.fetchRecordsFromDf(dfScanParameters);
    assertTrue(results.isEmpty());
}

@Test
public void testFetchRecordsFromDf_NullDocument() throws Exception {
    DFQueryMetaData dfScanParameters = new DFQueryMetaData();
    dfScanParameters.setCollectionName("miCollection");

    ScanResult scanResult = mock(ScanResult.class);
    Record record = mock(Record.class);
    when(record.getDocument()).thenReturn(null);
    Iterator<Record> iterator = mock(Iterator.class);
    when(iterator.hasNext()).thenReturn(true, false);
    when(iterator.next()).thenReturn(record);
    when(scanResult.iterator()).thenReturn(iterator);
    when(dfClient.scan(any(ScanRequestBuilder.class))).thenReturn(scanResult);

    List<Record> results = repo.fetchRecordsFromDf(dfScanParameters);
    assertTrue(results.isEmpty());
}

@Test
public void testItrQueryForFO_EmptySelectAndWhere() {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setSelect("");
    metadata.setWhere("");

    Itr2Query result = repo.itrQueryForFO(metadata);
    assertNotNull(result);
}

@Test
public void testItrQueryForFO_NullSelectAndWhere() {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setSelect(null);
    metadata.setWhere(null);

    Itr2Query result = repo.itrQueryForFO(metadata);
    assertNotNull(result);
}

@Test
public void testProcessFoDataMap_WithNWM_NV() throws Exception {
    Map<String, Map<String, Object>> parsedRecord = new HashMap<>();
    Map<String, Object> data = new HashMap<>();
    data.put(TRADING_PARTY_LEI, LEI_NWM_NV);
    data.put(TRANSACTION_REPORTABLE, true);
    data.put(VERSION_REPORTABLE, true);
    parsedRecord.put(EMIR, data);

    Map<String, Map<String, Integer>> foMiData = new HashMap<>();
    foMiData.put(EMIR, new HashMap<String, Integer>() {{
        put("NWM_NV_REPORTABLE", 0);
    }});

    invokePrivateMethod("processFoDataMap", new Class<?>[]{Map.class, Map.class}, parsedRecord, foMiData);

    assertEquals(1, foMiData.get(EMIR).get("NWM_NV_REPORTABLE").intValue());
}

@Test
public void testProcessFoDataMap_WithNonReportable() throws Exception {
    Map<String, Map<String, Object>> parsedRecord = new HashMap<>();
    Map<String, Object> data = new HashMap<>();
    data.put(TRADING_PARTY_LEI, LEI_NWM_PLC);
    data.put(TRANSACTION_REPORTABLE, true);
    data.put(VERSION_REPORTABLE, false);
    parsedRecord.put(EMIR, data);

    Map<String, Map<String, Integer>> foMiData = new HashMap<>();
    foMiData.put(EMIR, new HashMap<String, Integer>() {{
        put("NWM_PLC_NONREPORTABLE", 0);
    }});

    invokePrivateMethod("processFoDataMap", new Class<?>[]{Map.class, Map.class}, parsedRecord, foMiData);

    assertEquals(1, foMiData.get(EMIR).get("NWM_PLC_NONREPORTABLE").intValue());
}

@Test
public void testProcessFoDataMap_WithNotFound() throws Exception {
    Map<String, Map<String, Object>> parsedRecord = new HashMap<>();
    Map<String, Object> data = new HashMap<>();
    data.put(TRADING_PARTY_LEI, LEI_NWM_PLC);
    data.put(TRANSACTION_REPORTABLE, false);
    data.put(VERSION_REPORTABLE, false);
    parsedRecord.put(EMIR, data);

    Map<String, Map<String, Integer>> foMiData = new HashMap<>();
    foMiData.put(EMIR, new HashMap<String, Integer>() {{
        put("NWM_PLC_NOTFOUND", 0);
    }});

    invokePrivateMethod("processFoDataMap", new Class<?>[]{Map.class, Map.class}, parsedRecord, foMiData);

    assertEquals(1, foMiData.get(EMIR).get("NWM_PLC_NOTFOUND").intValue());
}

@Test
public void testProcessFoDataMap_WithUnknownLei() throws Exception {
    Map<String, Map<String, Object>> parsedRecord = new HashMap<>();
    Map<String, Object> data = new HashMap<>();
    data.put(TRADING_PARTY_LEI, "UNKNOWN_LEI");
    data.put(TRANSACTION_REPORTABLE, true);
    data.put(VERSION_REPORTABLE, true);
    parsedRecord.put(EMIR, data);

    Map<String, Map<String, Integer>> foMiData = new HashMap<>();
    foMiData.put(EMIR, new HashMap<String, Integer>());

    invokePrivateMethod("processFoDataMap", new Class<?>[]{Map.class, Map.class}, parsedRecord, foMiData);

    // Should not add anything for unknown LEI
    assertTrue(foMiData.get(EMIR).isEmpty());
}

@Test
public void testParseItrRecordForMifidEtdWithNV() throws Exception {
    String jsonContent = "{\"tradingCapacity\":\"Dealing On Own Account\", " +
            "\"reportingPartyBookId\":\"RANLNV\", " +
            "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
    JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
    jsonParser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(jsonParser,
            AssetClass.ETD.value(), MIFID);

    assertTrue(result.containsKey(MIFID));
    assertEquals(LEI_NWM_NV, result.get(MIFID).get(TRADING_PARTY_LEI));
}

@Test
public void testParseItrRecordForMifidEtdWithRANL00() throws Exception {
    String jsonContent = "{\"tradingCapacity\":\"Dealing On Own Account\", " +
            "\"reportingPartyBookId\":\"RANL00\", " +
            "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
    JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
    jsonParser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(jsonParser,
            AssetClass.ETD.value(), MIFID);

    assertTrue(result.containsKey(MIFID));
    assertEquals(LEI_NWM_PLC, result.get(MIFID).get(TRADING_PARTY_LEI));
}

@Test
public void testParseItrRecordForMifidEtdWithMatchedPrincipal() throws Exception {
    String jsonContent = "{\"tradingCapacity\":\"Matched Principal\", " +
            "\"reportingPartyBookId\":\"RANL01\", " +
            "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
    JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
    jsonParser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(jsonParser,
            AssetClass.ETD.value(), MIFID);

    assertTrue(result.containsKey(MIFID));
    assertEquals(LEI_NWM_PLC, result.get(MIFID).get(TRADING_PARTY_LEI));
}

@Test
public void testParseItrRecordForMifidEtdWithAnyOtherCapacity() throws Exception {
    String jsonContent = "{\"tradingCapacity\":\"Any Other Capacity\", " +
            "\"reportingPartyBookId\":\"RANL01\", " +
            "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
    JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
    jsonParser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(jsonParser,
            AssetClass.ETD.value(), MIFID);

    assertTrue(result.containsKey(MIFID));
    assertEquals(LEI_NWM_PLC, result.get(MIFID).get(TRADING_PARTY_LEI));
}

@Test
public void testParseItrRecordForMifidEtdWithDifferentCapacity() throws Exception {
    String jsonContent = "{\"tradingCapacity\":\"Different Capacity\", " +
            "\"reportingPartyBookId\":\"RANL01\", " +
            "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
    JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
    jsonParser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(jsonParser,
            AssetClass.ETD.value(), MIFID);

    assertTrue(result.containsKey(MIFID));
    assertEquals("", result.get(MIFID).get(TRADING_PARTY_LEI));
}

@Test
public void testParseItrRecordForSftr() throws Exception {
    String jsonContent = "{\"" + SFTR_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_PLC + "\", " +
            "\"" + SFTR_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(VERSION_REPORTABLE) + "\":true, " +
            "\"" + SFTR_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(TRANSACTION_REPORTABLE) + "\":true}";
    JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
    jsonParser.nextToken();

    Map<String, Map<String, Object>> result = repo.parseItrRecord(jsonParser,
            AssetClass.FOREIGN_EXCHANGE.value(), SFTR);

    assertTrue(result.containsKey(SFTR));
    assertEquals(LEI_NWM_PLC, result.get(SFTR).get(TRADING_PARTY_LEI));
    assertEquals(true, result.get(SFTR).get(VERSION_REPORTABLE));
    assertEquals(true, result.get(SFTR).get(TRANSACTION_REPORTABLE));
}

@Test
public void testFetchItrData() throws Exception {
    Map<String, Object> itrData = new HashMap<>();
    Map<String, Object> jsonMap = new HashMap<>();
    jsonMap.put("tradingPartyLei", LEI_NWM_PLC);
    jsonMap.put("versionReportable", true);
    jsonMap.put("transactionReportable", true);

    Map<String, String> fieldMap = new HashMap<>();
    fieldMap.put(TRADING_PARTY_LEI, "tradingPartyLei");
    fieldMap.put(VERSION_REPORTABLE, "versionReportable");
    fieldMap.put(TRANSACTION_REPORTABLE, "transactionReportable");

    invokePrivateMethod("fetchItrData", new Class<?>[]{Map.class, Map.class, Map.class}, 
                       itrData, jsonMap, fieldMap);

    assertEquals(LEI_NWM_PLC, itrData.get(TRADING_PARTY_LEI));
    assertEquals(true, itrData.get(VERSION_REPORTABLE));
    assertEquals(true, itrData.get(TRANSACTION_REPORTABLE));
}

@Test
public void testFetchItrDataWithMissingFields() throws Exception {
    Map<String, Object> itrData = new HashMap<>();
    Map<String, Object> jsonMap = new HashMap<>();
    // Empty jsonMap

    Map<String, String> fieldMap = new HashMap<>();
    fieldMap.put(TRADING_PARTY_LEI, "tradingPartyLei");
    fieldMap.put(VERSION_REPORTABLE, "versionReportable");
    fieldMap.put(TRANSACTION_REPORTABLE, "transactionReportable");

    invokePrivateMethod("fetchItrData", new Class<?>[]{Map.class, Map.class, Map.class}, 
                       itrData, jsonMap, fieldMap);

    assertEquals("", itrData.get(TRADING_PARTY_LEI));
    assertEquals(false, itrData.get(VERSION_REPORTABLE));
    assertEquals(false, itrData.get(TRANSACTION_REPORTABLE));
}

@Test
public void testDeserialize_ValidJson() throws Exception {
    JsonDocument document = new JsonDocument();
    SubjectIdentifier identifier = new SubjectIdentifier("lei", "entity", "flow", "asset", "message", "regulation", TEST_DATE);
    MIDashboardAnalytics analytics = new MIDashboardAnalytics();
    analytics.setSubjectIdentifier(identifier);
    
    String json = objectMapper.writeValueAsString(analytics);
    document.setContents(json);

    MIDashboardAnalytics result = repo.deserailze(document);
    assertNotNull(result);
}

@Test
public void testProcessFoMiData_EMIR_NonETD() throws Exception {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    
    // Mock the fetchFromItr method behavior
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    Map<String, Map<String, Integer>> mockResult = new HashMap<>();
    mockResult.put(EMIR, new HashMap<String, Integer>() {{
        put(PLC_REPORTABLE, 1);
        put(PLC_NONREPORTABLE, 2);
        put(PLC_NOTFOUND, 3);
        put(NV_REPORTABLE, 4);
        put(NV_NONREPORTABLE, 5);
        put(NV_NOTFOUND, 6);
    }});
    
    doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
    
    // Verify that upsertFoMiSnapshot was called
    verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
}

@Test
public void testProcessFoMiData_MAS_NonIR() throws Exception {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    Map<String, Map<String, Integer>> mockResult = new HashMap<>();
    mockResult.put(MAS, new HashMap<String, Integer>() {{
        put(PLC_REPORTABLE, 1);
        put(PLC_NONREPORTABLE, 2);
        put(PLC_NOTFOUND, 3);
        put(NV_REPORTABLE, 4);
        put(NV_NONREPORTABLE, 5);
        put(NV_NOTFOUND, 6);
    }});
    
    doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
    
    verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
}

@Test
public void testProcessFoMiData_BOI() throws Exception {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    Map<String, Map<String, Integer>> mockResult = new HashMap<>();
    mockResult.put(BOI, new HashMap<String, Integer>() {{
        put(PLC_REPORTABLE, 1);
        put(PLC_NONREPORTABLE, 2);
        put(PLC_NOTFOUND, 3);
        put(NV_REPORTABLE, 4);
        put(NV_NONREPORTABLE, 5);
        put(NV_NOTFOUND, 6);
    }});
    
    doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
    
    verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
}

@Test
public void testProcessFoMiData_MIFID() throws Exception {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    Map<String, Map<String, Integer>> mockResult = new HashMap<>();
    mockResult.put(MIFID, new HashMap<String, Integer>() {{
        put(PLC_REPORTABLE, 1);
        put(PLC_NONREPORTABLE, 2);
        put(PLC_NOTFOUND, 3);
        put(NV_REPORTABLE, 4);
        put(NV_NONREPORTABLE, 5);
        put(NV_NOTFOUND, 6);
    }});
    
    doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
    
    verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
}

@Test
public void testProcessFoMiData_SFTR() throws Exception {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    
    MIAnalyticsDashboardRepositoryImpl spyRepo = spy(repo);
    Map<String, Map<String, Integer>> mockResult = new HashMap<>();
    mockResult.put(SFTR, new HashMap<String, Integer>() {{
        put(PLC_REPORTABLE, 1);
        put(PLC_NONREPORTABLE, 2);
        put(PLC_NOTFOUND, 3);
        put(NV_REPORTABLE, 4);
        put(NV_NONREPORTABLE, 5);
        put(NV_NOTFOUND, 6);
    }});
    
    doReturn(mockResult).when(spyRepo).fetchFromItr(any(), any(), anyString(), anyString(), any(), anyString());
    doReturn(mock(RecordId.class)).when(spyRepo).upsertFoMiSnapshot(any());
    
    spyRepo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
    
    verify(spyRepo, atLeast(1)).upsertFoMiSnapshot(any());
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testProcessFoMiData_UnknownJurisdiction() throws Exception {
    DFQueryMetaData metadata = new DFQueryMetaData();
    metadata.setStatName("testStat");
    
    // Mock FO_ASSETWISE_MAP to return unknown jurisdiction
    Map<String, List<String>> mockMap = new HashMap<>();
    mockMap.put(AssetClass.FOREIGN_EXCHANGE.value(), Arrays.asList("UNKNOWN_JURISDICTION"));
    
    // This will throw TaggingServiceRunTimeException due to unknown jurisdiction
    repo.processFoMiData(metadata, TEST_DATE, AssetClass.FOREIGN_EXCHANGE.value());
}

@Test
public void testPopulateFoLifeTimeParams() throws Exception {
    Date testDate = new Date();
    Map<String, String> result = (Map<String, String>) invokePrivateMethod("populateFoLifeTimeParams", 
                                                                           new Class<?>[]{Date.class}, testDate);
    
    assertNotNull(result);
    assertTrue(result.containsKey(DATETIME_FROM));
    assertTrue(result.containsKey(DATETIME_TO));
}

@Test
public void testItrParameterizedQueryForFo() throws Exception {
    Date testDate = new Date();
    String queryId = "testQueryId";
    String selectClause = "testSelect";
    
    IQuery result = (IQuery) invokePrivateMethod("itrParameterizedQueryForFo", 
                                                 new Class<?>[]{Date.class, String.class, String.class}, 
                                                 testDate, queryId, selectClause);
    
    assertNotNull(result);
}

@Test
public void testFetchFromItrWithParamQuery_MIFID() throws Exception {
    Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
    foMiDataMap.put(MIFID, generateTestFoMap());
    DFQueryMetaData dfQueryMetaData = new DFQueryMetaData();
    dfQueryMetaData.setStatName("testStat");

    invokePrivateMethod("fetchFromItrWithParamQuery", 
                       new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                       dfQueryMetaData, foMiDataMap, "mifidUrl", MIFID, new Date(), AssetClass.FOREIGN_EXCHANGE.value());

    // Method should complete without throwing exception
    assertNotNull(foMiDataMap);
}

@Test
public void testFetchFromItrWithParamQuery_EMIR() throws Exception {
    Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
    foMiDataMap.put(EMIR, generateTestFoMap());
    DFQueryMetaData dfQueryMetaData = new DFQueryMetaData();
    dfQueryMetaData.setStatName("testStat");

    invokePrivateMethod("fetchFromItrWithParamQuery", 
                       new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                       dfQueryMetaData, foMiDataMap, "emirUrl", EMIR, new Date(), AssetClass.ETD.value());

    assertNotNull(foMiDataMap);
}

@Test
public void testFetchFromItrWithParamQuery_MAS() throws Exception {
    Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
    foMiDataMap.put(MAS, generateTestFoMap());
    DFQueryMetaData dfQueryMetaData = new DFQueryMetaData();
    dfQueryMetaData.setStatName("testStat");

    invokePrivateMethod("fetchFromItrWithParamQuery", 
                       new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                       dfQueryMetaData, foMiDataMap, "masUrl", MAS, new Date(), AssetClass.INTEREST_RATE.value());

    assertNotNull(foMiDataMap);
}

@Test
public void testFetchFromItrWithParamQuery_SFTR_WithAldop() throws Exception {
    Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
    foMiDataMap.put(SFTR, generateTestFoMap());
    DFQueryMetaData dfQueryMetaData = new DFQueryMetaData();
    dfQueryMetaData.setStatName("testStat");

    // Mock SFTR_ALDOP_QUERY_ID to test the special case
    Map<String, List<String>> mockQueryIds = new HashMap<>();
    mockQueryIds.put(AssetClass.FOREIGN_EXCHANGE.value(), Arrays.asList(SFTR_ALDOP_QUERY_ID));

    invokePrivateMethod("fetchFromItrWithParamQuery", 
                       new Class<?>[]{DFQueryMetaData.class, Map.class, String.class, String.class, Date.class, String.class},
                       dfQueryMetaData, foMiDataMap, "sftrUrl", SFTR, new Date(), AssetClass.FOREIGN_EXCHANGE.value());

    assertNotNull(foMiDataMap);
}

@Test
public void testFetchData() throws Exception {
    IQuery mockQuery = mock(IQuery.class);
    Map<String, Map<String, Integer>> foMiDataMap = new HashMap<>();
    foMiDataMap.put("testJurisdiction", generateTestFoMap());
    String url = "testUrl";
    String jurisdiction = "testJurisdiction";
    DFQueryMetaData dfQueryMetaData = new DFQueryMetaData();
    dfQueryMetaData.setStatName("testStat");

    invokePrivateMethod("fetchData", 
                       new Class<?>[]{IQuery.class, Map.class, String.
