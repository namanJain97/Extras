@Test
public void testGetResult_WithCauseInError() throws Exception {
    // Setup
    ReconReportDocument doc = getTestReconReport();
    List<ReconReportDocument> docs = Lists.newArrayList(doc);
    
    WriteErrorDetail<ReconReport> errorDetail = new WriteErrorDetail<>(
        doc.getReconReport(), 
        new RuntimeException("Underlying cause"), 
        "Top-level error"
    );
    List<WriteResult<ReconReport>> writeResults = Lists.newArrayList(
        WriteResult.forFailure(errorDetail)
    );
    
    // Execute
    List<ReconciliationUpdateResult> results = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, "getResult", docs, writeResults
    );
    
    // Verify
    assertEquals(1, results.size());
    assertEquals(Status.FAILIURE, results.get(0).getStatus());
    assertEquals("Top-level error. Underlying cause", results.get(0).getErrorDetail());
}

@Test
public void testGetReconWithComments_UserValidationFailure() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(docs.get(0).getDocumentId(), getCommentRequest());
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Force user validation failure
    when(blotterSecurityService.getLoggedInUserName()).thenReturn("invalid_user");
    
    // Execute
    List<Pair<ReconReport, Long>> result = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, 
        "getReconWithComments", 
        docs, requests, writeResults
    );
    
    // Verify
    assertTrue(result.isEmpty());
    assertEquals(1, writeResults.size());
    assertEquals(ActionRequestValidator.USER_VALIDATION_ERROR, writeResults.get(0).getErrorDetail());
}

@Test
public void testGetReconWithJiraId_JiraIdPresent() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(docs.get(0).getDocumentId(), getAddJiraRequest());
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Add duplicate JIRA ID
    ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, 
        "getReconWithJiraId", 
        docs, requests, writeResults
    );
    
    // Execute again to trigger "JIRA_ID_PRESENT"
    List<Pair<ReconReport, Long>> result = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, 
        "getReconWithJiraId", 
        docs, requests, writeResults
    );
    
    // Verify
    assertTrue(result.isEmpty());
    assertEquals(1, writeResults.size());
    assertEquals(ActionRequestValidator.JIRA_ID_PRESENT, writeResults.get(0).getErrorDetail());
}

@Test
public void testRemoveJiraId_JiraIdNotPresent() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    
    // Request to remove non-existent JIRA ID
    AddReconciliationJiraReference request = (AddReconciliationJiraReference) getRemoveJiraRequest();
    request.getJiraReference().setJiraId("NON_EXISTENT_ID");
    requests.put(docs.get(0).getDocumentId(), request);
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Execute
    List<Pair<ReconReport, Long>> result = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, 
        "removeJiraId", 
        docs, requests, writeResults
    );
    
    // Verify
    assertTrue(result.isEmpty());
    assertEquals(1, writeResults.size());
    assertEquals(ActionRequestValidator.JIRA_ID_NOT_PRESENT, writeResults.get(0).getErrorDetail());
}

@Test
public void testGetReconWithJiraType_UserValidationFailure() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(docs.get(0).getDocumentId(), getAddJiraTypeRequest());
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Force user validation failure
    when(blotterSecurityService.getLoggedInUserName()).thenReturn("invalid_user");
    
    // Execute
    List<Pair<ReconReport, Long>> result = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, 
        "getReconWithJiraType", 
        docs, requests, writeResults
    );
    
    // Verify
    assertTrue(result.isEmpty());
    assertEquals(1, writeResults.size());
    assertEquals(ActionRequestValidator.USER_VALIDATION_ERROR, writeResults.get(0).getErrorDetail());
}

@Test
public void testRemoveJiraType_JiraTypeNotPresent() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    
    // Request to remove non-existent JIRA type
    AddReconciliationJiraType request = (AddReconciliationJiraType) getRemoveJiraTypeRequest();
    request.getJiraType().setIssueType("NON_EXISTENT_TYPE");
    requests.put(docs.get(0).getDocumentId(), request);
    
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Execute
    List<Pair<ReconReport, Long>> result = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, 
        "removeJiraType", 
        docs, requests, writeResults
    );
    
    // Verify
    assertTrue(result.isEmpty());
    assertEquals(1, writeResults.size());
    assertEquals(ActionRequestValidator.JIRA_TYPE_NOT_PRESENT, writeResults.get(0).getErrorDetail());
}

@Test
public void testExecuteReadCommand_Exception() {
    // Setup
    FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
    request.setWhereClause("test_where");
    request.setSelectClause("test_select");
    request.setGroupByClause("test_group_by");
    
    // Force exception
    when(dfReconPersistManager.findProjectionWithGroupingByQuery(Mockito.any()))
        .thenThrow(new RuntimeException("Test exception"));
    
    // Execute & Verify
    try {
        reconciliationServiceImpl.executeReadCommand(request);
        fail("Expected BlotterRunTimeException");
    } catch (BlotterRunTimeException e) {
        assertTrue(e.getMessage().contains("Error occured while fetching record(s) for recon dashboard."));
        assertNotNull(e.getCause());
    }
}

@Test
public void testGetReconWithWorkflow_ExceptionInUpdater() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    Map<DocumentId, ReconciliationRequest> requests = new HashMap<>();
    requests.put(docs.get(0).getDocumentId(), getWorkflowRequest());
    List<ReconciliationUpdateResult> writeResults = new ArrayList<>();
    
    // Force exception in dataUpdater
    ReconDataUpdater mockUpdater = Mockito.mock(ReconDataUpdater.class);
    when(mockUpdater.addWorkflowToException(Mockito.any(), Mockito.any(), Mockito.any()))
        .thenThrow(new RuntimeException("Test exception"));
    ReflectionTestUtils.setField(reconciliationServiceImpl, "dataUpdater", mockUpdater);
    
    // Execute & Verify
    assertThrows(BlotterRunTimeException.class, () -> 
        ReflectionTestUtils.invokeMethod(
            reconciliationServiceImpl, 
            "getReconWithWorkflow", 
            docs, requests, writeResults
        )
    );
}

@Test
public void testSaveAllRecords_EmptyReports() {
    // Setup
    List<ReconReportDocument> docs = Lists.newArrayList(getTestReconReport());
    List<Pair<ReconReport, Long>> reports = Collections.emptyList();
    
    // Execute
    List<ReconciliationUpdateResult> results = ReflectionTestUtils.invokeMethod(
        reconciliationServiceImpl, "saveAllRecords", docs, reports
    );
    
    // Verify
    assertTrue(results.isEmpty());
}
