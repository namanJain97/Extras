package com.rbs.tntr.business.taggingService.repository;

import static org.junit.Assert.; import static org.mockito.Matchers.; import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.*;

import com.fasterxml.jackson.core.JsonParser; import com.nwm.tntr.commons.domain.persistence.constant.AssetClass; import com.nwm.tntr.commons.repository.df.DfConnectionManager; import com.rbs.datafabric.api.ScanResult; import com.rbs.datafabric.api.exception.OptimisticLockException; import com.rbs.datafabric.api.exception.ScanException; import com.rbs.datafabric.api.exception.UpsertException; import com.rbs.datafabric.client.DataFabricClient; import com.rbs.datafabric.domain.Document; import com.rbs.datafabric.domain.JsonDocument; import com.rbs.datafabric.domain.Record; import com.rbs.datafabric.domain.RecordId; import com.rbs.datafabric.domain.client.builder.UpsertRequestBuilder; import com.rbs.tntr.business.taggingService.service.common.DateTimeService; import com.rbs.tntr.business.taggingService.service.common.ItrClient; import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.DFQueryMetaData; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIDashboardAnalytics; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.SubjectIdentifier; import org.junit.Before; import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.springframework.test.util.ReflectionTestUtils;

public class MIAnalyticsDashboardRepositoryImplTest { MIAnalyticsDashboardRepositoryImpl repo; @Mock DfConnectionManager dfConn; @Mock ItrConfiguration itrConfig; @Mock ItrClient itrClient; @Mock DataFabricClient dfClient;

@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    repo = new MIAnalyticsDashboardRepositoryImpl(dfConn, itrConfig, itrClient);
    // inject dfClient
    ReflectionTestUtils.setField(repo, "dfClient", dfClient);
    // set config fields
    ReflectionTestUtils.setField(repo, "databaseName", "db");
    ReflectionTestUtils.setField(repo, "miCollection", "micoll");
    ReflectionTestUtils.setField(repo, "foMiCollection", "fomicoll");
    ReflectionTestUtils.setField(repo, "readTimeOut", 5);
    ReflectionTestUtils.setField(repo, "foEmirUrl", "emir");
    ReflectionTestUtils.setField(repo, "foEmirParameterisedUrl", "emirp");
    ReflectionTestUtils.setField(repo, "foMasUrl", "mas");
    ReflectionTestUtils.setField(repo, "foMasParameterisedUrl", "masp");
    ReflectionTestUtils.setField(repo, "foBoiUrl", "boi");
    ReflectionTestUtils.setField(repo, "foMifidUrl", "mifid");
    ReflectionTestUtils.setField(repo, "foSftrUrl", "sftr");
    ReflectionTestUtils.setField(repo, "foSftrAldopUrl", "sftrap");
    ReflectionTestUtils.setField(repo, "foCftcUrl", "cftc");
}

@Test
public void testCreateDfClientConnection_success() throws Exception {
    // simulate getDfClient
    MIAnalyticsDashboardRepositoryImpl spy = spy(repo);
    doReturn(dfClient).when(spy).getDfClient(dfConn);
    spy.createDfClientConnection();
    // no exception
}

@Test
public void testCreateDfClientConnection_failure() throws Exception {
    MIAnalyticsDashboardRepositoryImpl spy = spy(repo);
    doThrow(new com.rbs.datafabric.agile.commons.lang.StartableException("fail")).when(spy).getDfClient(dfConn);
    spy.createDfClientConnection();
}

@Test
public void testSerializeDeserialize() throws Exception {
    MIDashboardAnalytics stats = new MIDashboardAnalytics();
    SubjectIdentifier id = new SubjectIdentifier();
    id.setBusinessDate(new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-19"));
    id.setAssetClass(AssetClass.ETD.value());
    stats.setSubjectIdentifier(id);
    Document doc = repo.serialize(stats);
    assertTrue(doc instanceof JsonDocument);
    MIDashboardAnalytics out = repo.deserailze(doc);
    assertNotNull(out);
    assertEquals(AssetClass.ETD.value(), out.getSubjectIdentifier().getAssetClass());
}

@Test
public void testUpsertMiSnapshot_success() throws Exception {
    MIDashboardAnalytics stats = new MIDashboardAnalytics();
    stats.setSubjectIdentifier(new SubjectIdentifier());
    RecordId rid = new RecordId(); rid.setKey("k"); rid.setVersion(1);
    when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenReturn(rid);
    RecordId actual = repo.upsertMiSnapshot(stats);
    assertEquals("k", actual.getKey());
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testUpsertMiSnapshot_failure() throws Exception {
    MIDashboardAnalytics stats = new MIDashboardAnalytics(); stats.setSubjectIdentifier(new SubjectIdentifier());
    when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenThrow(new UpsertException("err"));
    repo.upsertMiSnapshot(stats);
}

@Test
public void testUpsertFoMiSnapshot_success() throws Exception {
    FrontOfficeMIDashboardAnalytics fo = new FrontOfficeMIDashboardAnalytics();
    when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenReturn(new RecordId());
    RecordId rid = repo.upsertFoMiSnapshot(fo);
    assertNotNull(rid);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testUpsertFoMiSnapshot_failure() throws Exception {
    FrontOfficeMIDashboardAnalytics fo = new FrontOfficeMIDashboardAnalytics();
    when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenThrow(new OptimisticLockException("o"));
    repo.upsertFoMiSnapshot(fo);
}

@Test
public void testFetchStatistics_ok() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData();
    meta.setCollectionName("c"); meta.setStatName("cnt");
    // prepare scan result
    ScanResult scan = mock(ScanResult.class);
    Record rec = mock(Record.class);
    JsonDocument jd = new JsonDocument().withContents("{\"cnt\":5}");
    when(rec.getDocument()).thenReturn(jd);
    when(scan.iterator()).thenReturn(Arrays.asList(rec).iterator());
    when(dfClient.scan(any())).thenReturn(scan);
    int cnt = repo.fetchStatistics(meta, "cnt");
    assertEquals(5, cnt);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchStatistics_ioError() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("c"); meta.setStatName("cnt");
    ScanResult scan = mock(ScanResult.class);
    Record rec = mock(Record.class);
    JsonDocument jd = new JsonDocument().withContents("invalid json");
    when(rec.getDocument()).thenReturn(jd);
    when(scan.iterator()).thenReturn(Arrays.asList(rec).iterator());
    when(dfClient.scan(any())).thenReturn(scan);
    repo.fetchStatistics(meta, "cnt");
}

@Test
public void testFetchStatistics_nullRecords() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("c");
    when(dfClient.scan(any())).thenReturn(null);
    int cnt = repo.fetchStatistics(meta, "cnt");
    assertEquals(0, cnt);
}

@Test
public void testFetchRecordsFromDf_ok() {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("c");
    ScanResult scan = mock(ScanResult.class);
    Record rec = mock(Record.class);
    when(rec.getDocument()).thenReturn(new JsonDocument());
    when(scan.iterator()).thenReturn(Arrays.asList(rec,null).iterator());
    when(dfClient.scan(any())).thenReturn(scan);
    List<Record> list = repo.fetchRecordsFromDf(meta);
    assertEquals(1, list.size());
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchRecordsFromDf_failure() {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("c");
    when(dfClient.scan(any())).thenThrow(new RuntimeException("boom"));
    repo.fetchRecordsFromDf(meta);
}

@Test
public void testCalculateKeys() throws Exception {
    SubjectIdentifier si = new SubjectIdentifier();
    si.setBusinessDate(new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-19"));
    si.setAssetClass("A"); si.setEntity("E"); si.setFlow("F"); si.setLei("L"); si.setRegulation("R"); si.setMessageType("M");
    String key = ReflectionTestUtils.invokeMethod(repo, "calculateMiSnapshotKey", si);
    assertNotNull(key);
    FrontOfficeSubjectIdentifier fo = new FrontOfficeSubjectIdentifier("E","L","A","R", new Date());
    String key2 = ReflectionTestUtils.invokeMethod(repo, "calculateFoMiSnapshotKey", fo);
    assertNotNull(key2);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testProcessFoMiData_unknownJurisdiction() {
    DFQueryMetaData meta = new DFQueryMetaData();
    repo.processFoMiData(meta, new Date(), "UNKNOWN");
}

// Additional tests for fetchFromItr, parseItrRecord, processFoDataMap can follow similar pattern

}

