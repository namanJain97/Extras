package com.rbs.tntr.business.taggingService.service.common;

import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.nwm.tntr.configuration.ItrConfiguration;
import com.nwm.tntr.itr.IQuery;
import com.rbs.tntr.business.taggingService.configuration.TaggingAuthenticationService;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.web.client.*;

@RunWith(MockitoJUnitRunner.class)
public class ItrClientImplTest {

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private TaggingAuthenticationService authenticationService;

    @Mock
    private ItrConfiguration itrConfiguration;
    
    @Mock
    private ClientHttpResponse clientHttpResponse;

    @InjectMocks
    private ItrClientImpl itrClientImpl;

    private URL url;
    private Itr2Query itr2Query;
    private IQuery iQuery;
    private String urlString;
    private List<String> mockResponse;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        url = new URL("http://test-url.com");
        urlString = "http://test-url.com";
        itr2Query = mock(Itr2Query.class);
        iQuery = mock(IQuery.class);
        mockResponse = new ArrayList<>();
        mockResponse.add("Test response");
        
        when(itrConfiguration.getItr2SsoPermission()).thenReturn("TEST_PERMISSION");
        when(authenticationService.getApplicationSsoToken(anyString())).thenReturn("TEST_SSO_TOKEN");
    }

    @Test
    public void testFetchWithUrlAndItr2Query() {
        // Setup
        ResponseEntity<List<String>> responseEntity = new ResponseEntity<>(mockResponse, HttpStatus.OK);
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class)))
                .thenReturn(responseEntity);

        // Execute
        List<String> result = itrClientImpl.fetch(url, itr2Query, String.class);

        // Verify
        assertNotNull(result);
        assertEquals(mockResponse, result);
        verify(authenticationService).getApplicationSsoToken(anyString());
        verify(itrConfiguration).getItr2SsoPermission();
        verify(restTemplate).exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class));
    }

    @Test
    public void testFetchWithStringUrlAndItr2Query() throws Exception {
        // Setup
        final ByteArrayInputStream inputStream = new ByteArrayInputStream("test data".getBytes());
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(clientHttpResponse.getBody()).thenReturn(inputStream);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenAnswer(new Answer<Object>() {
                    @Override
                    public Object answer(InvocationOnMock invocation) throws Throwable {
                        ResponseExtractor<?> extractor = invocation.getArgumentAt(3, ResponseExtractor.class);
                        extractor.extractData(clientHttpResponse);
                        return null;
                    }
                });

        // Execute
        List<String> result = itrClientImpl.fetch(urlString, itr2Query, streamConsumer);

        // Verify
        assertNull(result);
        verify(streamConsumer).accept(inputStream);
        verify(clientHttpResponse).getBody();
    }

    @Test
    public void testFetchWithStringUrlAndIQuery() throws Exception {
        // Setup
        final ByteArrayInputStream inputStream = new ByteArrayInputStream("test data".getBytes());
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(clientHttpResponse.getBody()).thenReturn(inputStream);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenAnswer(new Answer<Object>() {
                    @Override
                    public Object answer(InvocationOnMock invocation) throws Throwable {
                        ResponseExtractor<?> extractor = invocation.getArgumentAt(3, ResponseExtractor.class);
                        extractor.extractData(clientHttpResponse);
                        return null;
                    }
                });

        // Execute
        List<String> result = itrClientImpl.fetch(urlString, iQuery, streamConsumer);

        // Verify
        assertNull(result);
        verify(streamConsumer).accept(inputStream);
        verify(clientHttpResponse).getBody();
    }

    @Test(expected = HttpClientErrorException.class)
    public void testFetchWithUrlThrowsHttpClientErrorException() {
        // Setup
        HttpClientErrorException exception = new HttpClientErrorException(HttpStatus.BAD_REQUEST, "Bad Request", "Error".getBytes(), null);
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(url, itr2Query, String.class);
    }

    @Test(expected = HttpServerErrorException.class)
    public void testFetchWithUrlThrowsHttpServerErrorException() {
        // Setup
        HttpServerErrorException exception = new HttpServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR, "Server Error", "Error".getBytes(), null);
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(url, itr2Query, String.class);
    }

    @Test(expected = UnknownHttpStatusCodeException.class)
    public void testFetchWithUrlThrowsUnknownHttpStatusCodeException() {
        // Setup
        UnknownHttpStatusCodeException exception = new UnknownHttpStatusCodeException(999, "Unknown", HttpHeaders.EMPTY, "Error".getBytes(), null);
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(url, itr2Query, String.class);
    }

    @Test(expected = RuntimeException.class)
    public void testFetchWithUrlThrowsGenericException() {
        // Setup
        RuntimeException exception = new RuntimeException("Generic error");
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(url, itr2Query, String.class);
    }

    @Test(expected = HttpClientErrorException.class)
    public void testFetchWithStringUrlAndItr2QueryThrowsHttpClientErrorException() {
        // Setup
        HttpClientErrorException exception = new HttpClientErrorException(HttpStatus.BAD_REQUEST, "Bad Request", "Error".getBytes(), null);
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(urlString, itr2Query, streamConsumer);
    }

    @Test(expected = HttpServerErrorException.class)
    public void testFetchWithStringUrlAndItr2QueryThrowsHttpServerErrorException() {
        // Setup
        HttpServerErrorException exception = new HttpServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR, "Server Error", "Error".getBytes(), null);
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(urlString, itr2Query, streamConsumer);
    }

    @Test(expected = UnknownHttpStatusCodeException.class)
    public void testFetchWithStringUrlAndItr2QueryThrowsUnknownHttpStatusCodeException() {
        // Setup
        UnknownHttpStatusCodeException exception = new UnknownHttpStatusCodeException(999, "Unknown", HttpHeaders.EMPTY, "Error".getBytes(), null);
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(urlString, itr2Query, streamConsumer);
    }

    @Test(expected = RuntimeException.class)
    public void testFetchWithStringUrlAndItr2QueryThrowsGenericException() {
        // Setup
        RuntimeException exception = new RuntimeException("Generic error");
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(urlString, itr2Query, streamConsumer);
    }

    @Test(expected = HttpClientErrorException.class)
    public void testFetchWithStringUrlAndIQueryThrowsHttpClientErrorException() {
        // Setup
        HttpClientErrorException exception = new HttpClientErrorException(HttpStatus.BAD_REQUEST, "Bad Request", "Error".getBytes(), null);
        final Consumer<InputStream> streamConsumer = mock(Consumer.class);
        
        when(restTemplate.execute(
                eq(urlString),
                eq(HttpMethod.POST),
                any(JsonRequestCallback.class),
                any(ResponseExtractor.class)))
                .thenThrow(exception);

        // Execute - should throw exception
        itrClientImpl.fetch(urlString, iQuery, streamConsumer);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testGetJsonBodyThrowsJsonProcessingException() throws Exception {
        // Setup - Create a spy to test the private method
        ItrClientImpl spy = spy(itrClientImpl);
        
        doThrow(new JsonProcessingException("Test exception") {
            private static final long serialVersionUID = 1L;
        }).when(spy).fetch(any(URL.class), any(Itr2Query.class), any(Class.class));
        
        // Prepare a malformed object that would cause JsonProcessingException
        Object badObject = new Object() {
            @Override
            public String toString() {
                throw new RuntimeException("Bad object");
            }
        };
        
        // Force the exception in the spy by calling the method with the bad object
        spy.fetch(url, itr2Query, String.class);
    }

    @Test
    public void testResponseWithNonOkStatus() {
        // Setup
        ResponseEntity<List<String>> responseEntity = new ResponseEntity<>(HttpStatus.NOT_FOUND);
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                any(HttpEntity.class),
                any(ParameterizedTypeReference.class)))
                .thenReturn(responseEntity);
        
        try {
            // Execute
            itrClientImpl.fetch(url, itr2Query, String.class);
            fail("Expected exception was not thrown");
        } catch (IllegalStateException e) {
            // Verify exception message
            assertEquals("Unable to fetch data from Itr", e.getMessage());
        }
    }

    @Test
    public void testHeadersAreCorrectlySet() {
        // Setup
        ResponseEntity<List<String>> responseEntity = new ResponseEntity<>(mockResponse, HttpStatus.OK);
        ArgumentCaptor<HttpEntity> httpEntityCaptor = ArgumentCaptor.forClass(HttpEntity.class);
        
        when(restTemplate.exchange(
                eq(url.toString()),
                eq(HttpMethod.POST),
                httpEntityCaptor.capture(),
                any(ParameterizedTypeReference.class)))
                .thenReturn(responseEntity);
        
        // Execute
        itrClientImpl.fetch(url, itr2Query, String.class);
        
        // Verify headers
        HttpEntity<?> capturedEntity = httpEntityCaptor.getValue();
        HttpHeaders headers = capturedEntity.getHeaders();
        
        assertEquals(MediaType.APPLICATION_JSON, headers.getContentType());
        assertEquals("TEST_SSO_TOKEN", headers.getFirst("sso-token"));
        assertNotNull(headers.getFirst("RequestId"));
    }
}
