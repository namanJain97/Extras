@Test
    public void testAddComment_UserValidationFailure() throws Exception {
        AddTradeCommentRequest request = new AddTradeCommentRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeCommentRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(false);

        List<ActionUpdateResult> results = valuationActionService.addComment(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains(ActionRequestValidator.USER_VALIDATION_ERROR));
    }

    // Test cases for updateExceptionStatus method
    @Test
    public void testUpdateExceptionStatus_EditRejectedRollback() throws Exception {
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateExceptionStatus(any(), any())).thenReturn(true);
        when(dataUpdater.addExceptionStatus(any(), any(), any(), anyString())).thenReturn(exceptionManagement);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.emptyList());

        // Mock rollback
        when(dfTradePersistManager.upsertAllRecords(anyList())).thenReturn(Collections.singletonList(
                new WriteResult<>(DocumentId.from("key", 1L), new ValuationReport())
        ));

        List<ActionUpdateResult> results = valuationActionService.updateExceptionStatus(
                requests, ExceptionStatus.Edit_Rejected, "username"
        );
        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    // Test cases for updateEditedFields method
    @Test
    public void testUpdateEditedFields_BlotterRuntimeException() throws Exception {
        EditRequest request = new EditRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<EditRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        doThrow(new BlotterRunTimeException("Edit error")).when(dataUpdater)
                .updateTradeReportData(any(), any(), anyString(), any());

        List<ActionUpdateResult> results = valuationActionService.updateEditedFields(
                requests, "username", ExceptionStatus.Edit_Requested
        );
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains("Edit error"));
    }

    // Test cases for addJiraId method
    @Test
    public void testAddJiraId_JiraIdAlreadyPresent() throws Exception {
        AddTradeJiraReferenceRequest request = new AddTradeJiraReferenceRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraReferenceRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(requestValidator.isJiraIdPresent(any(), anyString())).thenReturn(true);

        List<ActionUpdateResult> results = valuationActionService.addJiraId(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains(ActionRequestValidator.JIRA_ID_PRESENT));
    }

    // Test cases for removeJiraId method
    @Test
    public void testRemoveJiraId_JiraIdNotPresent() throws Exception {
        AddTradeJiraReferenceRequest request = new AddTradeJiraReferenceRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraReferenceRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);
        when(requestValidator.isJiraIdPresent(any(), anyString())).thenReturn(false);

        List<ActionUpdateResult> results = valuationActionService.removeJiraId(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains(ActionRequestValidator.JIRA_ID_NOT_PRESENT));
    }

    // Test cases for removeJiraType method
    @Test
    public void testRemoveJiraType_JiraTypeNotPresent() throws Exception {
        AddTradeJiraTypeRequest request = new AddTradeJiraTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeJiraTypeRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);
        when(exceptionManagement.getIssueType()).thenReturn(new ExceptionManagement.IssueType("differentType"));

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(false);

        List<ActionUpdateResult> results = valuationActionService.removeJiraType(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains(ActionRequestValidator.JIRA_TYPE_NOT_PRESENT));
    }

    // Test cases for updateUserActionType method
    @Test
    public void testUpdateUserActionType_Success() throws Exception {
        UpdateUserActionTypeRequest request = new UpdateUserActionTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        request.setComment(new Comment("comment"));
        request.setUserActionType("APPROVE");
        List<UpdateUserActionTypeRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);
        NonReportableData nonReportableData = mock(NonReportableData.class);
        when(report.getNonReportableData()).thenReturn(nonReportableData);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(dataUpdater.addComments(any(), anyString(), anyString(), any())).thenReturn(exceptionManagement);
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(
                new WriteResult<>(DocumentId.from("key", 2L), new ValuationReport())
        ));

        List<ActionUpdateResult> results = valuationActionService.updateUserActionType(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).isSuccess());
    }

    // Test cases for performResetAction method
    @Test
    public void testPerformResetAction_ApprovalStatusValidationFailure() throws Exception {
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<UpdateExceptionStatusRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateResetActionApprovalStatus(any(), any())).thenReturn(false);

        List<ActionUpdateResult> results = valuationActionService.performResetAction(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains(ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
    }

    // Test cases for removeCommentType method
    @Test
    public void testRemoveCommentType_ApprovalStatusValidationFailure() throws Exception {
        AddTradeCommentTypeRequest request = new AddTradeCommentTypeRequest();
        request.setDocumentId(new ActionDocumentId("key", 1L));
        List<AddTradeCommentTypeRequest> requests = Collections.singletonList(request);

        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        ValuationReport report = mock(ValuationReport.class);
        when(doc.getValuationReport()).thenReturn(report);
        ExceptionManagement exceptionManagement = mock(ExceptionManagement.class);
        when(report.getExceptionManagement()).thenReturn(exceptionManagement);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenReturn(Collections.singletonList(doc));
        when(requestValidator.validateUser(anyString(), any())).thenReturn(true);
        when(requestValidator.validateApprovalStatus(any())).thenReturn(true);

        List<ActionUpdateResult> results = valuationActionService.removeCommentType(requests, "username");
        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains(ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
    }

    // Test cases for getTradePrimaryKey method using reflection
    @Test
    public void testGetTradePrimaryKey_Reflection() throws Exception {
        DocumentId documentId = DocumentId.from("key", 1L);
        Method method = ValuationActionService.class.getDeclaredMethod("getTradePrimaryKey", DocumentId.class);
        method.setAccessible(true);
        ActionDocumentId result = (ActionDocumentId) method.invoke(valuationActionService, documentId);
        assertEquals("key", result.getKey());
        assertEquals(1L, result.getVersion().longValue());
    }

    // Test cases for saveAllRecords method error handling
    @Test
    public void testSaveAllRecords_ErrorHandling() throws Exception {
        ValuationReportDocument doc = mock(ValuationReportDocument.class);
        when(doc.getDocumentId()).thenReturn(DocumentId.from("key", 1L));
        List<ValuationReportDocument> docs = Collections.singletonList(doc);

        WriteResult<ValuationReport> writeResult = new WriteResult<>(
                DocumentId.from("key", 1L),
                new BlotterRunTimeException("DB error", new RuntimeException("Cause"))
        );
        when(dfTradePersistManager.saveAllRecords(anyList())).thenReturn(Collections.singletonList(writeResult));

        Method method = ValuationActionService.class.getDeclaredMethod(
                "getResult", List.class, List.class
        );
        method.setAccessible(true);
        List<ActionUpdateResult> results = (List<ActionUpdateResult>) method.invoke(
                valuationActionService, docs, Collections.singletonList(writeResult)
        );

        assertEquals(1, results.size());
        assertTrue(results.get(0).getErrorMessage().contains("DB error"));
    }
