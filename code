import numpy as np
import pandas as pd
from dateutil import parser
import matplotlib.pyplot as plt
import re
import pandas as pd
from itertools import combinations
from datetime import datetime
from sklearn.preprocessing import MinMaxScaler

def removeAbsoluteLinear(df):
    duplicate_columns = []
    for col1 in df.columns:
        for col2 in df.columns:
            if col1 != col2 and df[col1].nunique() == df[col2].nunique():
                cond1 = (df.groupby(col1)[col2].nunique() == 1).all()
                cond2 = (df.groupby(col2)[col1].nunique() == 1).all()
                if cond1 and cond2 and col1 not in duplicate_columns and col2 not in duplicate_columns:
                    duplicate_columns.append(col2)

    # Remove duplicate columns based on linearity condition
    unique_columns = df.columns.difference(duplicate_columns)

    # New DataFrame with non-duplicate columns
    df_unique = df[unique_columns]
    return df_unique

def getDateFeatures(data):
    datetime_format = r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z(\[UTC\])?$|^(\d{2}-\d{2}-\d{4}\s\d{1,2}:\d{2})$|^\d{1,2}/\d{1,2}/\d{4}\s\d{1,2}:\d{2}$'
    
    matching_columns = data.apply(lambda col: col.astype(str).str.match(datetime_format).any())
    datetime_column = matching_columns[matching_columns].index.tolist()
    return datetime_column

def getOrdinalFeatures():
    return ['reportableData.transactionType', 'reportableData.lifecycleEvent', 'reportableData.action']

def fillMissingDiscreteNulls(data):
    disc_cols = getDiscreteFeatures(data)
    data[disc_cols] = data[disc_cols].fillna('Novalue')
    return data

def getNumericColumns(data): 
    numeric_columns = data.select_dtypes(include=['int16', 'float', 'int32', 'int64']).columns.tolist()   
    bin_cols = getBinFeatures(data)
    result  = [x for x in numeric_columns if x not in bin_cols] 
    return result

def getContinuousColumns(data): 
    threshold = 10
    numeric_columns = data.select_dtypes(include=['int16', 'float', 'int32', 'int64']).columns.tolist()
    cont_cols = data[numeric_columns].columns[(data[numeric_columns].nunique() ) > threshold]
   
    return cont_cols

def getNumericDescreteColumns(data): 
    threshold = 10
    numeric_columns = data.select_dtypes(include=['int16', 'float', 'int32', 'int64']).columns.tolist()
    cont_cols = data[numeric_columns].columns[(data[numeric_columns].nunique() ) <= threshold]
   
    return cont_cols

def doValueImputationForVariance(data):
    data1 = meanImputationforNumericalFeatures(data)
    data2 = fillMissingNominalNulls(data)
    data3 = fillMissingOrdinalNulls(data)
    combined_df = pd.concat([data1, data2, data3], axis = 1)
    return combined_df

def getZeroVarianceColumns(data, doImputation): 
    if doImputation == True:
        df = doValueImputationForVariance(data)
        same_value_columns = df.columns[df.nunique() == 1].tolist()
        
    else:
        same_value_columns = data.columns[data.nunique() == 1].tolist()
        
    return same_value_columns
