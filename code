@Test
public void testPopulateManualFields_ProcessingErrorState() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put("transactionStateValue", "Processing Error");
    map.put("tntrReceivedTimestamp", "2022-01-01T00:00:00.000Z");
    invokePopulateManualFieldsMethod(map);
    assertNotNull(map.get("EXCEPTION_AGE"));
    assertNotNull(map.get("EXCEPTION_AGE_BUCKET"));
}

@Test
public void testPopulateManualFields_AcknowledgedState() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put("transactionStateValue", "Acknowledged");
    map.put("reportingDeadline", "2022-01-01T00:00:00.000Z");
    map.put("trResponseDateTime", "2022-01-02T00:00:00.000Z"); // After deadline
    invokePopulateManualFieldsMethod(map);
    assertEquals("Late Reported", map.get("TIMELINESS"));
}

@Test
public void testPopulateManualFields_OutsideSLA() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put("transactionStateValue", "Failed Acknowledgement");
    map.put("reportingDeadline", "2022-01-01T00:00:00.000Z");
    invokePopulateManualFieldsMethod(map);
    assertEquals("Outside SLA", map.get("TIMELINESS"));
}

@Test
public void testGetDateDifference_Months() throws Exception {
    DateTime start = new DateTime(2022, 1, 1, 0, 0);
    DateTime end = new DateTime(2022, 3, 1, 0, 0);
    String diff = invokeGetDateDifferenceInStandardFormatMethod(start, end);
    assertEquals("2M", diff);
}

@Test
public void testGetDateDifference_Days() throws Exception {
    DateTime start = new DateTime(2022, 1, 1, 0, 0);
    DateTime end = new DateTime(2022, 1, 3, 1, 30);
    String diff = invokeGetDateDifferenceInStandardFormatMethod(start, end);
    assertEquals("2d 1h 30m 0s ", diff);
}

@Test
public void testRenderMiReportData_MIKnown() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put("minDate", "2022-01-01T00:00:00.000Z");
    map.put("maxDate", "2022-01-10T00:00:00.000Z");
    invokeRenderMiReportDataMethod("MI_KNOWN", map);
    assertTrue(Long.parseLong(map.get("minDate")) > 0);
    assertTrue(Long.parseLong(map.get("maxDate")) > 0);
}

@Test
public void testRenderMiReportData_MIDailyTransaction() throws Exception {
    Map<String, String> map = new HashMap<>();
    map.put("MI_DAILY_EXCEPTION_STATUS", "Open");
    map.put("MI_DAILY_MESSAGE_TYPE", "Snapshot");
    invokeRenderMiReportDataMethod("MI_DAILY_TRANSACTION", map);
    assertEquals("Transaction", map.get("MI_DAILY_MESSAGE_TYPE"));
}

@Test
public void testGetBreakAge_WeekendAdjustment() throws Exception {
    scan.setWhere("subjectIdentifier.reconciliationRuleIdentifier = 'MasPositionFx'");
    int breakAge = dfUtility.getBreakAge("2022-09-16T00:00:00.000Z", scan); // Friday
    assertEquals(0, breakAge); // Adjusted to Monday, then counted
}

@Test
public void testGetBreakAge_NegativeDays() throws Exception {
    scan.setWhere("subjectIdentifier.reconciliationRuleIdentifier = 'MasPositionFx'");
    int breakAge = dfUtility.getBreakAge("2025-01-01T00:00:00.000Z", scan); // Future date
    assertEquals(0, breakAge);
}

@Test
public void testConvertScannedRecords_ReconciliationSplit() throws Exception {
    List<String> jsonRecords = Lists.newArrayList(
        "{\"subjectIdentifier\":{\"sourceSystemMatchingKeyIdentifier\":\"ID1|ID2|ID3\",\"reconciliationRuleIdentifier\":\"TestRecon\"}," +
        "\"sourceRecords\":[{\"field\":\"value\"}],\"targetRecords\":[{\"field\":\"value\"}]}"
    );
    List<Map<String, String>> records = dfUtility.convertScannedRecords(
        getMockRecords(jsonRecords), "Reconciliation", scan
    );
    assertEquals(2, records.size()); // Source + Target records
}

@Test
public void testConvertScannedRecords_NullDocument() throws Exception {
    Record record = new Record();
    record.setDocument(null);
    List<Map<String, String>> result = dfUtility.convertScannedRecords(
        Collections.singletonList(record), "Transaction", scan
    );
    assertTrue(result.isEmpty());
}

@Test
public void testPopulateAllHeaders_WithSelect() {
    DfScanParameters param = createDfScanParameters("Transaction", "Source System", "");
    param.setFieldConversion(true);
    List<DfScanParameters> params = Collections.singletonList(param);
    dfUtility.populateAllHeaders(params);
    assertTrue(dfUtility.getAllHeaders().contains("Source System"));
}

@Test
public void testPopulateAllHeaders_NoSelect() {
    DfScanParameters param = createDfScanParameters("Transaction", "", "");
    param.setFieldConversion(true);
    List<DfScanParameters> params = Collections.singletonList(param);
    dfUtility.populateAllHeaders(params);
    assertFalse(dfUtility.getAllHeaders().isEmpty());
}

private void invokePopulateManualFieldsMethod(Map<String, String> map) throws Exception {
    Method method = DataFabricExportUtility.class.getDeclaredMethod("populateManualFields", Map.class);
    method.setAccessible(true);
    method.invoke(dfUtility, map);
}

private String invokeGetDateDifferenceInStandardFormatMethod(DateTime start, DateTime end) throws Exception {
    Method method = DataFabricExportUtility.class.getDeclaredMethod("getDateDifferenceInStandardFormat", DateTime.class, DateTime.class);
    method.setAccessible(true);
    return (String) method.invoke(dfUtility, start, end);
}

private void invokeRenderMiReportDataMethod(String collectionName, Map<String, String> map) throws Exception {
    Method method = DataFabricExportUtility.class.getDeclaredMethod("renderMiReportData", String.class, Map.class);
    method.setAccessible(true);
    method.invoke(dfUtility, collectionName, map);
}
