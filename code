Could you write all the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

package com.rbs.tntr.business.blotter.services.actions;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.TNTRApplication;
import com.nwm.tntr.commons.domain.persistence.constant.UserActionType;
import com.nwm.tntr.commons.domain.persistence.entity.DocumentId;
import com.nwm.tntr.commons.domain.persistence.entity.ExceptionManagement;
import com.nwm.tntr.commons.domain.persistence.entity.NonReportableData;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReport;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.rbs.tntr.business.blotter.df.manager.DfCollateralPersistManager;
import com.rbs.tntr.business.blotter.df.updater.CollateralDataUpdater;
import com.rbs.tntr.business.blotter.services.validators.ActionRequestValidator;
import com.rbs.tntr.domain.blotter.enums.ExceptionStatus;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import com.rbs.tntr.domain.blotter.exceptions.DfRunTimeException;
import com.rbs.tntr.domain.blotter.tntrBlotterView.ActionDocumentId;

@Service
public class CollateralActionService {
    private final Logger logger = LoggerFactory.getLogger(CollateralActionService.class);
    private static final String UPDATE_ERROR = "Error updating collateral record : ";
    public static final String  COLLATERAL = "Collateral";

    private final DfCollateralPersistManager dfCollateralPersistManager;
    private final CollateralDataUpdater dataUpdater;
    private final ActionRequestValidator requestValidator;

    @Autowired
    public CollateralActionService(DfCollateralPersistManager dfCollateralPersistManager, CollateralDataUpdater dataUpdater, ActionRequestValidator requestValidator) {
        this.dfCollateralPersistManager = dfCollateralPersistManager;
        this.dataUpdater = dataUpdater;
        this.requestValidator = requestValidator;
    }



    public List<ActionUpdateResult> addComment(List<AddTradeCommentRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithComments(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }
    
    public List<ActionUpdateResult> removeComment(List<AddTradeCommentRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithRemovedComments(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithComments(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentRequest addTradeCommentRequest = (AddTradeCommentRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addCommentsToException(addTradeCommentRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithRemovedComments(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentRequest addTradeCommentRequest = (AddTradeCommentRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.removeCommentsToException(addTradeCommentRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }
    
    private CollateralReport getCollateralReport(CollateralReport tradeReport, ExceptionManagement exceptionManagement) {
        return CollateralReport.newBuilder(tradeReport)
                .withExceptionManagement(exceptionManagement)
                .withNonReportableData(NonReportableData.newBuilder(tradeReport.getNonReportableData())
                        .withUpdatedByApplication(TNTRApplication.BLOTTER_SERVICE)
                        .build())
                .build();
    }

    private List<CollateralReportDocument> getTradeReportDocuments(List<DocumentId> documentIds) throws DfRunTimeException {
        return dfCollateralPersistManager.getAllRecordsById(documentIds);
    }

    private Pair<CollateralReport, Long> getReportsWithExpectedBaseVersion(CollateralReportDocument tradeReportDocument, CollateralReport tradeReport) {
        return Pair.of(tradeReport, tradeReportDocument.getDocumentId().getVersion());
    }

    private List<ActionUpdateResult> saveAllRecords(List<CollateralReportDocument> tradeReportDocuments, List<Pair<CollateralReport, Long>> tradeReports) {
        List<WriteResult<CollateralReport>> writeResults =  dfCollateralPersistManager.saveAllRecords(tradeReports);
        List<ActionUpdateResult> result = getResult(tradeReportDocuments, writeResults);
        return result;
    }

	private List<ActionUpdateResult> rollBackRejectedRecords(Map<DocumentId, UpdateRequest> tradeRequestMap) {
		logger.info("Rolling back records to previous version due to rejection");
		List<ActionUpdateResult> writeResults = Lists.newArrayList();
		List<DocumentId> documentIds = Lists.newArrayList();
		tradeRequestMap.keySet().forEach(documentId -> {
			documentIds.add(DocumentId.from(documentId.getKey(), (documentId.getVersion() - 2)));
		});
		List<CollateralReportDocument> collateralReportDocuments = getTradeReportDocuments(documentIds);
		List<CollateralReport> collateralReports = collateralReportDocuments.stream()
				.map(collateralDocument -> collateralDocument.getCollateralReport()).collect(Collectors.toList());
		writeResults = upsertAllRecords(collateralReportDocuments, collateralReports);
		return writeResults;
	}

	private List<ActionUpdateResult> upsertAllRecords(List<CollateralReportDocument> collateralReportDocuments,
			List<CollateralReport> collateralReports) {
		List<WriteResult<CollateralReport>> writeResults = dfCollateralPersistManager
				.upsertAllRecords(collateralReports);
		List<ActionUpdateResult> result = getResult(collateralReportDocuments, writeResults);
		return result;
	}

    private List<ActionUpdateResult> getResult(List<CollateralReportDocument> tradeReportDocuments, List<WriteResult<CollateralReport>> writeResults) {
        List<ActionUpdateResult> results = Lists.newArrayList();
        if(writeResults != null) {
            for (int i = 0; i < writeResults.size(); i++) {
                if (writeResults.get(i).isSuccess()) {
                    results.add(ActionUpdateResult.createSuccess(getTradePrimaryKey(tradeReportDocuments.get(i).getDocumentId()), writeResults.get(i).getDocumentId().getKey(), writeResults.get(i).getDocumentId().getVersion()));
                } else {
                    String error = writeResults.get(i).getErrorDetail().getCause() != null
                            ? writeResults.get(i).getErrorDetail().getDescription() + ". " + writeResults.get(i).getErrorDetail().getCause().getMessage()
                            : writeResults.get(i).getErrorDetail().getDescription();
                    logger.error("Error occured in persisting Collateral key : [{}], version : [{}] Reason : [{}]", tradeReportDocuments.get(i).getDocumentId().getKey(), tradeReportDocuments.get(i).getDocumentId().getVersion(), error);
                    results.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocuments.get(i).getDocumentId()), error));
                }
            }
        }

        return results;
    }

    protected void populateTradeRequestMap(UpdateRequest updateRequest, Map<DocumentId, UpdateRequest> map) {
        ActionDocumentId docId = updateRequest.getDocumentId();
        DocumentId documentId = DocumentId.from(docId.getKey(), docId.getVersion());

        map.put(documentId, updateRequest);
    }

    private ActionDocumentId getTradePrimaryKey(DocumentId documentId) {
        return new ActionDocumentId(documentId.getKey(), documentId.getVersion());
    }

	public List<ActionUpdateResult> updateEditedFields(List<EditRequest> requests, String userName,
			ExceptionStatus exceptionStatus) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
				List<Pair<CollateralReport, Long>> tradeReports = editFields(tradeReportDocuments, tradeRequestMap,
						writeResults, userName, exceptionStatus);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

	protected List<Pair<CollateralReport, Long>> editFields(List<CollateralReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName,
			ExceptionStatus exceptionStatus) {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    try {
                        EditRequest editRequest = (EditRequest) requests.get(tradeReportDocument.getDocumentId());

						CollateralReport tradeRepo = dataUpdater.updateTradeReportData(editRequest, tradeReport,
								userName, exceptionStatus);
                        reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                    } catch (BlotterRunTimeException e) {
                        failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), e.getMessage()));
                        logger.error("Collateral edit failed for key : [{}], version : [{}], reason : [{}]",tradeReportDocument.getDocumentId().getKey(), tradeReportDocument.getDocumentId().getVersion(), e.getMessage(), e);
                    }
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while editing collateral. ", e);
            throw new BlotterRunTimeException("Error occured while editing collateral. "+e.getMessage(), e);
        }
    }

    public List<ActionUpdateResult> updateExceptionStatus(List<UpdateExceptionStatusRequest> requests, ExceptionStatus requestedExceptionStatus, String userName) {
        if(requests.isEmpty() || requestValidator.validateExceptionStatus(requestedExceptionStatus)){
            if(!requests.isEmpty()){
                logger.warn("Validation Failed : [{}] action not applicable on Collateral Records.", requestedExceptionStatus);
            }
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            

            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validatePermittedExceptionStatusForCol(tradeReportDocuments, writeResults, requestedExceptionStatus);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithExceptionStatus(tradeReportDocuments, requestedExceptionStatus, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

			if (ExceptionStatus.Edit_Rejected.equals(requestedExceptionStatus)) {
				writeResults = rollBackRejectedRecords(tradeRequestMap);
			}

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return getTradeUpdateResultOnError(requests, e.getMessage());
        }
    }
    
    public List<ActionUpdateResult> performResetAction(List<UpdateExceptionStatusRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();

            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = resetActionOnCollateral(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return getTradeUpdateResultOnError(requests, e.getMessage());
        }
    }

    private List<ActionUpdateResult> getTradeUpdateResultOnError(List<UpdateExceptionStatusRequest> requests, String errormessage) {
        return requests
                .stream()
                .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + errormessage))
                .collect(Collectors.toList());
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithExceptionStatus(List<CollateralReportDocument> tradeReportDocuments, ExceptionStatus requestedExceptionStatus, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if (!requestValidator.validateExceptionStatus(requestedExceptionStatus, tradeReport.getExceptionManagement().getApprovalStatus())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if (requestValidator.validateApprover(requestedExceptionStatus, tradeReport.getCollateralReportId().getCollateralPortfolioGroup(), COLLATERAL,userName)) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    UpdateExceptionStatusRequest updateExceptionStatusRequest = (UpdateExceptionStatusRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.addExceptionStatus(requestedExceptionStatus, updateExceptionStatusRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating exception status in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating exception status in ExceptionManagement. ", e);
        }
    }
    
	protected List<Pair<CollateralReport, Long>> resetActionOnCollateral(
			List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests,
			List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
		try {
			List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
			for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
				CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
				 if (!requestValidator.validateResetActionApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus(),
	                        requests.get(tradeReportDocument.getDocumentId()).getFlow())) {
					logger.warn("Reset Action is not allowed because Current Approval Status of trade is : {}",
							tradeReport.getExceptionManagement().getApprovalStatus());
					failedTrades.add(
							ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()),
									ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
					logFailuerReason(tradeReportDocument.getDocumentId(),
							ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
				} else {
					UpdateExceptionStatusRequest updateExceptionStatusRequest = (UpdateExceptionStatusRequest) requests
							.get(tradeReportDocument.getDocumentId());
					ExceptionManagement exceptionManagement = dataUpdater.resetAction(updateExceptionStatusRequest,
							tradeReport.getExceptionManagement(), userName);

					CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
					reportsWithExpectedBaseVersions
							.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
				}
			}
			return reportsWithExpectedBaseVersions;
		} catch (Exception e) {
			logger.error("Error occured while updating exception status in ExceptionManagement. ", e);
			throw new BlotterRunTimeException("Error occured while updating exception status in ExceptionManagement. ",
					e);
		}
	}

    public List<ActionUpdateResult> assignExceptionToUser(List<AssignTradeRequest> requests, String userName) {
        try {
            if(requests.isEmpty()){
                return Lists.newArrayList();
            }
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithAssignment(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithAssignment(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AssignTradeRequest assignTradeRequest = (AssignTradeRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.assignException(assignTradeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating assign user in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating assign user in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> addJiraId(List<AddTradeJiraReferenceRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithJiraReference(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithJiraReference(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                AddTradeJiraReferenceRequest addTradeJiraReferenceRequest = (AddTradeJiraReferenceRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(requestValidator.isJiraIdPresent(tradeReport.getExceptionManagement().getIssueIds(), addTradeJiraReferenceRequest.getJiraReference().getJiraId())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_ID_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_ID_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.addJiraIdToException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while adding jira id in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while adding jira id in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeJiraId(List<AddTradeJiraReferenceRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = removeJiraReference(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> removeJiraReference(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                AddTradeJiraReferenceRequest addTradeJiraReferenceRequest = (AddTradeJiraReferenceRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(!requestValidator.isJiraIdPresent(tradeReport.getExceptionManagement().getIssueIds(), addTradeJiraReferenceRequest.getJiraReference().getJiraId())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_ID_NOT_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_ID_NOT_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.removeJiraIdFromException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while removing jira id from ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while removing jira id from ExceptionManagement. ", e);
        }
    }


    public List<ActionUpdateResult> addJiraType(List<AddTradeJiraTypeRequest> requests, String userName) {
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithJiraType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithJiraType(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeJiraTypeRequest addTradeJiraTypeRequest = (AddTradeJiraTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addJiraTypeToException(addTradeJiraTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while adding jira type in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while adding jira type in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeJiraType(List<AddTradeJiraTypeRequest> requests, String userName) {
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = removeJiraType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> removeJiraType(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                AddTradeJiraTypeRequest addTradeJiraReferenceRequest = (AddTradeJiraTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(!tradeReport.getExceptionManagement().getIssueType().value().equals(addTradeJiraReferenceRequest.getJiraType().getIssueType())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_TYPE_NOT_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_TYPE_NOT_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.removeJiraTypeFromException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while removing jira type from ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while removing jira type from ExceptionManagement. ", e);
        }
    }

    private void logFailuerReason(DocumentId documentId, String reason){
        logger.warn("Collateral validation failed for key : [{}], version : [{}] Reason : [{}]", documentId.getKey(), documentId.getVersion(), reason);
    }
    
	public List<ActionUpdateResult> updateUserActionType(List<UpdateUserActionTypeRequest> requests, String userName) {
		if (requests.isEmpty()) {
			return Lists.newArrayList();
		}
		try {
			List<ActionUpdateResult> writeResults = Lists.newArrayList();

			Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
			requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
			List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(
					Lists.newArrayList(tradeRequestMap.keySet()));

			if (!tradeReportDocuments.isEmpty()) {
				List<Pair<CollateralReport, Long>> tradeReports = getUserActionTypeTrades(tradeReportDocuments,
						tradeRequestMap, writeResults, userName);
				if (!tradeReports.isEmpty()) {
					writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
				}
			}

			return writeResults;
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			return requests.stream().map(request -> ActionUpdateResult.createWithError(request.getDocumentId(),
					UPDATE_ERROR + e.getMessage())).collect(Collectors.toList());
		}
	}

	protected List<Pair<CollateralReport, Long>> getUserActionTypeTrades(List<CollateralReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName)
			throws BlotterRunTimeException {
		try {
			List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

			for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
				CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
				UpdateUserActionTypeRequest updateUserActionTypeRequest = (UpdateUserActionTypeRequest) requests
						.get(tradeReportDocument.getDocumentId());
				ExceptionManagement exceptionManagement = dataUpdater.addComments(tradeReport.getExceptionManagement(),
						userName, updateUserActionTypeRequest.getComment().getComment(),
						updateUserActionTypeRequest.getAction());
				CollateralReport tradeRepo = getTradeReportWithUserActionType(tradeReport, exceptionManagement,
						UserActionType.fromValue(updateUserActionTypeRequest.getUserActionType()));
				reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
			}
			return reportsWithExpectedBaseVersions;
		} catch (Exception e) {
			logger.error("Error occured while updating comments in ExceptionManagement. ", e);
			throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
		}
	}

	private CollateralReport getTradeReportWithUserActionType(CollateralReport tradeReport,
			ExceptionManagement exceptionManagement, UserActionType userActionType) {
		return CollateralReport.newBuilder(tradeReport).withExceptionManagement(exceptionManagement)
				.withNonReportableData(NonReportableData.newBuilder(tradeReport.getNonReportableData())
						.withUserActionType(userActionType).withUpdatedByApplication(TNTRApplication.BLOTTER_SERVICE)
						.build())
				.build();
	}

    public List<ActionUpdateResult> addCommentType(List<AddTradeCommentTypeRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithCommentTypd(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    public List<ActionUpdateResult> removeCommentType(List<AddTradeCommentTypeRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try{
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<CollateralReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<CollateralReport, Long>> tradeReports = getTradeWithRemovedCommentType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }
            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithCommentTypd(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentTypeRequest addTradeCommentTypeRequest = (AddTradeCommentTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addCommentTypeToException(addTradeCommentTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    protected List<Pair<CollateralReport, Long>> getTradeWithRemovedCommentType(List<CollateralReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<CollateralReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (CollateralReportDocument tradeReportDocument : tradeReportDocuments) {
                CollateralReport tradeReport = tradeReportDocument.getCollateralReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentTypeRequest addTradeCommentTypeRequest = (AddTradeCommentTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.removeCommentTypeToException(addTradeCommentTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    CollateralReport collateralRepo = getCollateralReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, collateralRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }
}


Existing test class:

package com.rbs.tntr.business.blotter.services.actions;

import com.nwm.tntr.commons.domain.persistence.entity.ExceptionManagement;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReport;
import com.nwm.tntr.commons.domain.persistence.entity.collateral.CollateralReportDocument;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.rbs.tntr.business.blotter.df.manager.DfCollateralPersistManager;
import com.rbs.tntr.business.blotter.df.updater.CollateralDataUpdater;
import com.rbs.tntr.business.blotter.df.updater.ExceptionManagmentUpdater;
import com.rbs.tntr.business.blotter.services.validators.ActionRequestValidator;
import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import com.rbs.tntr.domain.blotter.enums.ExceptionStatus;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.verification.VerificationMode;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.*;

public class CollateralActionServiceTest {

    @InjectMocks
    private CollateralActionService collateralActionService;

    @Mock
    private DfCollateralPersistManager dfCollateralPersistManager;

    @Mock
    private CollateralDataUpdater dataUpdater;

    @Mock
    private ActionRequestValidator requestValidator;

    @Mock
    private CollateralReportDocument collateralReportDocument;

    @Mock
    private CollateralReport collateralReport;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testAddComment_EmptyRequests() {
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralActionService.addComment(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAssignExceptionToUser_EmptyRequests() {
        List<AssignTradeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralActionService.assignExceptionToUser(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddJiraId_EmptyRequests() {
        List<AddTradeJiraReferenceRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralActionService.addJiraId(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddComment_ValidRequest() throws Exception {
        // Given
        String userName = "username";
        AddTradeCommentRequest request = new AddTradeCommentRequest();
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(requestValidator.validateUser(eq(userName), any())).thenReturn(true);
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        when(collateralReportDocument.getCollateralReport()).thenReturn(collateralReport);
        WriteResult<CollateralReport> writeResult = mock(WriteResult.class);
        when(writeResult.isSuccess()).thenReturn(true);
        when(dfCollateralPersistManager.saveAllRecords(any())).thenReturn(Arrays.asList(writeResult));

        // When
        List<ActionUpdateResult> results = collateralActionService.addComment(requests, userName);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

    private ExceptionManagmentUpdater verify(CollateralDataUpdater dataUpdater, VerificationMode times) {
        return null;
    }

    @Test
    public void testRemoveComment_ValidRequest() throws Exception {
        // Given
        String userName = "username";
        AddTradeCommentRequest request = new AddTradeCommentRequest();
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(requestValidator.validateUser(eq(userName), any())).thenReturn(true);
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        when(collateralReportDocument.getCollateralReport()).thenReturn(collateralReport);
        WriteResult<CollateralReport> writeResult = mock(WriteResult.class);
        when(writeResult.isSuccess()).thenReturn(true);
        when(dfCollateralPersistManager.saveAllRecords(any())).thenReturn(Arrays.asList(writeResult));

        // When
        List<ActionUpdateResult> results = collateralActionService.removeComment(requests, userName);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

    @Test
    public void testAddComment_UserValidationFails() {
        // Given
        String userName = "username";
        AddTradeCommentRequest request = new AddTradeCommentRequest();
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(requestValidator.validateUser(eq(userName), any())).thenReturn(false);

        // When
        List<ActionUpdateResult> results = collateralActionService.addComment(requests, userName);

        // Then
        assertNotNull(results);
        assertEquals(1, results.size());
    }

    @Test
    public void testUpdateEditedFields_ValidRequests() throws Exception {
        // Given
        String userName = "username";
        EditRequest editRequest = new EditRequest();
        List<EditRequest> requests = new ArrayList<>();
        requests.add(editRequest);

        // Set up mocks
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        when(requestValidator.validateApprovalStatus(any())).thenReturn(true);
        when(collateralReportDocument.getCollateralReport()).thenReturn(collateralReport);
        WriteResult<CollateralReport> writeResult = mock(WriteResult.class);
        when(writeResult.isSuccess()).thenReturn(true);
        when(dfCollateralPersistManager.saveAllRecords(any())).thenReturn(Arrays.asList(writeResult));

        // When
        List<ActionUpdateResult> results = collateralActionService.updateEditedFields(requests, userName, null);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

    @Test
    public void testUpdateExceptionStatus_ValidRequests() throws Exception {
        // Given
        String userName = "username";
        UpdateExceptionStatusRequest request = new UpdateExceptionStatusRequest();
        List<UpdateExceptionStatusRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        WriteResult<CollateralReport> writeResult = mock(WriteResult.class);
        when(writeResult.isSuccess()).thenReturn(true);
        when(dfCollateralPersistManager.saveAllRecords(any())).thenReturn(Arrays.asList(writeResult));

        // When
        ExceptionStatus status = null;
        List<ActionUpdateResult> results = collateralActionService.updateExceptionStatus(requests, status, userName);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

    @Test
    public void testAddJiraId_ValidRequest() throws Exception {
        // Given
        String userName = "username";
        AddTradeJiraReferenceRequest request = new AddTradeJiraReferenceRequest();
        List<AddTradeJiraReferenceRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        when(collateralReportDocument.getCollateralReport()).thenReturn(collateralReport);
        when(dataUpdater.addJiraIdToException(any(), any(), any())).thenReturn(mock(ExceptionManagement.class));

        // When
        List<ActionUpdateResult> results = collateralActionService.addJiraId(requests, userName);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

    @Test
    public void testAddCommentType_UserValidationFails() {
        // Given
        String userName = "username";
        AddTradeCommentTypeRequest request = new AddTradeCommentTypeRequest();
        List<AddTradeCommentTypeRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(requestValidator.validateUser(eq(userName), any())).thenReturn(false);

        // When
        List<ActionUpdateResult> results = collateralActionService.addCommentType(requests, userName);

        // Then
        assertNotNull(results);
        assertEquals(1, results.size());
    }

    @Test
    public void testRemoveCommentType_UserValidationFails() {
        // Given
        String userName = "username";
        AddTradeCommentTypeRequest request = new AddTradeCommentTypeRequest();
        List<AddTradeCommentTypeRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(requestValidator.validateUser(eq(userName), any())).thenReturn(false);

        // When
        List<ActionUpdateResult> results = collateralActionService.removeCommentType(requests, userName);

        // Then
        assertNotNull(results);
        assertEquals(1, results.size());
    }

    @Test
    public void testRemoveJiraId_ValidRequest() throws Exception {
        // Given
        String userName = "username";
        AddTradeJiraReferenceRequest request = new AddTradeJiraReferenceRequest();
        List<AddTradeJiraReferenceRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        when(collateralReportDocument.getCollateralReport()).thenReturn(collateralReport);
        when(dataUpdater.removeJiraIdFromException(any(), any(), any())).thenReturn(mock(ExceptionManagement.class));

        // When
        List<ActionUpdateResult> results = collateralActionService.removeJiraId(requests, userName);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

    @Test
    public void testAssignExceptionToUser_UserValidationFails() {
        // Given
        String userName = "username";
        AssignTradeRequest request = new AssignTradeRequest();
        List<AssignTradeRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(requestValidator.validateUser(eq(userName), any())).thenReturn(false);

        // When
        List<ActionUpdateResult> results = collateralActionService.assignExceptionToUser(requests, userName);

        // Then
        assertNotNull(results);
        assertEquals(1, results.size());
    }

    @Test
    public void testPerformResetAction_EmptyRequests() {
        List<UpdateExceptionStatusRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = collateralActionService.performResetAction(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testUpdateUserActionType_ValidRequest() {
        // Given
        String userName = "username";
        UpdateUserActionTypeRequest request = new UpdateUserActionTypeRequest();
        List<UpdateUserActionTypeRequest> requests = new ArrayList<>();
        requests.add(request);

        // Set up mocks
        when(dfCollateralPersistManager.getAllRecordsById(any())).thenReturn(Arrays.asList(collateralReportDocument));
        when(collateralReportDocument.getCollateralReport()).thenReturn(collateralReport);

        WriteResult<CollateralReport> writeResult = mock(WriteResult.class);
        when(writeResult.isSuccess()).thenReturn(true);
        when(dfCollateralPersistManager.saveAllRecords(any())).thenReturn(Arrays.asList(writeResult));

        // When
        List<ActionUpdateResult> results = collateralActionService.updateUserActionType(requests, userName);

        // Then
        assertNotNull(results);
        assertFalse(results.isEmpty());
    }

}
