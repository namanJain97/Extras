package com.rbs.tntr.business.taggingService.service.trigger;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.google.common.collect.Lists;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.GetException;
import com.rbs.datafabric.api.exception.OptimisticLockException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.api.exception.UpsertException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.common.DataFabricSerializerException;
import com.rbs.datafabric.domain.*;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.enums.FlowType;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.io.IOException;
import java.time.LocalDate;
import java.util.*;

import static org.junit.Assert.*;

public class TaggingServiceBatchTriggerDfRepositoryTest {
    private DataFabricClient dfClient;
    private DfConnectionManager dfConnectionManager;
    private TaggingServiceBatchTriggerDfRepository repository;
    private static final String COLLECTION_NAME = "TNTR-trade-local";
    private static final String DB = "Tntr";

    @Before
    public void setUp() {
        dfClient = Mockito.mock(DataFabricClient.class);
        dfConnectionManager = Mockito.mock(DfConnectionManager.class);
        Mockito.when(dfConnectionManager.getDfClient()).thenReturn(dfClient);
        repository = Mockito.spy(new TaggingServiceBatchTriggerDfRepository(dfConnectionManager));
        repository.setDatabaseName(DB);
        repository.setCollectionName(COLLECTION_NAME);
    }

    @Test
    public void testConstructor_SerializerInitialized() {
        // Verify serializer is initialized with JSON format
        TaggingServiceBatchTriggerDfRepository newRepository = new TaggingServiceBatchTriggerDfRepository(dfConnectionManager);
        assertNotNull(newRepository);
        // Since serializer is private, we verify indirectly via saveEntity behavior
    }

    @Test
    public void testEnsureDatafabricClientInitialized() throws StartableException {
        repository.ensureDatafabricClientInitialized();
        Mockito.verify(dfConnectionManager).getDfClient();
    }

    @Test
    public void testSaveEntity_ValuationFlow() throws UpsertException, OptimisticLockException, StartableException, DataFabricSerializerException {
        RecordId mockRecord = new RecordId();
        mockRecord.setKey("10001");
        Mockito.doReturn(mockRecord).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.saveEntity(getJiraAssignmentTriggerEvent());
        assertEquals("10001", recordId.getKey());
        Mockito.verify(repository).upsertRecordToDf(Mockito.any());
    }

    @Test
    public void testSaveEntity_ReconciliationFlow() throws UpsertException, OptimisticLockException, StartableException, DataFabricSerializerException {
        RecordId mockRecord = new RecordId();
        mockRecord.setKey("10001");
        Mockito.doReturn(mockRecord).when(repository).upsertRecordToDf(Mockito.any());
        JiraAssignmentTriggerEvent event = getJiraAssignmentTriggerEvent();
        event.setFlow("Reconciliation");
        RecordId recordId = repository.saveEntity(event);
        assertEquals("10001", recordId.getKey());
        Mockito.verify(repository).upsertRecordToDf(Mockito.any());
    }

    @Test
    public void testSaveEntity_JsonProcessingException() throws UpsertException, OptimisticLockException, StartableException, DataFabricSerializerException {
        JiraAssignmentTriggerEvent event = getJiraAssignmentTriggerEvent();
        Mockito.doThrow(new JsonProcessingException("Serialization error") {}).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.saveEntity(event);
        assertNull(recordId);
    }

    @Test
    public void testReadEntityForKey_Success() throws GetException, StartableException {
        String key = "Reconciliation_g2_Jira Assignment_TNTR-5678_CFTC_Rates_NAK_FAILED_2";
        Record mockRecord = getMockRecords();
        Mockito.when(dfClient.get(Mockito.any())).thenReturn(mockRecord);
        JiraAssignmentTriggerEvent result = repository.readEntityForKey(key);
        assertEquals("Reconciliation_g2_Jira Assignment_TNTR-5678_CFTC_Rates_NAK_FAILED_2", result.getPrimaryKey());
        assertEquals("Reconciliation", result.getFlow());
    }

    @Test
    public void testReadEntityForKey_GetException() throws StartableException, GetException {
        String key = "someKey";
        Mockito.when(dfClient.get(Mockito.any())).thenThrow(new GetException("Error"));
        JiraAssignmentTriggerEvent result = repository.readEntityForKey(key);
        assertNull(result);
    }

    @Test
    public void testReadEntityForKey_JsonProcessingException() throws GetException, StartableException, IOException {
        String key = "someKey";
        Record mockRecord = getMockRecords();
        Mockito.when(dfClient.get(Mockito.any())).thenReturn(mockRecord);
        // Simulate JsonProcessingException in readTree
        Mockito.doThrow(new JsonProcessingException("Parse error") {}).when(repository).objectMapper.readTree(Mockito.anyString());
        JiraAssignmentTriggerEvent result = repository.readEntityForKey(key);
        assertNull(result);
    }

    @Test
    public void testReadEntityForKey_IOException() throws GetException, StartableException, IOException {
        String key = "someKey";
        Record mockRecord = getMockRecords();
        Mockito.when(dfClient.get(Mockito.any())).thenReturn(mockRecord);
        // Simulate IOException in readTree
        Mockito.doThrow(new IOException("IO error") {}).when(repository).objectMapper.readTree(Mockito.anyString());
        JiraAssignmentTriggerEvent result = repository.readEntityForKey(key);
        assertNull(result);
    }

    @Test
    public void testReadEntityForKey_NullDocument() throws GetException, StartableException {
        String key = "someKey";
        Record mockRecord = new Record();
        RecordId recordId = new RecordId();
        recordId.setDatabaseName(DB);
        recordId.setCollectionName(COLLECTION_NAME);
        mockRecord.setId(recordId);
        mockRecord.setDocument(null);
        Mockito.when(dfClient.get(Mockito.any())).thenReturn(mockRecord);
        JiraAssignmentTriggerEvent result = repository.readEntityForKey(key);
        assertNull(result);
    }

    @Test
    public void testReadAllEntity_Success() throws ScanException, StartableException {
        String where = "primaryKey = 'Reconciliation_g2_Jira Assignment_TNTR-5678_CFTC_Rates_NAK_FAILED_2'";
        List<Record> mockRecords = Lists.newArrayList(getMockRecords());
        Mockito.when(dfClient.scan(Mockito.any())).thenReturn(getMockScanResult(mockRecords));
        List<JiraAssignmentTriggerEvent> results = repository.readAllEntity(where);
        assertEquals(1, results.size());
        assertEquals("Reconciliation_g2_Jira Assignment_TNTR-5678_CFTC_Rates_NAK_FAILED_2", results.get(0).getPrimaryKey());
        assertEquals("Reconciliation", results.get(0).getFlow());
    }

    @Test
    public void testReadAllEntity_ScanException() throws ScanException, StartableException {
        String where = "someWhereClause";
        Mockito.when(dfClient.scan(Mockito.any())).thenThrow(new ScanException("Error"));
        List<JiraAssignmentTriggerEvent> results = repository.readAllEntity(where);
        assertTrue(results.isEmpty());
    }

    @Test
    public void testReadAllEntity_JsonProcessingException() throws ScanException, StartableException, IOException {
        String where = "someWhereClause";
        List<Record> mockRecords = Lists.newArrayList(getMockRecords());
        Mockito.when(dfClient.scan(Mockito.any())).thenReturn(getMockScanResult(mockRecords));
        Mockito.doThrow(new JsonProcessingException("Parse error") {}).when(repository).objectMapper.readTree(Mockito.anyString());
        List<JiraAssignmentTriggerEvent> results = repository.readAllEntity(where);
        assertTrue(results.isEmpty());
    }

    @Test
    public void testReadAllEntity_IOException() throws ScanException, StartableException, IOException {
        String where = "someWhereClause";
        List<Record> mockRecords = Lists.newArrayList(getMockRecords());
        Mockito.when(dfClient.scan(Mockito.any())).thenReturn(getMockScanResult(mockRecords));
        Mockito.doThrow(new IOException("IO error") {}).when(repository).objectMapper.readTree(Mockito.anyString());
        List<JiraAssignmentTriggerEvent> results = repository.readAllEntity(where);
        assertTrue(results.isEmpty());
    }

    @Test
    public void testReadAllEntity_NullDocument() throws ScanException, StartableException {
        String where = "someWhereClause";
        Record mockRecord = new Record();
        RecordId recordId = new RecordId();
        recordId.setDatabaseName(DB);
        recordId.setCollectionName(COLLECTION_NAME);
        mockRecord.setId(recordId);
        mockRecord.setDocument(null);
        List<Record> mockRecords = Lists.newArrayList(mockRecord);
        Mockito.when(dfClient.scan(Mockito.any())).thenReturn(getMockScanResult(mockRecords));
        List<JiraAssignmentTriggerEvent> results = repository.readAllEntity(where);
        assertTrue(results.isEmpty());
    }

    @Test
    public void testReadAllEntity_BlankWhereClause() throws ScanException, StartableException {
        String where = "";
        List<Record> mockRecords = Lists.newArrayList(getMockRecords());
        Mockito.when(dfClient.scan(Mockito.any())).thenReturn(getMockScanResult(mockRecords));
        List<JiraAssignmentTriggerEvent> results = repository.readAllEntity(where);
        assertEquals(1, results.size());
        assertEquals("Reconciliation_g2_Jira Assignment_TNTR-5678_CFTC_Rates_NAK_FAILED_2", results.get(0).getPrimaryKey());
    }

    @Test
    public void testUpdateEntity_ValuationFlow() throws StartableException, UpsertException, OptimisticLockException, DataFabricSerializerException {
        String pKey = "10001";
        String lastSuccessDate = "2020-02-01";
        int recordsModified = 100;
        String status = "COMPLETED";
        String comment = "Test update";
        String ruleEngineDateTime = "2020-02-01T10:00:00.000Z";
        Date nextDateTime = new Date();
        JiraAssignmentTriggerEvent mockEvent = getJiraAssignmentTriggerEvent();
        Mockito.doReturn(mockEvent).when(repository).readEntityForKey(pKey);
        RecordId mockRecord = new RecordId();
        mockRecord.setKey(pKey);
        Mockito.doReturn(mockRecord).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.updateEntity(pKey, lastSuccessDate, recordsModified, status, comment, ruleEngineDateTime, nextDateTime);
        assertEquals(pKey, recordId.getKey());
        Mockito.verify(repository).readEntityForKey(pKey);
        Mockito.verify(repository).upsertRecordToDf(Mockito.any());
    }

    @Test
    public void testUpdateEntity_ReconciliationFlow() throws StartableException, UpsertException, OptimisticLockException, DataFabricSerializerException {
        String pKey = "10001";
        String lastSuccessDate = "2020-02-01";
        int recordsModified = 100;
        String status = "COMPLETED";
        String comment = "Test update";
        String ruleEngineDateTime = "2020-02-01T10:00:00.000Z";
        Date nextDateTime = new Date();
        JiraAssignmentTriggerEvent mockEvent = getJiraAssignmentTriggerEvent();
        mockEvent.setFlow("Reconciliation");
        Mockito.doReturn(mockEvent).when(repository).readEntityForKey(pKey);
        RecordId mockRecord = new RecordId();
        mockRecord.setKey(pKey);
        Mockito.doReturn(mockRecord).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.updateEntity(pKey, lastSuccessDate, recordsModified, status, comment, ruleEngineDateTime, nextDateTime);
        assertEquals(pKey, recordId.getKey());
        Mockito.verify(repository).readEntityForKey(pKey);
        Mockito.verify(repository).upsertRecordToDf(Mockito.any());
    }

    @Test
    public void testUpdateEntity_NullEntity() throws StartableException, UpsertException, OptimisticLockException, DataFabricSerializerException {
        String pKey = "10001";
        String lastSuccessDate = "2020-02-01";
        int recordsModified = 100;
        String status = "COMPLETED";
        String comment = "Test update";
        String ruleEngineDateTime = "2020-02-01T10:00:00.000Z";
        Date nextDateTime = new Date();
        Mockito.doReturn(null).when(repository).readEntityForKey(pKey);
        RecordId recordId = repository.updateEntity(pKey, lastSuccessDate, recordsModified, status, comment, ruleEngineDateTime, nextDateTime);
        assertNull(recordId);
    }

    @Test
    public void testUpdateEntity_JsonProcessingException() throws StartableException, UpsertException, OptimisticLockException, DataFabricSerializerException {
        String pKey = "10001";
        String lastSuccessDate = "2020-02-01";
        int recordsModified = 100;
        String status = "COMPLETED";
        String comment = "Test update";
        String ruleEngineDateTime = "2020-02-01T10:00:00.000Z";
        Date nextDateTime = new Date();
        JiraAssignmentTriggerEvent mockEvent = getJiraAssignmentTriggerEvent();
        Mockito.doReturn(mockEvent).when(repository).readEntityForKey(pKey);
        Mockito.doThrow(new JsonProcessingException("Serialization error") {}).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.updateEntity(pKey, lastSuccessDate, recordsModified, status, comment, ruleEngineDateTime, nextDateTime);
        assertNull(recordId);
    }

    @Test
    public void testGetBatchTriggerEvent_AllNullInputs() throws StartableException, UpsertException, OptimisticLockException, DataFabricSerializerException {
        String pKey = "10001";
        String lastSuccessDate = null;
        int recordsModified = -1; // Invalid to skip update
        String status = null;
        String comment = null;
        String ruleEngineDateTime = null;
        Date nextDateTime = null;
        JiraAssignmentTriggerEvent mockEvent = getJiraAssignmentTriggerEvent();
        Mockito.doReturn(mockEvent).when(repository).readEntityForKey(pKey);
        RecordId mockRecord = new RecordId();
        mockRecord.setKey(pKey);
        Mockito.doReturn(mockRecord).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.updateEntity(pKey, lastSuccessDate, recordsModified, status, comment, ruleEngineDateTime, nextDateTime);
        assertEquals(pKey, recordId.getKey());
        // Verify no fields were updated in mockEvent (indirectly via behavior)
        assertEquals("Valuation", mockEvent.getFlow()); // Unchanged
    }

    @Test
    public void testGetBatchTriggerEvent_BlankInputs() throws StartableException, UpsertException, OptimisticLockException, DataFabricSerializerException {
        String pKey = "10001";
        String lastSuccessDate = "";
        int recordsModified = -1; // Invalid to skip update
        String status = "";
        String comment = "";
        String ruleEngineDateTime = "";
        Date nextDateTime = null;
        JiraAssignmentTriggerEvent mockEvent = getJiraAssignmentTriggerEvent();
        Mockito.doReturn(mockEvent).when(repository).readEntityForKey(pKey);
        RecordId mockRecord = new RecordId();
        mockRecord.setKey(pKey);
        Mockito.doReturn(mockRecord).when(repository).upsertRecordToDf(Mockito.any());
        RecordId recordId = repository.updateEntity(pKey, lastSuccessDate, recordsModified, status, comment, ruleEngineDateTime, nextDateTime);
        assertEquals(pKey, recordId.getKey());
        // Verify no fields were updated in mockEvent (indirectly via behavior)
        assertEquals("Valuation", mockEvent.getFlow()); // Unchanged
    }

    @Test
    public void testDeleteAllRecords_Success() {
        long expectedDeletedCount = 10L;
        Mockito.doReturn(expectedDeletedCount).when(repository).deleteAllDataFromCollection(Mockito.anyString());
        long actualDeletedCount = repository.deleteAllRecords();
        assertEquals(expectedDeletedCount, actualDeletedCount);
        Mockito.verify(repository).deleteAllDataFromCollection("isActive = true or isActive = false");
    }

    @Test
    public void testDeleteAllRecords_Exception() {
        Mockito.doThrow(new RuntimeException("Error")).when(repository).deleteAllDataFromCollection(Mockito.anyString());
        long deletedCount = repository.deleteAllRecords();
        assertEquals(0, deletedCount);
    }

    @Test
    public void testGetPageLimit() {
        Integer pageLimit = repository.getPageLimit();
        assertNull(pageLimit);
        Mockito.verifyNoMoreInteractions(dfClient);
    }

    @Test
    public void testGetBatchSize() {
        Integer batchSize = repository.getBatchSize();
        assertNull(batchSize);
        Mockito.verifyNoMoreInteractions(dfClient);
    }

    @Test
    public void testGetFilerPath() {
        String testPath = "test/path";
        String result = repository.getFilerPath(testPath);
        assertNull(result);
        Mockito.verifyNoMoreInteractions(dfClient);
    }

    @Test
    public void testGetInvalidFilerPath() {
        String testPath = "test/path";
        String result = repository.getInvalidFilerPath(testPath);
        assertNull(result);
        Mockito.verifyNoMoreInteractions(dfClient);
    }

    @Test
    public void testGetDateString() {
        LocalDate testDate = LocalDate.of(2020, 5, 15);
        String dateString = TaggingServiceBatchTriggerDfRepository.getDateString(testDate);
        assertEquals("15-05-2020", dateString);
        Mockito.verifyNoMoreInteractions(dfClient);
    }

    private JiraAssignmentTriggerEvent getJiraAssignmentTriggerEvent() {
        return new JiraAssignmentTriggerEvent.Builder()
                .withId("1")
                .withPrimaryKey("10001")
                .withExpression("subjectIdentifier.reportTriggerType = 'Collateral Update' ")
                .withFlow("Valuation")
                .withAction("Jira Assignment")
                .withActionValue("MIL-7049")
                .withActionValueType("Mis Reporting")
                .withIsActive(true)
                .withStartDate("2020-01-01")
                .withLastSuccessDate("2020-01-01")
                .withMaxVolume(1000)
                .withUserComments("Jira Type Added").create();
    }

    private ScanResult getMockScanResult(List<Record> records) {
        return new ScanResult() {
            @Override
            public AsOf getAsOf() {
                return null;
            }

            @Override
            public String getCommandId() {
                return null;
            }

            @Override
            public ExplainPlan getExplainPlan() {
                return null;
            }

            @Override
            public void close() {
            }

            @Override
            public Iterator<Record> iterator() {
                return records.iterator();
            }
        };
    }

    private Record getMockRecords() {
        String jsonRecord = "{\n" +
                "  \"id\": \"1\",\n" +
                "  \"primaryKey\": \"Reconciliation_g2_Jira Assignment_TNTR-5678_CFTC_Rates_NAK_FAILED_2\",\n" +
                "  \"groupId\": \"g2\",\n" +
                "  \"expression\": \"subjectIdentifier.reconciliationRuleIdentifier in ('CftcPositionRates') and reconciliationBusinessDateTime = '2022-11-18T00:00:00.000Z' and reconciliationState.reconciliationStatus = 'Target Unpaired' and sourceRecords.reportingStatus in ('FAILED_ACKNOWLEDGEMENT')\",\n" +
                "  \"expressionDescription\": \"TEST\",\n" +
                "  \"flow\": \"Reconciliation\",\n" +
                "  \"action\": \"Jira Assignment\",\n" +
                "  \"actionValue\": \"TNTR-5678\",\n" +
                "  \"actionValueType\": \"\",\n" +
                "  \"ruleOwnerRecfId\": null,\n" +
                "  \"isActive\": false,\n" +
                "  \"activeDateTime\": \"2022-11-23T09:59:43.343Z\",\n" +
                "  \"inActiveDateTime\": \"2022-11-23T13:05:39.313Z\",\n" +
                "  \"ruleName\": \"CFTC_Rates_NAK_FAILED_2\",\n" +
                "  \"startDate\": \"2022-11-18T00:00:00.000Z\",\n" +
                "  \"lastSuccessDate\": \"2022-11-23T00:00:00.000Z\",\n" +
                "  \"comments\": \"\",\n" +
                "  \"status\": null,\n" +
                "  \"businessDateStr\": \"2022-11-23\",\n" +
                "  \"ruleEngineDateTime\": null,\n" +
                "  \"modifiedRecords\": 0,\n" +
                "  \"maxVolume\": 3000,\n" +
                "  \"indexHint\": \"\",\n" +
                "  \"userComment\": \"no user comment\",\n" +
                "  \"subExpression\": \"\",\n" +
                "  \"scheduledTime\": \"10:04 AM\",\n" +
                "  \"nextRunDateTime\": \"2022-11-24T10:04:00.000Z\"\n" +
                "}";
        Record record = new Record();
        RecordId recordId = new RecordId();
        recordId.setDatabaseName(DB);
        recordId.setCollectionName(COLLECTION_NAME);
        record.setId(recordId);
        record.setDocument((new JsonDocument()).withContents(jsonRecord));
        return record;
    }
}
