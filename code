package com.rbs.tntr.business.taggingService.repository;

import com.fasterxml.jackson.core.JsonParser; import com.rbs.datafabric.api.ScanResult; import com.rbs.datafabric.api.exception.ScanException; import com.rbs.datafabric.api.exception.UpsertException; import com.rbs.datafabric.client.DataFabricClient; import com.rbs.datafabric.domain.Document; import com.rbs.datafabric.domain.JsonDocument; import com.rbs.datafabric.domain.Record; import com.rbs.datafabric.domain.RecordId; import com.rbs.datafabric.domain.client.builder.UpsertRequestBuilder; import com.rbs.tntr.business.taggingService.service.common.ItrClient; import com.rbs.tntr.configuration.ItrConfiguration; import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.DFQueryMetaData; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIDashboardAnalytics; import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.SubjectIdentifier; import org.apache.commons.lang3.StringUtils; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.*; import org.springframework.test.util.ReflectionTestUtils;

import java.io.; import java.nio.charset.StandardCharsets; import java.text.SimpleDateFormat; import java.util.; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Consumer;

import static org.junit.Assert.; import static org.mockito.Matchers.any; import static org.mockito.Matchers.eq; import static org.mockito.Mockito.;

@RunWith(org.mockito.runners.MockitoJUnitRunner.class) public class MIAnalyticsDashboardRepositoryImplTest {

@Mock
private DfConnectionManager dfConnectionManager;
@Mock
private DataFabricClient dfClient;
@Mock
private ItrConfiguration itrConfiguration;
@Mock
private ItrClient itrClient;

@InjectMocks
private MIAnalyticsDashboardRepositoryImpl repository;

@Before
public void setUp() throws Exception {
    when(dfConnectionManager.getConnection()).thenReturn(null);
    // inject dfClient via getDfClient override
    // spy repository to override getDfClient
    repository = Mockito.spy(new MIAnalyticsDashboardRepositoryImpl(dfConnectionManager, itrConfiguration, itrClient));
    doReturn(dfClient).when(repository).getDfClient(dfConnectionManager);
    // set config values
    ReflectionTestUtils.setField(repository, "databaseName", "db");
    ReflectionTestUtils.setField(repository, "miCollection", "miCol");
    ReflectionTestUtils.setField(repository, "foMiCollection", "foCol");
    ReflectionTestUtils.setField(repository, "readTimeOut", 5);
    ReflectionTestUtils.setField(repository, "foEmirUrl", "emir");
    ReflectionTestUtils.setField(repository, "foEmirParameterisedUrl", "emirParam");
    ReflectionTestUtils.setField(repository, "foMasUrl", "mas");
    ReflectionTestUtils.setField(repository, "foMasParameterisedUrl", "masParam");
    ReflectionTestUtils.setField(repository, "foBoiUrl", "boi");
    ReflectionTestUtils.setField(repository, "foMifidUrl", "mifid");
    ReflectionTestUtils.setField(repository, "foSftrUrl", "sftr");
    ReflectionTestUtils.setField(repository, "foSftrAldopUrl", "sftrAldop");
    ReflectionTestUtils.setField(repository, "foCftcUrl", "cftc");
    // ITR config
    when(itrConfiguration.getItr2ProtocolScheme()).thenReturn("http");
    when(itrConfiguration.getItr2ServiceName()).thenReturn("service");
    // create connection
    repository.createDfClientConnection();
}

@Test
public void testSerializeDeserialize() throws Exception {
    SubjectIdentifier id = new SubjectIdentifier();
    id.setBusinessDate(new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-01"));
    id.setLei("lei");
    id.setAssetClass("asset");
    id.setEntity("ent");
    id.setFlow("flow");
    id.setRegulation("reg");
    id.setMessageType("msg");
    MIDashboardAnalytics stats = new MIDashboardAnalytics();
    stats.setSubjectIdentifier(id);
    Document doc = repository.serialize(stats);
    assertTrue(doc instanceof JsonDocument);
    MIDashboardAnalytics out = repository.deserailze(doc);
    assertEquals(stats.getSubjectIdentifier().getLei(), out.getSubjectIdentifier().getLei());
}

@Test
public void testUpsertMiSnapshotSuccess() throws Exception {
    MIDashboardAnalytics stats = mock(MIDashboardAnalytics.class);
    SubjectIdentifier sid = new SubjectIdentifier();
    sid.setBusinessDate(new Date());
    sid.setLei("lei"); sid.setAssetClass("asset"); sid.setEntity("e"); sid.setFlow("f"); sid.setRegulation("r"); sid.setMessageType("m");
    when(stats.getSubjectIdentifier()).thenReturn(sid);
    RecordId rid = new RecordId("id");
    when(dfClient.upsert(any(UpsertRequestBuilder.class))).thenReturn(rid);
    RecordId out = repository.upsertMiSnapshot(stats);
    assertEquals(rid, out);
}

@Test(expected = RuntimeException.class)
public void testUpsertMiSnapshotException() throws Exception {
    MIDashboardAnalytics stats = mock(MIDashboardAnalytics.class);
    when(stats.getSubjectIdentifier()).thenThrow(new RuntimeException());
    repository.upsertMiSnapshot(stats);
}

@Test
public void testGetURL() {
    String url = repository.getURL("endpoint");
    assertEquals("http://service/endpoint", url);
}

@Test
public void testItrQueryForFO() {
    DFQueryMetaData meta = new DFQueryMetaData();
    meta.setSelect("sel"); meta.setWhere("where");
    Itr2Query q = repository.itrQueryForFO(meta);
    assertNotNull(q);
}

@Test
public void testParseRecordFlatten() throws Exception {
    String json = "{\"a\":1, \"b\": {\"c\":2}}";
    JsonParser parser = JsonParser.class
            .getConstructor(InputStream.class)
            .newInstance(new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)));
    Map<String,Object> map = repository.parseRecord(parser);
    assertTrue(map.containsKey("a"));
    assertTrue(map.containsKey("b.c"));
}

@Test
public void testRenderCftcDataBlock() {
    Map<String,Object> map = new HashMap<>();
    map.put("block", "{x=true,y=false}");
    Map<String,Object> out = repository.renderCftcDataBlock(map, "block");
    assertEquals("true", out.get("x"));
}

@Test
public void testCalculateKeys() throws Exception {
    SubjectIdentifier sid = new SubjectIdentifier();
    sid.setBusinessDate(new SimpleDateFormat("yyyy-MM-dd").parse("2025-05-02"));
    sid.setLei("lei"); sid.setAssetClass("asset"); sid.setEntity("entity"); sid.setFlow("flow"); sid.setRegulation("reg"); sid.setMessageType("msg");
    String key = (String) ReflectionTestUtils.invokeMethod(repository, "calculateMiSnapshotKey", sid);
    assertNotNull(key);
    FrontOfficeSubjectIdentifier fsid = new FrontOfficeSubjectIdentifier("ent","lei","asset","reg",sid.getBusinessDate());
    String fkey = (String) ReflectionTestUtils.invokeMethod(repository, "calculateFoMiSnapshotKey", fsid);
    assertNotNull(fkey);
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchStatisticsIOException() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("col"); meta.setStatName("count");
    when(dfClient.scan(any())).thenThrow(new RuntimeException(new IOException()));
    repository.fetchStatistics(meta, "field");
}

@Test
public void testFetchStatisticsEmpty() throws Exception {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("col"); meta.setStatName("count");
    ScanResult res = mock(ScanResult.class);
    when(dfClient.scan(any())).thenReturn(res);
    when(res.iterator()).thenReturn(Collections.<Record>emptyList().iterator());
    int count = repository.fetchStatistics(meta, "field");
    assertEquals(0, count);
}

@Test
public void testFetchRecordsFromDfSuccess() {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("col");
    ScanResult res = mock(ScanResult.class);
    Record r = mock(Record.class);
    when(r.getDocument()).thenReturn(new JsonDocument().withContents("{}"));
    when(res.iterator()).thenReturn(Collections.singletonList(r).iterator());
    when(dfClient.scan(any())).thenReturn(res);
    List<Record> list = repository.fetchRecordsFromDf(meta);
    assertEquals(1, list.size());
}

@Test(expected = TaggingServiceRunTimeException.class)
public void testFetchRecordsFromDfException() {
    DFQueryMetaData meta = new DFQueryMetaData(); meta.setCollectionName("col");
    when(dfClient.scan(any())).thenThrow(new RuntimeException());
    repository.fetchRecordsFromDf(meta);
}

@Test
public void testProcessFoDataMapIncrements() {
    Map<String, Map<String,Integer>> foMiData = new HashMap<>();
    String jurisdiction = "JUR";
    Map<String,Integer> data = new HashMap<>(); data.put("NWM_PLC_REPORTABLE", 0);
    foMiData.put(jurisdiction, data);
    Map<String, Map<String,Object>> parsed = new HashMap<>();
    Map<String,Object> rec = new HashMap<>();
    rec.put("tradingPartyLei", "LEI_NWM_PLC"); rec.put("transactionReportable", true); rec.put("versionReportable", true);
    parsed.put(jurisdiction, rec);
    repository.processFoDataMap(parsed, foMiData);
    assertEquals((Integer)1, foMiData.get(jurisdiction).get("NWM_PLC_REPORTABLE"));
}

@Test
public void testPersistFoMiDataPaths() {
    // test persistFoMiData indirectly covers upsertFoMiSnapshot
    FrontOfficeMIDashboardAnalytics fo = mock(FrontOfficeMIDashboardAnalytics.class);
    // spy upsertFoMiSnapshot to verify calls
    MIAnalyticsDashboardRepositoryImpl spy = Mockito.spy(repository);
    doReturn(new RecordId("id")).when(spy).upsertFoMiSnapshot(any(FrontOfficeMIDashboardAnalytics.class));
    // invoke persistFoMiData
    ReflectionTestUtils.invokeMethod(spy, "persistFoMiData", "E", "L", "A", "REG", new Date(), 1, 2);
    verify(spy, times(1)).upsertFoMiSnapshot(any(FrontOfficeMIDashboardAnalytics.class));
}

}

