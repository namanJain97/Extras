Could you write all the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

package com.rbs.tntr.business.blotter.services.common;

import com.nwm.tntr.commons.core.SpringContext;
import com.nwm.tntr.commons.enums.ApiQueryFilter;
import com.nwm.tntr.commons.repository.collateral.CollateralTdxRepository;
import com.nwm.tntr.commons.repository.recon.ReconTdxRepository;
import com.nwm.tntr.commons.repository.recon.ReconTdxService;
import com.nwm.tntr.commons.repository.reconBatchTrigger.ReconBatchTriggerRepository;
import com.nwm.tntr.commons.repository.service.tdx.TdxRepository;
import com.nwm.tntr.commons.repository.trade.TradeTdxRepository;
import com.nwm.tntr.commons.repository.trade.ValuationsTdxRepository;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.tntr.business.blotter.services.reconciliationActions.ReconciliationActionService;
import com.rbs.tntr.business.blotter.web.request.futures.FuturesDashboardSearchRequest;
import com.rbs.tntr.domain.blotter.enums.FlowType;
import com.tdx.client.api.exception.TDXClientFactoryException;
import com.tdx.client.api.exception.TDXException;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import java.io.IOException;
import java.util.*;

@Component
public class TdxFacade implements TdxService {

    final ReconTdxService reconTdxService;
    final ReconBatchTriggerRepository reconBatchTriggerRepository;
    final ReconciliationActionService reconciliationActionService;

    @Autowired
    public TdxFacade(ReconTdxService reconTdxService, ReconBatchTriggerRepository reconBatchTriggerRepository, ReconciliationActionService reconciliationActionService) {
        this.reconTdxService = reconTdxService;
        this.reconBatchTriggerRepository = reconBatchTriggerRepository;
        this.reconciliationActionService = reconciliationActionService;
    }

    @Override
    public List<HashMap> executeReadCommand(FuturesDashboardSearchRequest futuresDashboardSearchRequest) throws TDXException, TDXClientFactoryException, IOException, StartableException, ScanException {
        EnumMap<ApiQueryFilter, Object> apiQueryFilterMap = new EnumMap<>(ApiQueryFilter.class);
        apiQueryFilterMap.put(ApiQueryFilter.SELECT, futuresDashboardSearchRequest.getSelectClause());
        apiQueryFilterMap.put(ApiQueryFilter.WHERE, futuresDashboardSearchRequest.getWhereClause());
        apiQueryFilterMap.put(ApiQueryFilter.GROUP_BY, futuresDashboardSearchRequest.getGroupByClause());
        apiQueryFilterMap.put(ApiQueryFilter.HISTORY, futuresDashboardSearchRequest.isHistory());
        if(futuresDashboardSearchRequest.getRowLimit()>0) {
            apiQueryFilterMap.put(ApiQueryFilter.ROW_LIMIT, futuresDashboardSearchRequest.getRowLimit());
        }
        if(StringUtils.isNotBlank(futuresDashboardSearchRequest.getAsOf())){
            apiQueryFilterMap.put(ApiQueryFilter.AS_OF, futuresDashboardSearchRequest.getAsOf());
        }

        List<HashMap> lstTDXDocument;
        if(futuresDashboardSearchRequest.getFlow().equalsIgnoreCase(FlowType.RECONC_BATCH_TRIGGER.getValue())) {
            lstTDXDocument = reconBatchTriggerRepository.getReconBatchByCriteria(futuresDashboardSearchRequest.getWhereClause(),
                    futuresDashboardSearchRequest.getGroupByClause(),
                    null,
                    futuresDashboardSearchRequest.isHistory(),
                    futuresDashboardSearchRequest.getRowLimit());
        }else if(futuresDashboardSearchRequest.getFlow().equalsIgnoreCase(FlowType.RECONCILIATION.getValue())) {
            ReconTdxRepository reconTdxRepository = SpringContext.getBean(ReconTdxRepository.class);
            lstTDXDocument = reconTdxRepository.getTdxService().getDocumentByTdxServiceWithGroupBy(reconTdxRepository.getTdxDataSetName(), apiQueryFilterMap);
        }else if(futuresDashboardSearchRequest.getFlow().equalsIgnoreCase(FlowType.RECONCILIATION_DF.getValue())) {
            lstTDXDocument = reconciliationActionService.executeReadCommand(futuresDashboardSearchRequest);
        }else if(futuresDashboardSearchRequest.getFlow().equalsIgnoreCase(FlowType.COLLATERAL.getValue())) {
            CollateralTdxRepository collTdxRepository = SpringContext.getBean(CollateralTdxRepository.class);
            lstTDXDocument = collTdxRepository.getTdxService().getDocumentByTdxServiceWithGroupBy(collTdxRepository.getTdxDataSetName(), apiQueryFilterMap);
        }else{
            TdxRepository tradeTdxRepository;
            if(futuresDashboardSearchRequest.getFlow().equalsIgnoreCase(FlowType.VALUATION.getValue())) {
                tradeTdxRepository = SpringContext.getBean(ValuationsTdxRepository.class);
            }else {
                tradeTdxRepository = SpringContext.getBean(TradeTdxRepository.class);
            }

            lstTDXDocument = tradeTdxRepository.getTdxService().getDocumentByTdxServiceWithGroupBy(tradeTdxRepository.getTdxDataSetName(), apiQueryFilterMap);
        }

        return lstTDXDocument;
    }

}

Exisitng test class:

package com.rbs.tntr.business.blotter.services.common;

import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.tntr.business.blotter.web.request.futures.FuturesDashboardSearchRequest;
import com.rbs.tntr.domain.blotter.enums.FlowType;
import com.tdx.client.api.exception.TDXClientFactoryException;
import com.tdx.client.api.exception.TDXException;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import java.io.IOException;
import java.util.*;
import static org.junit.Assert.*;

@RunWith(MockitoJUnitRunner.class)
public class TdxFacadeTest {

    @InjectMocks
    private TdxFacade tdxFacade;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testReconBatchFlow() throws TDXException, TDXClientFactoryException, IOException, StartableException, ScanException {
        FuturesDashboardSearchRequest searchRequest = new FuturesDashboardSearchRequest();
        searchRequest.setFlow(FlowType.RECONC_BATCH_TRIGGER.getValue());
        searchRequest.setWhereClause("WHERE status = 'active'");
        List<HashMap> result = tdxFacade.executeReadCommand(searchRequest);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
}
