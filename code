package com.rbs.tntr.business.blotter.services.replay;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nwm.tntr.commons.domain.persistence.constant.ReportingRegime;
import com.nwm.tntr.commons.domain.persistence.constant.ReportingRegulatoryAuthority;
import com.nwm.tntr.commons.domain.persistence.constant.SourceSystemId;
import com.rbs.tntr.business.blotter.configuration.*;
import com.rbs.tntr.business.blotter.security.BlotterSecurityService;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeServiceImpl;
import com.rbs.tntr.business.blotter.services.replay.tntr.*;
import com.rbs.tntr.domain.blotter.enums.CRAction;
import com.rbs.tntr.domain.blotter.tntrBlotterView.*;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentMatcher;
import org.mockito.Mockito;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.lang.reflect.Method;
import java.net.SocketTimeoutException;
import java.util.*;

public class ReplayServiceImplTest {

    ReplayServiceImpl replayService;
    RestTemplate restTemplate;
    private static final ObjectMapper mapper = new ObjectMapper();
    BlotterSecurityService bss;
    DateTimeService dateTimeService;
    String currentDate = "2019-01-26T12:23:00.373Z";
    final static String COLLATERAL_UPDATE = "Collateral Update";
    EmirReplayBackdatedValREEndpoints emirReplayBackdatedValREEndpoints;
    NoaReplayREEndpoints noaReplayREEndpoints;
    EmirReplayREHost emirReplayREHost;
    EmirExoticReplayREEndpoint emirExoticReplayREEndpoint;
    NoaReplayREHost noaReplayREHost;
    EmirReplayREEndpoints emirReplayREEndpoints;
    MifidReplayREHost mifidReplayREHost;
    MifidReplayREEndpoint mifidReplayREEndpoint;
    MasReplayREEndpoints masReplayREEndpoints;
    MasReplayREHost masReplayREHost;

    final String reHost = "http://tntrreportingdev-ttr-dev.arc-tst.fm.rbsgrp.net";
    final String reEndPoint = "/tntr/eodprocess/sftr/trade/initiate/replay/trades";
    final String reColluEndPoint = "/tntr/eodprocess/sftr/trade/initiate/replay/valuations";
    final String aldopTradeEndPoint = "/tntr/eodprocess/sftr/aldop/trade/initiate/replay/trades";
    final String aldopColluTradeEndPoint = "/tntr/eodprocess/sftr/aldop/trade/initiate/replay/valuations";
    final String replayCredit = "/tntr/credit/valuation/blotter/replay";
    final String replayRates = "/tntr/rates/valuation/blotter/replay";
    final String replayCftc = "/tntr/cftc/valuation/blotter/replay";
    final String csaReplay = "/tntr/canada/valuation/blotter/replay";
    final String noaCrTrade = "/tntr/cftc/cr/transaction";
    final String noaCrValPath = "/tntr/cftc/cr/valuation/path";
    final String noaCrValDR = "/tntr/cftc/cr/valuation";
    final String noaCrColPath = "/tntr/cftc/colval/initiate/misreporting/collateral/path";
    final String noaCrMrColDR = "/tntr/cftc/colval/initiate/misreporting/collateral";
    final String fxReplay = "/tntr/fx/valuation/blotter/replay";
    final String upStreamTradeReplay = "tntr/trade/blotter/replay";
    final String upStreamCreditReplay = "/tntr/credit/emir/trade/blotter/replay";
    final String etdTransaction = "/tntr/eodprocess/esma/etd/initiate/upstream-blotter-replay-transaction";
    final String emirTrade = "/tntr/emir/trade/blotter/replay";
    final String mifidTrade = "/tntr/mifid/trade/blotter/replay";
    final String mifidFx = "tntr/fx/mifid/trade/blotter/replay";
    final String mifidCredit = "tntr/credit/mifid/blotter/replay/blotterRequest";
    final String masCol = "/tntr/mas/colval/initate/backdated";
    final String emirColFca = "/tntr/emir/colval/initate/backdated/fca";
    final String emirColEsma = "/tntr/emir/colval/initate/backdated/esma";

    @Before
    public void init() {
        emirReplayBackdatedValREEndpoints = new EmirReplayBackdatedValREEndpoints();
        emirReplayBackdatedValREEndpoints.setCredit(replayCredit);
        emirReplayBackdatedValREEndpoints.setFx(fxReplay);
        emirReplayBackdatedValREEndpoints.setRates(replayRates);

        noaReplayREEndpoints = new NoaReplayREEndpoints();
        noaReplayREEndpoints.setTrade(upStreamTradeReplay);
        noaReplayREEndpoints.setCrTrade(noaCrTrade);
        noaReplayREEndpoints.setCrValPath(noaCrValPath);
        noaReplayREEndpoints.setCrValDateRange(noaCrValDR);
        noaReplayREEndpoints.setCrColPath(noaCrColPath);
        noaReplayREEndpoints.setMrColDateRange(noaCrMrColDR);
        noaReplayREEndpoints.setMrBothDateRange(noaCrMrColDR);

        emirReplayREHost = new EmirReplayREHost();
        emirReplayREHost.setFx(reHost);
        emirReplayREHost.setCredit(reHost);
        emirReplayREHost.setRates(reHost);
        emirReplayREHost.setEtd(reHost);

        noaReplayREHost = new NoaReplayREHost();
        noaReplayREHost.setFx(reHost);
        noaReplayREHost.setRates(reHost);
        noaReplayREHost.setExotic(reHost);
        noaReplayREHost.setCftcCollal(reHost);

        emirExoticReplayREEndpoint = new EmirExoticReplayREEndpoint();
        emirExoticReplayREEndpoint.setTrade("trade");
        emirExoticReplayREEndpoint.setRates(replayRates);
        emirExoticReplayREEndpoint.setFx(fxReplay);
        emirExoticReplayREEndpoint.setCredit(replayCredit);

        emirReplayREEndpoints = new EmirReplayREEndpoints();
        emirReplayREEndpoints.setCredit(upStreamCreditReplay);
        emirReplayREEndpoints.setRates(emirTrade);
        emirReplayREEndpoints.setFx(upStreamTradeReplay);
        emirReplayREEndpoints.setEtdLifecycle("");
        emirReplayREEndpoints.setEtdPosition("");
        emirReplayREEndpoints.setEtdTransaction(etdTransaction);

        mifidReplayREHost = new MifidReplayREHost();
        mifidReplayREHost.setBonds(reHost);
        mifidReplayREHost.setCredit(reHost);
        mifidReplayREHost.setRates(reHost);
        mifidReplayREHost.setFx(reHost);
        mifidReplayREHost.setEtd(reHost);

        mifidReplayREEndpoint = new MifidReplayREEndpoint();
        mifidReplayREEndpoint.setCredit(mifidCredit);
        mifidReplayREEndpoint.setRates(mifidTrade);
        mifidReplayREEndpoint.setFx(mifidFx);
        mifidReplayREEndpoint.setEtd(mifidTrade);
        mifidReplayREEndpoint.setBonds(mifidTrade);

        masReplayREHost = new MasReplayREHost();
        masReplayREHost.setCollateral(reHost);

        masReplayREEndpoints = new MasReplayREEndpoints();
        masReplayREEndpoints.setCollateral(masCol);

        ReportingEngineConfiguration reConfig = new ReportingEngineConfiguration.Builder()
                .withTradeReportingEndpoint(reEndPoint)
                .withColluReportingEndpoint(reColluEndPoint)
                .withReportingHost(reHost)
                .withReportingHostETD(reHost)
                .withEmirExoticReplayREHost(reHost)
                .withEmirReplayBackdatedValREEndpoints(emirReplayBackdatedValREEndpoints)
                .withCftcReplayValutionEndpoint(replayCftc)
                .withNoaReplayREEndpoints(noaReplayREEndpoints)
                .withCsaReplayValuationEndpoint(csaReplay)
                .withEmirReplayREHost(emirReplayREHost)
                .withEmirExoticReplayREEndpoint(emirExoticReplayREEndpoint)
                .withNoaReplayREHost(noaReplayREHost)
                .withEmirReplayREEndpoints(emirReplayREEndpoints)
                .withMifidReplayREHost(mifidReplayREHost)
                .withMifidReplayREEndpoint(mifidReplayREEndpoint)
                .withMasReplayREEndpoints(masReplayREEndpoints)
                .withMasReplayREHost(masReplayREHost)
                .withEmirColReplayEsmaEndpoint(emirColEsma)
                .withEmirColReplayFcaEndpoint(emirColFca)
                .withEmirColReplayREHost(reHost)
                .build();

        restTemplate = Mockito.mock(RestTemplate.class);
        bss = Mockito.mock(BlotterSecurityService.class);
        Mockito.when(bss.getApplicationSsoToken()).thenReturn("ApplicationSsoToken");

        dateTimeService = Mockito.mock(DateTimeService.class);
        Mockito.when(dateTimeService.getCurrentDateTime())
                .thenReturn(new DateTimeServiceImpl().parseDateTime(currentDate));

        replayService = new ReplayServiceImpl(reConfig, restTemplate, bss, dateTimeService);
        Mockito.when(bss.getLoggedInUserName()).thenReturn("username");
    }

    // Existing test methods remain unchanged, additional tests added below

    // Test for replayCRValuation with exception handling (RestClientException)
    @Test
    public void replayCRValuation_RestClientException() {
        CorrectiveReportingForValuation request = new CorrectiveReportingForValuation();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "InterestRate", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_VALUATION);
        request.setDataFetchFrom("CMG");

        TntrCRValuationRequest valuationRequest = new TntrCRValuationRequest(
                request.getPrimaryKey().getSourceSystem(), true, "username");
        String reUrl = reHost + noaCrValPath;

        ArgumentMatcher<HttpEntity> httpEntityMatcher = argument -> {
            TntrCRValuationRequest t = (TntrCRValuationRequest) argument.getBody();
            return t.getSourceSystem().equals(valuationRequest.getSourceSystem()) &&
                    t.getActionBy().equals(valuationRequest.getActionBy()) &&
                    t.isUseCmgValuationData() &&
                    argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON) &&
                    argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
        };

        Mockito.when(restTemplate.exchange(
                Mockito.eq(reUrl),
                Mockito.eq(HttpMethod.POST),
                Mockito.argThat(httpEntityMatcher),
                Mockito.any(ParameterizedTypeReference.class)))
                .thenThrow(new RestClientException("Test Exception"));

        String result = replayService.replayCRValuation(request);
        Assert.assertEquals("Request for DODD_FRANK_ACT_US for InterestRate was submitted to RE Service", result);
    }

    // Test for replayCRValuation with generic Exception
    @Test
    public void replayCRValuation_GenericException() {
        CorrectiveReportingForValuation request = new CorrectiveReportingForValuation();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "InterestRate", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_VALUATION);
        request.setDataFetchFrom("CMG");

        TntrCRValuationRequest valuationRequest = new TntrCRValuationRequest(
                request.getPrimaryKey().getSourceSystem(), true, "username");
        String reUrl = reHost + noaCrValPath;

        ArgumentMatcher<HttpEntity> httpEntityMatcher = argument -> {
            TntrCRValuationRequest t = (TntrCRValuationRequest) argument.getBody();
            return t.getSourceSystem().equals(valuationRequest.getSourceSystem()) &&
                    t.getActionBy().equals(valuationRequest.getActionBy()) &&
                    t.isUseCmgValuationData() &&
                    argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON) &&
                    argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
        };

        Mockito.when(restTemplate.exchange(
                Mockito.eq(reUrl),
                Mockito.eq(HttpMethod.POST),
                Mockito.argThat(httpEntityMatcher),
                Mockito.any(ParameterizedTypeReference.class)))
                .thenThrow(new RuntimeException("Generic Exception"));

        String result = replayService.replayCRValuation(request);
        Assert.assertEquals("", result); // EMPTY string as per method logic
    }

    // Test for replayCRCollateral with Under Reporting issue type
    @Test
    public void replayCRCollateral_UnderReporting_Success() {
        CorrectiveReportingForCollateral request = new CorrectiveReportingForCollateral();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Under Reporting", "Collateral", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_COLLATERAL_DATE_RANGE);
        request.setFlow("Collateral");
        request.setCollateralDateFrom("2024-01-01");
        request.setCollateralDateTo("2024-01-05");
        request.setOverrideFields("field");

        String baseUrl = reHost + "/tntr/cftc/colval/initiate/underreporting/collateral"; // Assuming this from configuration
        String reUrl = UriComponentsBuilder.fromHttpUrl(baseUrl)
                .queryParam("overrideFields", request.getOverrideFields().trim())
                .queryParam("beginDate", request.getCollateralDateFrom())
                .queryParam("endDate", request.getCollateralDateTo())
                .build().encode().toUri().toString();

        ArgumentMatcher<HttpEntity> httpEntityMatcher = argument ->
                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON) &&
                        argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");

        Mockito.when(restTemplate.exchange(
                Mockito.eq(reUrl),
                Mockito.eq(HttpMethod.POST),
                Mockito.argThat(httpEntityMatcher),
                Mockito.any(ParameterizedTypeReference.class)))
                .thenReturn(new ResponseEntity<>("Success", HttpStatus.OK));

        String result = replayService.replayCRCollateral(request);
        Assert.assertEquals("Request for DODD_FRANK_ACT_US for Collateral was Successful", result);
    }

    // Test for replayCRTrades with invalid source system for FX
    @Test
    public void replayCRTrades_InvalidSourceSystem_FX() {
        CorrectiveReportingForTrade request = getCrTradeAsPrimaryKey("Mis Reporting", "ForeignExchange", "InvalidSource");
        String result = replayService.replayCRTrades(request);
        Assert.assertEquals("Request for invalid source system id : InvalidSource rejected", result);
    }

    // Test for replayTradesForUpstream with empty list
    @Test
    public void replayTradesForUpstream_EmptyList() {
        List<ReplayTrade> requests = new ArrayList<>();
        List<String> results = replayService.replayTradesForUpstream(requests, ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        Assert.assertTrue(results.isEmpty());
    }

    // Test for replayTradesForUpstream with exotic trade in EMIR
    @Test
    public void replayTradesForUpstream_EMIR_ExoticTrade() throws JsonProcessingException {
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("GDS GBLO");
        replayTrade.setRegime(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayTrade.setIsExoticTrade("true");
        replayTrade.setType("Transaction");
        List<ReplayTrade> requests = Arrays.asList(replayTrade);

        TntrReplayTradesRequest tradesRequest = new TntrReplayTradesRequest(
                Arrays.asList(replayTrade.getTradeId()), replayTrade.getSourceSystemId(), "username");
        String reUrl = reHost + "/trade";

        ArgumentMatcher<HttpEntity> httpEntityMatcher = argument -> {
            TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
            return t.getTradeIds().containsAll(tradesRequest.getTradeIds()) &&
                    t.getSourceSystem().equals(tradesRequest.getSourceSystem()) &&
                    t.getActionBy().equals(tradesRequest.getActionBy()) &&
                    argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON) &&
                    argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
        };

        Mockito.when(restTemplate.exchange(
                Mockito.eq(reUrl),
                Mockito.eq(HttpMethod.POST),
                Mockito.argThat(httpEntityMatcher),
                Mockito.any(ParameterizedTypeReference.class)))
                .thenReturn(new ResponseEntity<>("Success", HttpStatus.OK));

        List<String> results = replayService.replayTradesForUpstream(requests, ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        Assert.assertEquals(1, results.size());
        Assert.assertEquals("Request for EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION for GDS GBLO was Successful", results.get(0));
    }

    // Test for replayBackdatedValuationForBusinessDate with invalid source system
    @Test
    public void replayBackdatedValuationForBusinessDate_InvalidSourceSystem() {
        ReplayValuationForBusinessDate request = new ReplayValuationForBusinessDate();
        request.setValuationDate("2024-05-16");
        request.setFlow("Transaction");
        request.setTradeId("tradeId1");
        request.setSourceSystem("InvalidSource");
        request.setRegulatoryName(ReportingRegime.DODD_FRANK_ACT_US);
        request.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        request.setIsExoticTrade("false");
        List<ReplayValuationForBusinessDate> requests = Arrays.asList(request);

        List<String> results = replayService.replayBackdatedValuationForBusinessDate(requests,
                ReportingRegime.DODD_FRANK_ACT_US, ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        Assert.assertEquals(1, results.size());
        Assert.assertEquals("Request for invalid source system id : InvalidSource rejected", results.get(0));
    }

    // Test for replayBackdatedValuationForDateRange with exotic trade
    @Test
    public void replayBackdatedValuationForDateRange_EMIR_ExoticTrade() throws JsonProcessingException {
        ReplayValuationForDateRange request = new ReplayValuationForDateRange();
        request.setValuationDateFrom("2024-05-16");
        request.setValuationDateTo("2024-05-18");
        request.setFlow("Transaction");
        request.setTradeId("tradeId1");
        request.setSourceSystem("GDS GBLO");
        request.setAssetClass("ForeignExchange");
        request.setExoticType("AC_Exotic");
        request.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        request.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        request.setIsExoticTrade("true");
        List<ReplayValuationForDateRange> requests = Arrays.asList(request);

        TntrReplayValuationForDateRangeRequest dateRangeRequest = new TntrReplayValuationForDateRangeRequest(
                request.getSourceSystem(), Arrays.asList(request.getTradeId()), request.getValuationDateFrom(),
                request.getValuationDateTo(), "username", request.getRegulatoryAuthority().value());
        String reUrl = reHost + fxReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher = argument -> {
            TntrReplayValuationForDateRangeRequest t = (TntrReplayValuationForDateRangeRequest) argument.getBody();
            return t.getTradeList().containsAll(dateRangeRequest.getTradeList()) &&
                    t.getSourceSystem().equals(dateRangeRequest.getSourceSystem()) &&
                    t.getValuationDateFrom().equals(dateRangeRequest.getValuationDateFrom()) &&
                    t.getValuationDateTo().equals(dateRangeRequest.getValuationDateTo()) &&
                    t.getActionBy().equals(dateRangeRequest.getActionBy()) &&
                    t.getRegulatoryAuthority().equals(dateRangeRequest.getRegulatoryAuthority()) &&
                    argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON) &&
                    argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
        };

        Mockito.when(restTemplate.exchange(
                Mockito.eq(reUrl),
                Mockito.eq(HttpMethod.POST),
                Mockito.argThat(httpEntityMatcher),
                Mockito.any(ParameterizedTypeReference.class)))
                .thenReturn(new ResponseEntity<>("Success", HttpStatus.OK));

        List<String> results = replayService.replayBackdatedValuationForDateRange(requests,
                ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION,
                ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        Assert.assertEquals(1, results.size());
        Assert.assertEquals("Request for EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION for GDS GBLO was Successful", results.get(0));
    }

    // Test for replayBackdatedCollateralForDateRange with FCA authority
    @Test
    public void replayBackdatedCollateralForDateRange_EMIR_FCA_Success() throws JsonProcessingException {
        ReplayCollateralForDateRange request = new ReplayCollateralForDateRange();
        request.setStartDate("2024-05-15");
        request.setEndDate("2024-05-16");
        request.setMasterAgreementId("masterAgreementId");
        request.setReportSubmissionType("TYPE");
        request.setEntity("PLC");
        request.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        request.setRegulatoryAuthority(ReportingRegulatoryAuthority.FINANCIAL_CONDUCT_AUTHORITY_UK);
        List<ReplayCollateralForDateRange> requests = Arrays.asList(request);

        TntrReplayCollateralForDateRangeRequest tntrReq = new TntrReplayCollateralForDateRangeRequest(
                request.getStartDate(), request.getEndDate(), request.getReportSubmissionType(),
                request.getEntity(), Arrays.asList(request.getMasterAgreementId()));
        String reUrl = reHost + emirColFca;

        ArgumentMatcher<HttpEntity> httpEntityMatcher = argument -> {
            TntrReplayCollateralForDateRangeRequest t = (TntrReplayCollateralForDateRangeRequest) argument.getBody();
            return t.getMasterAgreementIdList().containsAll(tntrReq.getMasterAgreementIdList()) &&
                    t.getStartDate().equals(tntrReq.getStartDate()) &&
                    t.getEndDate().equals(tntrReq.getEndDate()) &&
                    t.getEntity().equals(tntrReq.getEntity()) &&
                    t.getReportSubmissionType().equals(tntrReq.getReportSubmissionType()) &&
                    argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON) &&
                    argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
        };

        Mockito.when(restTemplate.exchange(
                Mockito.eq(reUrl),
                Mockito.eq(HttpMethod.POST),
                Mockito.argThat(httpEntityMatcher),
                Mockito.any(ParameterizedTypeReference.class)))
                .thenReturn(new ResponseEntity<>("Success", HttpStatus.OK));

        List<String> results = replayService.replayBackdatedCollateralForDateRange(requests,
                ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION,
                ReportingRegulatoryAuthority.FINANCIAL_CONDUCT_AUTHORITY_UK);
        Assert.assertEquals(1, results.size());
        Assert.assertEquals("Request for PLC for TYPE was Successful", results.get(0));
    }

    // Test for getCustomExoticTradeEndpoint with different regimes
    @Test
    public void getCustomExoticTradeEndpoint_DifferentRegimes() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("getCustomExoticTradeEndpoint",
                ReportingRegime.class, String.class, String.class);
        method.setAccessible(true);

        String result1 = (String) method.invoke(replayService, ReportingRegime.DODD_FRANK_ACT_US, "GDS GBLO", "TRANSACTION");
        Assert.assertEquals(reHost + "/tntr/trade/blotter/replay", result1);

        String result2 = (String) method.invoke(replayService, ReportingRegime.CANADA_RULE_91_507, "GDS USNY", "TRANSACTION");
        Assert.assertEquals(reHost + "/tntr/trade/blotter/replay", result2);

        String result3 = (String) method.invoke(replayService, ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION, "GDS GBLO", "TRANSACTION");
        Assert.assertEquals(reHost + "/trade", result3);

        String result4 = (String) method.invoke(replayService, ReportingRegime.THE_MONETARY_AUTHORITY_OF_SINGAPORE, "GDS GBLO", "TRANSACTION");
        Assert.assertNull(result4); // No endpoint for MAS
    }

    // Test for getReportingTypeFromIssueType with invalid issue type
    @Test
    public void getReportingTypeFromIssueType_InvalidIssueType() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("getReportingTypeFromIssueType", String.class);
        method.setAccessible(true);

        String result = (String) method.invoke(replayService, "Invalid Type");
        Assert.assertNull(result);
    }

    // Test for getCustomCRUrlHost with unsupported asset class
    @Test
    public void getCustomCRUrlHost_UnsupportedAssetClass() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("getCustomCRUrlHost", ReportingRegime.class, String.class);
        method.setAccessible(true);

        String result = (String) method.invoke(replayService, ReportingRegime.DODD_FRANK_ACT_US, "UnsupportedClass");
        Assert.assertNull(result);
    }

    // Test for getCustomCRUrlEndpoint with unsupported action
    @Test
    public void getCustomCRUrlEndpoint_UnsupportedAction() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("getCustomCRUrlEndpoint",
                ReportingRegime.class, CRAction.class, String.class);
        method.setAccessible(true);

        String result = (String) method.invoke(replayService, ReportingRegime.DODD_FRANK_ACT_US, null, "Mis Reporting");
        Assert.assertNull(result);
    }

    // Test for logHttpRequest with JsonProcessingException
    @Test
    public void logHttpRequest_JsonProcessingException() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("logHttpRequest", HttpEntity.class, String.class);
        method.setAccessible(true);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("sso-token", "ApplicationSsoToken");
        HttpEntity<Object> request = new HttpEntity<>(new Object() {
            @Override
            public String toString() {
                throw new RuntimeException("Force JsonProcessingException");
            }
        }, headers);

        // No assertion needed, just ensure no crash
        method.invoke(replayService, request, "testUrl");
    }

    // Test for getHeaderWithUserSSO
    @Test
    public void getHeaderWithUserSSO() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("getHeaderWithUserSSO");
        method.setAccessible(true);

        Mockito.when(bss.getLoggedInUserToken()).thenReturn("UserSsoToken");
        HttpHeaders headers = (HttpHeaders) method.invoke(replayService);

        Assert.assertEquals(MediaType.APPLICATION_JSON, headers.getContentType());
        Assert.assertEquals("UserSsoToken", headers.getFirst("sso-token"));
        Assert.assertEquals("username", headers.getFirst("user"));
        Assert.assertNotNull(headers.getFirst("RequestId"));
    }

    // Test for getHeaderWithSsoForETD
    @Test
    public void getHeaderWithSsoForETD() throws Exception {
        Method method = ReplayServiceImpl.class.getDeclaredMethod("getHeaderWithSsoForETD");
        method.setAccessible(true);

        Mockito.when(bss.getApplicationSsoToken(Mockito.anyString())).thenReturn("EtdSsoToken");
        HttpHeaders headers = (HttpHeaders) method.invoke(replayService);

        Assert.assertEquals(MediaType.APPLICATION_JSON, headers.getContentType());
        Assert.assertEquals("EtdSsoToken", headers.getFirst("sso-token"));
        Assert.assertEquals("username", headers.getFirst("user"));
        Assert.assertNotNull(headers.getFirst("RequestId"));
    }

    private CorrectiveReportingForTrade getCrTradeAsPrimaryKey(String issueType, String assetClass, String sourceSystem) {
        CorrectiveReportingForTrade request = new CorrectiveReportingForTrade();
        request.setAction(CRAction.CR_TRADE);
        request.setSourceSystem(sourceSystem);
        request.setIssueType(issueType);
        request.setAssetClass(assetClass);
        request.setRegime(ReportingRegime.DODD_FRANK_ACT_US);
        return request;
    }

    // Existing test methods below (unchanged)
    @Test
    public void replayBackdatedValuationForBusinessDate_EMIR_Interest_Rate() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("GDS GBLO");
        replayValuationForBusinessDate1.setAssetClass("InterestRate");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + replayRates;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_EMIR_Credit() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("GDS GBLO");
        replayValuationForBusinessDate1.setAssetClass("Credit");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + replayCredit;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_EMIR_Fx() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("GDS GBLO");
        replayValuationForBusinessDate1.setAssetClass("ForeignExchange");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + fxReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_EMIR_SystemX_FX() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setAssetClass("ForeignExchange");
        replayValuationForBusinessDate1.setSourceSystem("SystemX");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + fxReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_DODD_FRANK_ACT_US_GDS_GBLO() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("GDS GBLO");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.DODD_FRANK_ACT_US);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + replayCftc;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_CANADA_RULE_91_507_GDS_GBLO() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("GDS GBLO");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.CANADA_RULE_91_507);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + csaReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_CANADA_RULE_91_507_SystemX() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("SystemX");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.CANADA_RULE_91_507);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("false");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + csaReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_DODD_FRANK_ACT_US_GLOBAL_FX_GBLO() throws JsonProcessingException {
        List<ReplayValuationForBusinessDate> requests = new ArrayList<>();
        ReplayValuationForBusinessDate replayValuationForBusinessDate1 = new ReplayValuationForBusinessDate();
        replayValuationForBusinessDate1.setValuationDate("2024-05-16");
        replayValuationForBusinessDate1.setFlow("Transaction");
        replayValuationForBusinessDate1.setTradeId("tradeId1");
        replayValuationForBusinessDate1.setSourceSystem("GlobalFX GBLO");
        replayValuationForBusinessDate1.setRegulatoryName(ReportingRegime.DODD_FRANK_ACT_US);
        replayValuationForBusinessDate1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);
        replayValuationForBusinessDate1.setIsExoticTrade("true");

        requests.add(replayValuationForBusinessDate1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForBusinessDateRequest backdatedRequest1 =
                new TntrReplayValuationForBusinessDateRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDate(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + replayCftc;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForBusinessDateRequest t = (TntrReplayValuationForBusinessDateRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDate().equals(backdatedRequest1.getValuationDate()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForBusinessDate1.getRegulatoryName().value() + " for " + replayValuationForBusinessDate1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForBusinessDate(requests, replayValuationForBusinessDate1.getRegulatoryName(), replayValuationForBusinessDate1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdatedValuationForBusinessDate_EMIR_TMS_GBLO_FX() throws JsonProcessingException {
        List<ReplayValuationForDateRange> requests = new ArrayList<>();
        ReplayValuationForDateRange replayValuationForDateRange1 = new ReplayValuationForDateRange();
        replayValuationForDateRange1.setValuationDateFrom("2024-05-16");
        replayValuationForDateRange1.setValuationDateTo("2024-05-18");
        replayValuationForDateRange1.setFlow("Transaction");
        replayValuationForDateRange1.setTradeId("tradeId1");
        replayValuationForDateRange1.setAssetClass("ForeignExchange");
        replayValuationForDateRange1.setSourceSystem("GDS GBLO");
        replayValuationForDateRange1.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayValuationForDateRange1.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);

        requests.add(replayValuationForDateRange1);

        List<String> tradeIdsWithSourceSystem1 = Arrays.asList(requests.get(0).getTradeId());

        TntrReplayValuationForDateRangeRequest backdatedRequest1 =
                new TntrReplayValuationForDateRangeRequest(requests.get(0).getSourceSystem(), tradeIdsWithSourceSystem1, requests.get(0).getValuationDateFrom(), requests.get(0).getValuationDateTo(), "username", requests.get(0).getRegulatoryAuthority().value());

        String reUrl = reHost + replayRates;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayValuationForDateRangeRequest t = (TntrReplayValuationForDateRangeRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeList().containsAll(backdatedRequest1.getTradeList()) &&
                                        t.getSourceSystem().equals(backdatedRequest1.getSourceSystem()) &&
                                        t.getValuationDateFrom().equals(backdatedRequest1.getValuationDateFrom()) &&
                                        t.getValuationDateTo().equals(backdatedRequest1.getValuationDateTo()) &&
                                        t.getActionBy().equals(backdatedRequest1.getActionBy()) &&
                                        t.getRegulatoryAuthority().equals(backdatedRequest1.getRegulatoryAuthority()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayValuationForDateRange1.getRegulatoryName().value() + " for " + replayValuationForDateRange1.getSourceSystem() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedValuationForDateRange(requests, replayValuationForDateRange1.getRegulatoryName(), replayValuationForDateRange1.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdateCollateral_Emir() throws JsonProcessingException {
        List<ReplayCollateralForDateRange> requests = new ArrayList<>();
        ReplayCollateralForDateRange request = new ReplayCollateralForDateRange();
        request.setStartDate("2024-05-15");
        request.setEndDate("2024-05-16");
        request.setMasterAgreementId("masterAgreementId");
        request.setReportSubmissionType("TYPE");
        request.setEntity("PLC");
        request.setRegulatoryName(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        request.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);

        requests.add(request);

        List<String> idList = Arrays.asList(requests.get(0).getMasterAgreementId());

        TntrReplayCollateralForDateRangeRequest tntrReq = new TntrReplayCollateralForDateRangeRequest(
                requests.get(0).getStartDate(),
                requests.get(0).getEndDate(),
                requests.get(0).getReportSubmissionType(),
                requests.get(0).getEntity(),
                idList);

        String reUrl = reHost + emirColEsma;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayCollateralForDateRangeRequest t = (TntrReplayCollateralForDateRangeRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getMasterAgreementIdList().containsAll(tntrReq.getMasterAgreementIdList()) &&
                                        t.getStartDate().equals(tntrReq.getStartDate()) &&
                                        t.getEndDate().equals(tntrReq.getEndDate()) &&
                                        t.getEntity().equals(tntrReq.getEntity()) && t.getReportSubmissionType().equals(tntrReq.getReportSubmissionType()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getEntity() + " for " + request.getReportSubmissionType() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedCollateralForDateRange(requests, request.getRegulatoryName(), request.getRegulatoryAuthority()));
    }

    @Test
    public void replayBackdateCollateral_Mas() throws JsonProcessingException {
        List<ReplayCollateralForDateRange> requests = new ArrayList<>();
        ReplayCollateralForDateRange request = new ReplayCollateralForDateRange();
        request.setStartDate("2024-05-15");
        request.setEndDate("2024-05-16");
        request.setMasterAgreementId("masterAgreementId");
        request.setReportSubmissionType("TYPE");
        request.setEntity("PLC");
        request.setRegulatoryName(ReportingRegime.THE_MONETARY_AUTHORITY_OF_SINGAPORE);
        request.setRegulatoryAuthority(ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION);

        requests.add(request);

        List<String> idList = Arrays.asList(requests.get(0).getMasterAgreementId());

        TntrReplayCollateralForDateRangeRequest tntrReq = new TntrReplayCollateralForDateRangeRequest(
                requests.get(0).getStartDate(),
                requests.get(0).getEndDate(),
                requests.get(0).getReportSubmissionType(),
                requests.get(0).getEntity(),
                idList);

        String reUrl = reHost + masCol;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayCollateralForDateRangeRequest t = (TntrReplayCollateralForDateRangeRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getMasterAgreementIdList().containsAll(tntrReq.getMasterAgreementIdList()) &&
                                        t.getStartDate().equals(tntrReq.getStartDate()) &&
                                        t.getEndDate().equals(tntrReq.getEndDate()) &&
                                        t.getEntity().equals(tntrReq.getEntity()) && t.getReportSubmissionType().equals(tntrReq.getReportSubmissionType()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getEntity() + " for " + request.getReportSubmissionType() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayBackdatedCollateralForDateRange(requests, request.getRegulatoryName(), request.getRegulatoryAuthority()));
    }

    @Test
    public void corrective_For_Trade() {
        CorrectiveReportingForTrade request = getCrTradeAsPrimaryKey("Mis Reporting", "ForeignExchange", "SystemX");

        TntrCRTradeRequest tradeRequest = new TntrCRTradeRequest(request.getSourceSystem(), "username", "MIS_REPORTING");

        String reUrl = reHost + noaCrTrade;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrCRTradeRequest t = (TntrCRTradeRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                t.getSourceSystemId().equals(tradeRequest.getSourceSystemId()) &&
                                        t.getActionBy().equals(tradeRequest.getActionBy()) &&
                                        t.getReportingType().equals(tradeRequest.getReportingType());
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getRegime().value() + " for " + request.getAssetClass() + " was " + "Successful";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(res, replayService.replayCRTrades(request));
    }

    @Test
    public void corrective_For_Trade_For_Exception() {
        CorrectiveReportingForTrade request = getCrTradeAsPrimaryKey("Mis Reporting", "Exotic", "SystemX");

        TntrCRTradeRequest tradeRequest = new TntrCRTradeRequest(request.getSourceSystem(), "username", "MIS_REPORTING");

        String reUrl = reHost + noaCrTrade;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrCRTradeRequest t = (TntrCRTradeRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                t.getSourceSystemId().equals(tradeRequest.getSourceSystemId()) &&
                                        t.getActionBy().equals(tradeRequest.getActionBy()) &&
                                        t.getReportingType().equals(tradeRequest.getReportingType());
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getRegime().value() + " for " + request.getAssetClass() + " was submitted successfully";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenThrow(new ResourceAccessException("Timeout Occurred", new SocketTimeoutException("Read timed out")));

        Assert.assertEquals(res, replayService.replayCRTrades(request));
    }

    @Test
    public void corrective_For_Valuation() {
        CorrectiveReportingForValuation request = new CorrectiveReportingForValuation();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "InterestRate", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_VALUATION);
        request.setDataFetchFrom("CMG");

        TntrCRValuationRequest valuationRequest = new TntrCRValuationRequest(
                request.getPrimaryKey().getSourceSystem(),
                true,
                "username");

        String reUrl = reHost + noaCrValPath;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrCRValuationRequest t = (TntrCRValuationRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                t.getSourceSystem().equals(valuationRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(valuationRequest.getActionBy()) &&
                                        t.isUseCmgValuationData();
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getPrimaryKey().getRegime().value() + " for " + request.getPrimaryKey().getAssetClass() + " was " + "Successful";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(res, replayService.replayCRValuation(request));
    }

    @Test
    public void corrective_For_Valuation_DateRange() {
        CorrectiveReportingForValuation request = new CorrectiveReportingForValuation();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "InterestRate", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_VALUATION_DATE_RANGE);
        request.setValuationDateTo("2024-01-05");
        request.setValuationDateFrom("2024-01-01");
        request.setDataFetchFrom("Foundry");

        String baseUrl = reHost + noaCrValDR;

        String reUrl = UriComponentsBuilder.fromHttpUrl(baseUrl)
                .queryParam("sourceSystem", request.getPrimaryKey().getSourceSystem())
                .queryParam("useCmgValuationData", false)
                .queryParam("actionBy", "username")
                .queryParam("valuationDateFrom", request.getValuationDateFrom())
                .queryParam("valuationDateTo", request.getValuationDateTo())
                .build().encode().toUri().toString();
        System.out.println(reUrl);
        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getPrimaryKey().getRegime().value() + " for " + request.getPrimaryKey().getAssetClass() + " was " + "Successful";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(res, replayService.replayCRValuation(request));
    }

    @Test
    public void corrective_For_Valuation_DateRange_Ex() {
        CorrectiveReportingForValuation request = new CorrectiveReportingForValuation();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "InterestRate", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_VALUATION_DATE_RANGE);
        request.setValuationDateTo("2024-01-05");
        request.setValuationDateFrom("2024-01-01");
        request.setDataFetchFrom("Foundry");

        String baseUrl = reHost + noaCrValDR;

        String reUrl = UriComponentsBuilder.fromHttpUrl(baseUrl)
                .queryParam("sourceSystem", request.getPrimaryKey().getSourceSystem())
                .queryParam("useCmgValuationData", false)
                .queryParam("actionBy", "username")
                .queryParam("valuationDateFrom", request.getValuationDateFrom())
                .queryParam("valuationDateTo", request.getValuationDateTo())
                .build().encode().toUri().toString();
        System.out.println(reUrl);
        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getPrimaryKey().getRegime().value() + " for " + request.getPrimaryKey().getAssetClass() + " was submitted to RE Service";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenThrow(new RestClientException("Test"));

        Assert.assertEquals(res, replayService.replayCRValuation(request));
    }

    @Test
    public void corrective_For_collateral() {
        CorrectiveReportingForCollateral request = new CorrectiveReportingForCollateral();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "Collateral", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_COLLATERAL);
        request.setFlow("Collateral");
        request.setOverrideFields("field");

        String baseUrl = reHost + noaCrColPath;

        String reUrl = UriComponentsBuilder.fromHttpUrl(baseUrl)
                .queryParam("overrideField", request.getOverrideFields().trim())
                .build().encode().toUri().toString();

        System.out.println(reUrl);
        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getPrimaryKey().getRegime().value() + " for " + request.getPrimaryKey().getAssetClass() + " was " + "Successful";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(res, replayService.replayCRCollateral(request));
    }

    @Test
    public void corrective_For_collateral_DateRange() {
        CorrectiveReportingForCollateral request = new CorrectiveReportingForCollateral();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "Collateral", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_COLLATERAL_DATE_RANGE);
        request.setFlow("Collateral");
        request.setCollateralDateFrom("2024-01-01");
        request.setCollateralDateTo("2024-01-05");
        request.setOverrideFields("field");

        String baseUrl = reHost + noaCrMrColDR;

        String reUrl = UriComponentsBuilder.fromHttpUrl(baseUrl)
                .queryParam("overrideFields", request.getOverrideFields().trim())
                .queryParam("beginDate", request.getCollateralDateFrom())
                .queryParam("endDate", request.getCollateralDateTo())
                .build().encode().toUri().toString();

        System.out.println(reUrl);
        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getPrimaryKey().getRegime().value() + " for " + request.getPrimaryKey().getAssetClass() + " was " + "Successful";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(res, replayService.replayCRCollateral(request));
    }

    @Test
    public void corrective_For_collateral_Both_DateRange() {
        CorrectiveReportingForCollateral request = new CorrectiveReportingForCollateral();
        request.setPrimaryKey(getCrTradeAsPrimaryKey("Mis Reporting", "Collateral", "GDS GBLO"));
        request.getPrimaryKey().setAction(CRAction.CR_COLLATERAL_DATE_RANGE);
        request.setFlow("Transaction & Collateral");
        request.setCollateralDateFrom("2024-01-01");
        request.setCollateralDateTo("2024-01-05");
        request.setOverrideFields("");

        String baseUrl = reHost + noaCrMrColDR;

        String reUrl = UriComponentsBuilder.fromHttpUrl(baseUrl)
                .queryParam("beginDate", request.getCollateralDateFrom())
                .queryParam("endDate", request.getCollateralDateTo())
                .build().encode().toUri().toString();

        System.out.println(reUrl);
        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + request.getPrimaryKey().getRegime().value() + " for " + request.getPrimaryKey().getAssetClass() + " was " + "Successful";
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(res, replayService.replayCRCollateral(request));
    }

    @Test
    public void replayTradesForUpstream_EMIR_TMS_GBLO_Fx() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setAssetClass("ForeignExchange");
        replayTrade.setSourceSystemId("TMS GBLO");
        replayTrade.setRegime(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + upStreamTradeReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_EMIR_ICE() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setAssetClass("ForeignExchange");
        replayTrade.setSourceSystemId("ICE");
        replayTrade.setRegime(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + upStreamCreditReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_EMIR_ROLFE_NOLAN() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("Rolfe & Nolan");
        replayTrade.setRegime(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + etdTransaction;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_EMIR_GDS_USNY() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("GDS USNY");
        replayTrade.setRegime(ReportingRegime.EUROPEAN_MARKETS_INFRASTRUCTURE_REGULATION);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + emirTrade;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_DODD_FRANK_ACT_US_GDS_USNY() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("GDS USNY");
        replayTrade.setRegime(ReportingRegime.DODD_FRANK_ACT_US);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + upStreamTradeReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_CANADA_RULE_91_507_SYSTEM_X() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("SystemX");
        replayTrade.setRegime(ReportingRegime.CANADA_RULE_91_507);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + upStreamTradeReplay;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE_GDS_GBLO() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("GDS GBLO");
        replayTrade.setRegime(ReportingRegime.MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + mifidTrade;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE_GLOBAL_FX_GBLO() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("GlobalFX GBLO");
        replayTrade.setRegime(ReportingRegime.MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + mifidFx;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE_ICE() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("ICE");
        replayTrade.setRegime(ReportingRegime.MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + mifidCredit;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE_HERMES() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("Hermes");
        replayTrade.setRegime(ReportingRegime.MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + mifidTrade;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
                        boolean isBodyAsExpected =
                                (t.getTradeIds().containsAll(tntrReplayTradesRequest.getTradeIds()) &&
                                        t.getSourceSystem().equals(tntrReplayTradesRequest.getSourceSystem()) &&
                                        t.getActionBy().equals(tntrReplayTradesRequest.getActionBy()));
                        boolean isHeaderMediaTypeJson =
                                argument.getHeaders().getContentType().equals(MediaType.APPLICATION_JSON);
                        boolean headerHasApplicationSsoToken
                                = argument.getHeaders().get("sso-token").get(0).equals("ApplicationSsoToken");
                        return isBodyAsExpected
                                && isHeaderMediaTypeJson
                                && headerHasApplicationSsoToken;
                    }
                };

        ParameterizedTypeReference<List<String>> parameterizedTypeReference =
                new ParameterizedTypeReference<List<String>>() {
                };

        String res = "Request for " + replayTrade.getRegime().value() + " for " + replayTrade.getSourceSystemId() + " was " + "Successful";
        List<String> list = Arrays.asList(res);
        Mockito.when(
                        restTemplate.exchange(
                                Mockito.eq(reUrl),
                                Mockito.eq(HttpMethod.POST),
                                Mockito.argThat(httpEntityMatcher),
                                Mockito.any(parameterizedTypeReference.getClass())))
                .thenReturn(new ResponseEntity<String>(
                        res,
                        HttpStatus.OK));

        Assert.assertEquals(list, replayService.replayTradesForUpstream(requests, replayTrade.getRegime()));
    }

    @Test
    public void replayTradesForUpstream_MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE_IGNITE() throws JsonProcessingException {
        List<ReplayTrade> requests = new ArrayList<>();
        ReplayTrade replayTrade = new ReplayTrade();
        replayTrade.setTradeId("tradeId1");
        replayTrade.setSourceSystemId("Ignite");
        replayTrade.setRegime(ReportingRegime.MARKETS_IN_FINANCIAL_INSTRUMENTS_DIRECTIVE);
        replayTrade.setIsExoticTrade("false");
        replayTrade.setType("Transaction");

        requests.add(replayTrade);

        List<String> tradeIds = Arrays.asList(requests.get(0).getTradeId());
        TntrReplayTradesRequest tntrReplayTradesRequest = new TntrReplayTradesRequest(tradeIds, requests.get(0).getSourceSystemId(), "username");
        String reUrl = reHost + mifidTrade;

        ArgumentMatcher<HttpEntity> httpEntityMatcher =
                new ArgumentMatcher<HttpEntity>() {
                    @Override
                    public boolean matches(Object o) {
                        HttpEntity argument = (HttpEntity) o;
                        TntrReplayTradesRequest t = (TntrReplayTradesRequest) argument.getBody();
