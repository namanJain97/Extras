import static org.junit.Assert.*;
import java.io.File;
import java.util.*;
import java.util.concurrent.BlockingQueue;
import com.google.common.collect.Lists;
import com.nwm.tntr.domain.email.EmailContent;
import com.rbs.datafabric.api.PagedScanResult;
import com.rbs.datafabric.api.ScanException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.tntr.business.blotter.search.querybuilder.DfExportScan;
import com.rbs.tntr.business.blotter.search.querybuilder.DfScanParameters;
import com.rbs.tntr.business.blotter.search.querybuilder.LoggedInUserDetails;
import com.rbs.tntr.business.blotter.services.jobs.DfExportJob;
import com.rbs.tntr.business.blotter.utility.BlotterUtil;
import org.apache.commons.io.FileUtils;
import org.joda.time.DateTime;
import org.junit.Test;
import org.mockito.Mockito;
import org.springframework.test.util.ReflectionTestUtils;
import static org.mockito.Mockito.mockStatic;

@Test
public void testCalculateThresholdCount_MultipleCollections() throws Exception {
    List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Transaction"), createParam("Valuation"));
    String userName = "testUser";
    String totalCountJson1 = "{\"totalCount\": 100}";
    String totalCountJson2 = "{\"totalCount\": 200}";
    PagedScanResult pagedScan1 = new PagedScanResult(getMockRecords(Lists.newArrayList(totalCountJson1)), true, "scanId1", 1);
    PagedScanResult pagedScan2 = new PagedScanResult(getMockRecords(Lists.newArrayList(totalCountJson2)), true, "scanId2", 1);
    Mockito.when(client.pagedScan(Mockito.any())).thenReturn(pagedScan1, pagedScan2);
    int totalCount = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateThresholdCount", scanParamList, userName);
    assertEquals(300, totalCount);
}

@Test
public void testCalculateThresholdCount_WithRetry() throws Exception {
    List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Transaction"));
    String userName = "testUser";
    String totalCountJson = "{\"totalCount\": 100}";
    PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(totalCountJson)), true, "scanId", 1);
    Mockito.when(client.pagedScan(Mockito.any()))
           .thenThrow(new ScanException("Test exception"))
           .thenReturn(pagedScan);
    int totalCount = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateThresholdCount", scanParamList, userName);
    assertEquals(100, totalCount);
    Mockito.verify(client, Mockito.times(2)).pagedScan(Mockito.any());
}

@Test
public void testModifyFileName() throws Exception {
    List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Reconciliation"));
    String fileName = "originalFileName";
    String reconDataJson = "{\"identifier\": \"ReconId\", \"reconciliationBusinessDateTime\": \"2023-01-01T00:00:00.000Z\"}";
    PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(reconDataJson)), true, "scanId", 1);
    Mockito.when(client.pagedScan(Mockito.any())).thenReturn(pagedScan);
    String modifiedFileName = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "modifyFileName", scanParamList, fileName);
    assertEquals("ReconId_2023-01-01_originalFileName", modifiedFileName);
}

@Test
public void testModifyFileName_NoData() throws Exception {
    List<DfScanParameters> scanParamList = Lists.newArrayList(createParam("Reconciliation"));
    String fileName = "originalFileName";
    PagedScanResult pagedScan = new PagedScanResult(Lists.newArrayList(), true, "scanId", 1);
    Mockito.when(client.pagedScan(Mockito.any())).thenReturn(pagedScan);
    String modifiedFileName = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "modifyFileName", scanParamList, fileName);
    assertEquals("", modifiedFileName);
}

@Test
public void testGenerateScanRequestId() {
    String userName = "testUser";
    String scanId = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateScanRequestId", userName);
    assertTrue(scanId.startsWith("testUser_scan_req_id_"));
}

@Test
public void testUpdateFailedScan() {
    String scanId = "testScanId";
    String status = "FAILED";
    String remarks = "Test failure";
    DfExportScan scan = createScan(scanId, "Transaction", "testUser");
    Mockito.when(exportRepo.fetchDfScanById(scanId)).thenReturn(scan);
    Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "updateFailedScan", scanId, status, remarks);
    Mockito.verify(exportRepo).upsertDfScan(Mockito.argThat(updatedScan ->
        updatedScan.getExecutionStatus().equals("FAILED") &&
        updatedScan.getRemarks().equals("Test failure") &&
        updatedScan.getExportLocation().isEmpty() &&
        updatedScan.getExportName().isEmpty() &&
        updatedScan.getExportRecordCount() == 0 &&
        updatedScan.getExecutionTime().isEmpty()
    ));
}

@Test
public void testGenerateAsOfFromScan() {
    String asOf = "2023-01-01T00:00:00.000Z";
    long millis = (long) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateAsOfFromScan", asOf);
    assertEquals(dateTimeService.parseDateTime("2023-01-01T00:00:00.000Z").getMillis(), millis);
}

@Test
public void testPopulateDynamicDate() {
    String clause = "nonReportableData.tntrReceivedTimestamp >= {T-3}";
    String updatedClause = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateDynamicDate", clause);
    String expectedDate = "'" + dateTimeService.asString(dateTimeService.getPastDateTime(dateTimeService.getCurrentStartDateTime(dateTimeService.getCurrentUTCDateTime()), 3)) + "'";
    assertTrue(updatedClause.contains(expectedDate));
}

@Test
public void testResumeInQueueScans() {
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    scan.setExecutionStatus("IN QUEUE");
    Mockito.when(exportRepo.fetchScansWithStatus("IN QUEUE")).thenReturn(Lists.newArrayList(scan));
    Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "resumeInQueueScans");
    Mockito.verify(exportRepo).fetchScansWithStatus("IN QUEUE");
}

@Test
public void testResumeInQueueScansAtStartup() {
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    scan.setExecutionStatus("IN QUEUE");
    Mockito.when(exportRepo.fetchScansWithStatus("IN QUEUE")).thenReturn(Lists.newArrayList(scan));
    Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "resumeInQueueScansAtStartup");
    Mockito.verify(exportRepo).fetchScansWithStatus("IN QUEUE");
}

@Test
public void testPopulateEmailNotification() {
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    scan.setBlotterName("TestBlotter");
    scan.setLastExecutionDateTime("2023-01-01 00:00:00");
    scan.setExportRecordCount(100);
    scan.setExecutionTime("10");
    scan.setExportName("exportFile");
    LoggedInUserDetails userDetails = new LoggedInUserDetails();
    userDetails.setName("Test User");
    userDetails.setEmail("test@example.com");
    try (MockedStatic<BlotterUtil> mocked = mockStatic(BlotterUtil.class)) {
        mocked.when(() -> BlotterUtil.getLoggedInUserDetails("testUser")).thenReturn(userDetails);
        EmailContent emailContent = (EmailContent) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateEmailNotification", scan);
        assertEquals("Blotter Export Notification", emailContent.getSubject());
        assertTrue(emailContent.getBody().contains("Dear Test User,"));
        assertTrue(emailContent.getBody().contains("Export triggered from TestBlotter completed successfully at 2023-01-01 00:00:00"));
        assertTrue(emailContent.getBody().contains("Total 100 records were exported & export took 10 seconds to complete."));
    }
}

@Test
public void testPopulateEmailWithAttachment() {
    DfExportScan scan = createScan("scanId", "CONTROL_MI", "MI_EXTRACT");
    scan.setExportName("miExport");
    scan.setExportRecordCount(50);
    ReflectionTestUtils.setField(dataFabricExportServiceImpl, "miReceiverEmail", "receiver@example.com");
    ReflectionTestUtils.setField(dataFabricExportServiceImpl, "emailFrom", "from@example.com");
    ReflectionTestUtils.setField(dataFabricExportServiceImpl, "smtpHost", "smtp.example.com");
    EmailContent emailContent = (EmailContent) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateEmailWithAttachment", scan);
    assertEquals("Blotter Export Notification", emailContent.getSubject());
    assertTrue(Arrays.asList(emailContent.getEmailTo()).contains("receiver@example.com"));
    assertTrue(emailContent.getBody().contains("Export for CONTROL MI was successful"));
}

@Test
public void testFetchCsvRecords_EmptyHeaders() {
    Set<String> headers = new TreeSet<>();
    try {
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "fetchCsvRecords", Lists.newArrayList(), headers, false);
        fail("Expected ValidationException");
    } catch (Exception e) {
        assertTrue(e.getCause() instanceof ValidationException);
    }
}

@Test
public void testFetchCsvRecords_Append() {
    Set<String> headers = Sets.newHashSet("header1", "header2");
    Map<String, String> record = new HashMap<>();
    record.put("header1", "value1");
    List<Map<String, String>> records = Lists.newArrayList(record);
    List<String[]> result = (List<String[]>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "fetchCsvRecords", records, headers, true);
    assertEquals(1, result.size());
    assertArrayEquals(new String[]{"value1", ""}, result.get(0));
}

@Test
public void testDeleteIncompleteExportFile() {
    String fileName = "testFile";
    String csvOutputFile = "c://Export/" + dateTimeService.getUTCDateAsString(dateTimeService.getCurrentUTCDateTime()) + "/" + fileName + ".csv";
    File mockFile = Mockito.mock(File.class);
    Mockito.when(mockFile.exists()).thenReturn(true);
    try (MockedStatic<FileUtils> mocked = mockStatic(FileUtils.class)) {
        mocked.when(() -> FileUtils.deleteQuietly(Mockito.any(File.class))).thenReturn(true);
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "deleteIncompleteExportFile", fileName);
    }
}

@Test
public void testDeleteIncompleteZipFile() {
    String zippedFile = "testFile.zip";
    File mockFile = Mockito.mock(File.class);
    Mockito.when(mockFile.exists()).thenReturn(true);
    try (MockedStatic<FileUtils> mocked = mockStatic(FileUtils.class)) {
        mocked.when(() -> FileUtils.deleteQuietly(Mockito.any(File.class))).thenReturn(true);
        ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "deleteIncompleteZipFile", zippedFile);
    }
}

@Test
public void testZipExportFile() throws Exception {
    String fileName = "testFile";
    String sourceFile = "c://Export/" + dateTimeService.getUTCDateAsString(dateTimeService.getCurrentUTCDateTime()) + "/" + fileName + ".csv";
    String outputZippedFile = "c://Export/" + dateTimeService.getUTCDateAsString(dateTimeService.getCurrentUTCDateTime()) + "/" + fileName + ".zip";
    File mockFile = new File(sourceFile);
    if (!mockFile.exists()) {
        mockFile.createNewFile();
    }
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "zipExportFile", fileName);
    assertTrue(new File(outputZippedFile).exists());
    mockFile.delete();
    new File(outputZippedFile).delete();
}

@Test
public void testExportDataToFile() throws Exception {
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    Set<String> headers = Sets.newHashSet("header1");
    String fileName = "testFile";
    List<Record> records = getMockRecords(Lists.newArrayList("{\"header1\": \"value1\"}"));
    Mockito.when(dataFabricExportUtil.convertScannedRecords(records, "Transaction", scan)).thenReturn(Lists.newArrayList(new HashMap<String, String>() {{ put("header1", "value1"); }}));
    Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(true);
    int count = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "exportDataToFile", scan, headers, fileName, "Transaction", records);
    assertEquals(1, count);
}

@Test
public void testWriteDataToFile_MI() throws Exception {
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    String fileName = "MI_testFile";
    List<String[]> rows = Lists.newArrayList(new String[]{"header1"}, new String[]{"value1"});
    Mockito.when(csvWriter.generateCsvFile(rows, Mockito.anyString(), Mockito.anyString())).thenReturn(true);
    boolean result = (boolean) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "writeDataToFile", scan, fileName, rows);
    assertTrue(result);
}

@Test
public void testGenerateOutputFileName() {
    String fileName = "testFile";
    String ext = "csv";
    String expected = "c://Export/" + dateTimeService.getUTCDateAsString(dateTimeService.getCurrentUTCDateTime()) + "/" + fileName + ".csv";
    String result = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateOutputFileName", fileName, ext);
    assertEquals(expected, result);
}

@Test
public void testGenerateOutputFileName_MI() {
    String fileName = "MI_testFile";
    String ext = "zip";
    String expected = "c://Export/" + dateTimeService.getUTCDateAsString(dateTimeService.getCurrentUTCDateTime()) + "/mi_folder/" + fileName + ".zip";
    String result = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "generateOutputFileName", fileName, ext);
    assertEquals(expected, result);
}

@Test
public void testCalculateNextRun_Daily() {
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    scan.setScheduled(true);
    scan.setScheduleFrequency("DAILY");
    scan.setNextRunDateTime(DateTime.now().toString());
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateNextRun", scan);
    assertEquals(dateTimeService.addDays(DateTime.now().toString(), 1), scan.getNextRunDateTime());
}

@Test
public void testPopulateNextRunDate() throws Exception {
    String scanTime = "11:00 PM";
    Date result = (Date) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateNextRunDate", scanTime);
    assertNotNull(result);
}

@Test
public void testProcessSnapshotPreviousCat() {
    Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
    Map<String, String> noneMap = new HashMap<>();
    noneMap.put("Jurisdiction", "TestJurisdiction");
    noneMap.put("Flow", "TestFlow");
    noneMap.put("previousDayCAT", "100");
    noneMap.put("previousDayReportable", "200");
    assetWiseMap.put("NONE", noneMap);
    String metric = "CAT Previous Day";
    List<Map<String, String>> result = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "processSnapshotPreviousCat", assetWiseMap, metric);
    assertEquals(1, result.size());
    Map<String, String> record = result.get(0);
    assertEquals("CAT Previous Day", record.get("Metrics"));
    assertEquals("100", record.get("Record Count"));
    assertEquals("50.0%", record.get("Percent"));
}

@Test
public void testProcessSnapshotMetric() {
    Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
    Map<String, String> noneMap = new HashMap<>();
    noneMap.put("Jurisdiction", "TestJurisdiction");
    noneMap.put("Flow", "TestFlow");
    noneMap.put("Reportable", "200");
    noneMap.put("Accurate", "100");
    assetWiseMap.put("NONE", noneMap);
    List<Map<String, String>> result = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "processSnapshotMetric", assetWiseMap, "Accurate", "Reportable");
    assertEquals(1, result.size());
    assertEquals("Accurate", result.get(0).get("Metrics"));
    assertEquals("50.0%", result.get(0).get("Percent"));
}

@Test
public void testProcessKnownUnknownMetric() {
    Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
    Map<String, String> noneMap = new HashMap<>();
    noneMap.put("Jurisdiction", "TestJurisdiction");
    noneMap.put("Flow", "TestFlow");
    noneMap.put("Reportable", "200");
    noneMap.put("misReportedKnown", "50");
    noneMap.put("misReportedUnKnown", "30");
    assetWiseMap.put("NONE", noneMap);
    List<Map<String, String>> result = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "processKnownUnknownMetric", assetWiseMap, "Mis-reported", "Reportable", "misReported");
    assertEquals(1, result.size());
    assertEquals("Mis-reported", result.get(0).get("Metrics"));
    assertEquals("80", result.get(0).get("Record Count"));
    assertEquals("50", result.get(0).get("Known Breaks"));
    assertEquals("30", result.get(0).get("Unknown Breaks"));
}

@Test
public void testGetAssetClassCsvName() {
    assertEquals("FX", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "ForeignExchange"));
    assertEquals("Rates", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "InterestRate"));
    assertEquals("NONE", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "Unknown"));
}

@Test
public void testGetTotalFromMap() {
    Map<String, Map<String, String>> assetWiseMap = new HashMap<>();
    Map<String, String> fxMap = new HashMap<>();
    fxMap.put("Reportable", "100");
    Map<String, String> ratesMap = new HashMap<>();
    ratesMap.put("Reportable", "200");
    assetWiseMap.put("ForeignExchange", fxMap);
    assetWiseMap.put("InterestRate", ratesMap);
    List<String> assetClasses = Lists.newArrayList("ForeignExchange", "InterestRate");
    int total = (int) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getTotalFromMap", assetWiseMap, "Reportable", assetClasses);
    assertEquals(300, total);
}

@Test
public void testGetPercentMetric() {
    assertEquals("50.0", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getPercentMetric", "100", 200));
    assertEquals("0.0", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getPercentMetric", "0", 0));
}

@Test
public void testGetOverReportedPercent() {
    assertEquals("25.0", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getOverReportedPercent", "50.0", 100, 200));
    assertEquals("0.0", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getOverReportedPercent", "0.0", 0, 0));
}

@Test
public void testBifurcateKnownRecords() {
    Map<String, String> record1 = new HashMap<>();
    record1.put("Jira", "JIRA-1,JIRA-2");
    record1.put("Asset Class Final", "FX");
    record1.put("Execution Entity Final", "Entity1");
    record1.put("Delegated", "Yes");
    record1.put("Regulator", "Reg1");
    record1.put("Message Type", "Type1");
    record1.put("Count", "10");
    List<Map<String, String>> parsedRecordsList = Lists.newArrayList(record1);
    List<Map<String, String>> bifurcatedList = (List<Map<String, String>>) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "bifurcateKnownRecords", parsedRecordsList);
    assertEquals(2, bifurcatedList.size());
}

@Test
public void testPopulateBifurcationKey() {
    String jiraId = "JIRA-1";
    Map<String, String> knownMap = new HashMap<>();
    knownMap.put("Asset Class Final", "FX");
    knownMap.put("Execution Entity Final", "Entity1");
    knownMap.put("Delegated", "Yes");
    knownMap.put("Regulator", "Reg1");
    knownMap.put("Message Type", "Type1");
    String key = (String) ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateBifurcationKey", jiraId, knownMap);
    assertEquals("JIRA-1FXEntity1YesReg1Type1", key);
}

@Test
public void testStartScheduledJob() throws InterruptedException {
    BlockingQueue<DfExportJob> queue = (BlockingQueue<DfExportJob>) ReflectionTestUtils.getField(dataFabricExportServiceImpl, "queue");
    DfExportScan scan = createScan("scanId", "Transaction", "testUser");
    DfExportJob job = new DfExportJob(Lists.newArrayList(createParam("Transaction")), "testUser", true, scan, "testFile");
    queue.put(job);
    Mockito.when(exportRepo.upsertDfScan(Mockito.any(DfExportScan.class))).thenReturn(getRecordId(scan));
    Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(Lists.newArrayList(new HashMap<String, String>()));
    Mockito.when(csvWriter.generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(true);
    Thread thread = (Thread) ReflectionTestUtils.getField(dataFabricExportServiceImpl, "thread");
    assertTrue(thread.isAlive());
    queue.take();
}
