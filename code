package com.rbs.tntr.business.blotter.services.common;

import com.nwm.tntr.commons.core.SpringContext;
import com.nwm.tntr.commons.enums.ApiQueryFilter;
import com.nwm.tntr.commons.repository.collateral.CollateralTdxRepository;
import com.nwm.tntr.commons.repository.recon.ReconTdxRepository;
import com.nwm.tntr.commons.repository.reconBatchTrigger.ReconBatchTriggerRepository;
import com.nwm.tntr.commons.repository.service.tdx.TdxService;
import com.nwm.tntr.commons.repository.trade.TradeTdxRepository;
import com.nwm.tntr.commons.repository.trade.ValuationsTdxRepository;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.tntr.business.blotter.services.reconciliationActions.ReconciliationActionService;
import com.rbs.tntr.business.blotter.web.request.futures.FuturesDashboardSearchRequest;
import com.rbs.tntr.domain.blotter.enums.FlowType;
import com.tdx.client.api.exception.TDXClientFactoryException;
import com.tdx.client.api.exception.TDXException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.context.ApplicationContext;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class TdxFacadeTest {

    @Mock
    private ReconTdxService reconTdxService;
    @Mock
    private ReconBatchTriggerRepository reconBatchTriggerRepository;
    @Mock
    private ReconciliationActionService reconciliationActionService;
    @Mock
    private ApplicationContext mockApplicationContext;
    @Mock
    private ReconTdxRepository mockReconTdxRepository;
    @Mock
    private CollateralTdxRepository mockCollateralTdxRepository;
    @Mock
    private ValuationsTdxRepository mockValuationsTdxRepository;
    @Mock
    private TradeTdxRepository mockTradeTdxRepository;
    @Mock
    private TdxService mockTdxService;

    @InjectMocks
    private TdxFacade tdxFacade;

    private ApplicationContext originalApplicationContext;

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        
        // Save original ApplicationContext
        originalApplicationContext = getStaticField(SpringContext.class, "applicationContext");
        
        // Setup mock repositories
        when(mockReconTdxRepository.getTdxService()).thenReturn(mockTdxService);
        when(mockCollateralTdxRepository.getTdxService()).thenReturn(mockTdxService);
        when(mockValuationsTdxRepository.getTdxService()).thenReturn(mockTdxService);
        when(mockTradeTdxRepository.getTdxService()).thenReturn(mockTdxService);
        
        // Setup mock ApplicationContext
        when(mockApplicationContext.getBean(ReconTdxRepository.class)).thenReturn(mockReconTdxRepository);
        when(mockApplicationContext.getBean(CollateralTdxRepository.class)).thenReturn(mockCollateralTdxRepository);
        when(mockApplicationContext.getBean(ValuationsTdxRepository.class)).thenReturn(mockValuationsTdxRepository);
        when(mockApplicationContext.getBean(TradeTdxRepository.class)).thenReturn(mockTradeTdxRepository);
        
        // Inject mock ApplicationContext into SpringContext
        setStaticField(SpringContext.class, "applicationContext", mockApplicationContext);
    }

    @After
    public void tearDown() throws Exception {
        // Restore original ApplicationContext
        setStaticField(SpringContext.class, "applicationContext", originalApplicationContext);
    }

    // Helper methods for reflection
    private void setStaticField(Class<?> clazz, String fieldName, Object value) throws Exception {
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(null, value);
    }

    private <T> T getStaticField(Class<?> clazz, String fieldName) throws Exception {
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);
        return (T) field.get(null);
    }

    // Test Cases

    @Test
    public void testReconBatchTriggerFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONC_BATCH_TRIGGER);
        request.setRowLimit(10);
        request.setAsOf("2023-01-01");

        List<HashMap> expected = Collections.singletonList(new HashMap());
        when(reconBatchTriggerRepository.getReconBatchByCriteria(
            request.getWhereClause(),
            request.getGroupByClause(),
            null,
            request.isHistory(),
            request.getRowLimit()
        )).thenReturn(expected);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertSame(expected, result);
    }

    @Test
    public void testReconciliationFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        request.setRowLimit(10);
        request.setAsOf("2023-01-01");

        List<HashMap> expected = Collections.singletonList(new HashMap());
        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(eq("ReconDataSet"), any(EnumMap.class)))
            .thenReturn(expected);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertSame(expected, result);
    }

    @Test
    public void testReconciliationDfFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION_DF);
        List<HashMap> expected = Collections.singletonList(new HashMap());
        when(reconciliationActionService.executeReadCommand(request)).thenReturn(expected);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertSame(expected, result);
    }

    @Test
    public void testCollateralFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.COLLATERAL);
        List<HashMap> expected = Collections.singletonList(new HashMap());
        when(mockCollateralTdxRepository.getTdxDataSetName()).thenReturn("CollateralDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(eq("CollateralDataSet"), any(EnumMap.class)))
            .thenReturn(expected);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertSame(expected, result);
    }

    @Test
    public void testValuationFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.VALUATION);
        List<HashMap> expected = Collections.singletonList(new HashMap());
        when(mockValuationsTdxRepository.getTdxDataSetName()).thenReturn("ValuationsDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(eq("ValuationsDataSet"), any(EnumMap.class)))
            .thenReturn(expected);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertSame(expected, result);
    }

    @Test
    public void testDefaultTradeFlow() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.TRADE); // Unhandled flow
        List<HashMap> expected = Collections.singletonList(new HashMap());
        when(mockTradeTdxRepository.getTdxDataSetName()).thenReturn("TradeDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(eq("TradeDataSet"), any(EnumMap.class)))
            .thenReturn(expected);

        List<HashMap> result = tdxFacade.executeReadCommand(request);
        assertSame(expected, result);
    }

    @Test
    public void testRowLimitNotSetWhenZero() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        request.setRowLimit(0); // Should not be added to filter map

        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenReturn(Collections.singletonList(new HashMap()));

        tdxFacade.executeReadCommand(request);

        ArgumentCaptor<EnumMap<ApiQueryFilter, Object>> captor = ArgumentCaptor.forClass(EnumMap.class);
        verify(mockTdxService).getDocumentByTdxServiceWithGroupBy(anyString(), captor.capture());
        assertFalse(captor.getValue().containsKey(ApiQueryFilter.ROW_LIMIT));
    }

    @Test
    public void testAsOfNotSetWhenBlank() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        request.setAsOf(""); // Blank, should not be added

        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenReturn(Collections.singletonList(new HashMap()));

        tdxFacade.executeReadCommand(request);

        ArgumentCaptor<EnumMap<ApiQueryFilter, Object>> captor = ArgumentCaptor.forClass(EnumMap.class);
        verify(mockTdxService).getDocumentByTdxServiceWithGroupBy(anyString(), captor.capture());
        assertFalse(captor.getValue().containsKey(ApiQueryFilter.AS_OF));
    }

    @Test(expected = TDXException.class)
    public void testTdxException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenThrow(new TDXException("Error"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = TDXClientFactoryException.class)
    public void testTdxClientFactoryException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenThrow(new TDXClientFactoryException("Error"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = IOException.class)
    public void testIOException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenThrow(new IOException("Error"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = StartableException.class)
    public void testStartableException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenThrow(new StartableException("Error"));

        tdxFacade.executeReadCommand(request);
    }

    @Test(expected = ScanException.class)
    public void testScanException() throws Exception {
        FuturesDashboardSearchRequest request = createRequest(FlowType.RECONCILIATION);
        when(mockReconTdxRepository.getTdxDataSetName()).thenReturn("ReconDataSet");
        when(mockTdxService.getDocumentByTdxServiceWithGroupBy(anyString(), any(EnumMap.class)))
            .thenThrow(new ScanException("Error"));

        tdxFacade.executeReadCommand(request);
    }

    // Helper to create request with minimal params
    private FuturesDashboardSearchRequest createRequest(FlowType flowType) {
        FuturesDashboardSearchRequest request = new FuturesDashboardSearchRequest();
        request.setFlow(flowType.getValue());
        request.setSelectClause("SELECT");
        request.setWhereClause("WHERE");
        request.setGroupByClause("GROUP BY");
        request.setHistory(true);
        return request;
    }
}
