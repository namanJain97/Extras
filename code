Could you write all the additional test cases for below java class to cover all the remaining scenarios or methods and make the test coverage or code coverage as 100% using junit 4 and old mockito version and java 8. Also don't use power mockito as i m using older mockito version and for private methods try to use reflection. Plus we can't change any file other than the above test class. 

package com.rbs.tntr.business.blotter.services.actions;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.TNTRApplication;
import com.nwm.tntr.commons.domain.persistence.constant.UserActionType;
import com.nwm.tntr.commons.domain.persistence.entity.DocumentId;
import com.nwm.tntr.commons.domain.persistence.entity.ExceptionManagement;
import com.nwm.tntr.commons.domain.persistence.entity.NonReportableData;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.rbs.tntr.business.blotter.df.manager.DfTradePersistManager;
import com.rbs.tntr.business.blotter.df.updater.TradeDataUpdater;
import com.rbs.tntr.business.blotter.services.validators.ActionRequestValidator;
import com.rbs.tntr.domain.blotter.enums.ExceptionStatus;
import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;
import com.rbs.tntr.domain.blotter.exceptions.DfRunTimeException;
import com.rbs.tntr.domain.blotter.tntrBlotterView.ActionDocumentId;

@Service
public class TradeActionService {
    private final Logger logger = LoggerFactory.getLogger(TradeActionService.class);

    private static final String UPDATE_ERROR = "Error updating trade record : ";
    public static final String CANCEL_TRADE_ACKED_ERROR = "Cancelling Trade version is not in Acked state.";
    public static final String TRANSACTION = "Transaction";

    private final DfTradePersistManager dfTradePersistManager;
    private final TradeDataUpdater dataUpdater;
    private final ActionRequestValidator requestValidator;

    @Autowired
    public TradeActionService(DfTradePersistManager dfTradePersistManager, TradeDataUpdater dataUpdater, ActionRequestValidator requestValidator) {
        this.dfTradePersistManager = dfTradePersistManager;
        this.dataUpdater = dataUpdater;
        this.requestValidator = requestValidator;
    }

    public List<ActionUpdateResult> addComment(List<AddTradeCommentRequest> requests, String userName) {
        if (requests.isEmpty()) {
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();

        try {
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithComments(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }
    
    public List<ActionUpdateResult> removeComment(List<AddTradeCommentRequest> requests, String userName) {
        if (requests.isEmpty()) {
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();

        try {
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithRemovedComments(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> getTradeWithComments(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentRequest addTradeCommentRequest = (AddTradeCommentRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addCommentsToException(addTradeCommentRequest,
                            tradeReport.getExceptionManagement(), userName);
                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }
    
    protected List<Pair<TradeReport, Long>> getTradeWithRemovedComments(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentRequest addTradeCommentRequest = (AddTradeCommentRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.removeCommentsToException(addTradeCommentRequest,
                            tradeReport.getExceptionManagement(), userName);
                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> addCommentType(List<AddTradeCommentTypeRequest> requests, String userName) {
        if (requests.isEmpty()) {
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();

        try {
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithCommentType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> getTradeWithCommentType(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentTypeRequest addTradeCommentTypeRequest = (AddTradeCommentTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.addCommentTypeToException(addTradeCommentTypeRequest,
                            tradeReport.getExceptionManagement(), userName);
                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeCommentType(List<AddTradeCommentTypeRequest> requests, String userName) {
        if (requests.isEmpty()) {
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();

        try {
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithRemovedCommentType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> getTradeWithRemovedCommentType(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeCommentTypeRequest addTradeCommentTypeRequest = (AddTradeCommentTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                    ExceptionManagement exceptionManagement = dataUpdater.removeCommentTypeToException(addTradeCommentTypeRequest,
                            tradeReport.getExceptionManagement(), userName);
                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating comments in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
        }
    }

    private TradeReport getTradeReport(TradeReport tradeReport, ExceptionManagement exceptionManagement) {
        return TradeReport.newBuilder(tradeReport)
                .withExceptionManagement(exceptionManagement)
                .withNonReportableData(NonReportableData.newBuilder(tradeReport.getNonReportableData())
                                .withUpdatedByApplication(TNTRApplication.BLOTTER_SERVICE)
                                .build())
                .build();
    }

    private Pair<TradeReport, Long> getReportsWithExpectedBaseVersion(TradeReportDocument tradeReportDocument, TradeReport tradeReport) {
        return Pair.of(tradeReport, tradeReportDocument.getDocumentId().getVersion());
    }

    private List<TradeReportDocument> getTradeReportDocuments(List<DocumentId> documentIds) throws DfRunTimeException {
        return dfTradePersistManager.getAllRecordsById(documentIds);
    }

    private List<ActionUpdateResult> saveAllRecords(List<TradeReportDocument> tradeReportDocuments, List<Pair<TradeReport, Long>> tradeReports) {
        List<WriteResult<TradeReport>> writeResults =  dfTradePersistManager.saveAllRecords(tradeReports);
        List<ActionUpdateResult> result = getResult(tradeReportDocuments, writeResults);
        return result;
    }

	private List<ActionUpdateResult> upsertAllRecords(List<TradeReportDocument> tradeReportDocuments,
			List<TradeReport> tradeReports) {
		List<WriteResult<TradeReport>> writeResults = dfTradePersistManager.upsertAllRecords(tradeReports);
		List<ActionUpdateResult> result = getResult(tradeReportDocuments, writeResults);
		return result;
	}

    private List<ActionUpdateResult> getResult(List<TradeReportDocument> tradeReportDocuments, List<WriteResult<TradeReport>> writeResults) {
        List<ActionUpdateResult> results = Lists.newArrayList();
        if(writeResults != null) {
            for (int i = 0; i < writeResults.size(); i++) {
                if (writeResults.get(i).isSuccess()) {
                    results.add(ActionUpdateResult.createSuccess(getTradePrimaryKey(tradeReportDocuments.get(i).getDocumentId()), writeResults.get(i).getDocumentId().getKey(), writeResults.get(i).getDocumentId().getVersion()));
                } else {
                    String error = writeResults.get(i).getErrorDetail().getCause() != null
                            ? writeResults.get(i).getErrorDetail().getDescription() + ". " + writeResults.get(i).getErrorDetail().getCause().getMessage()
                            : writeResults.get(i).getErrorDetail().getDescription();
                    logger.error("Error occured in persisting Trade key : [{}], version : [{}] Reason : [{}]", tradeReportDocuments.get(i).getDocumentId().getKey(), tradeReportDocuments.get(i).getDocumentId().getVersion(), error);
                    results.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocuments.get(i).getDocumentId()), error));
                }
            }
        }

        return results;
    }

    protected void populateTradeRequestMap(UpdateRequest updateRequest, Map<DocumentId, UpdateRequest> map) {
        ActionDocumentId docId = updateRequest.getDocumentId();
        DocumentId documentId = DocumentId.from(docId.getKey(), docId.getVersion());

        map.put(documentId, updateRequest);
    }

    private ActionDocumentId getTradePrimaryKey(DocumentId documentId) {
        return new ActionDocumentId(documentId.getKey(), documentId.getVersion());
    }

	public List<ActionUpdateResult> updateEditedFields(List<EditRequest> requests, String userName,
			ExceptionStatus exceptionStatus) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();

            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
				List<Pair<TradeReport, Long>> tradeReports = editFields(tradeReportDocuments, tradeRequestMap,
						writeResults, userName, exceptionStatus);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

	protected List<Pair<TradeReport, Long>> editFields(List<TradeReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName,
			ExceptionStatus exceptionStatus) {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    try {
                        EditRequest editRequest = (EditRequest) requests.get(tradeReportDocument.getDocumentId());

						TradeReport tradeRepo = dataUpdater.updateTradeReportData(editRequest, tradeReport, userName,
								exceptionStatus);
                        reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                    } catch (BlotterRunTimeException e) {
                        failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), e.getMessage()));
                        logger.error("Trade edit failed for key : [{}], version : [{}], reason : [{}]",tradeReportDocument.getDocumentId().getKey(), tradeReportDocument.getDocumentId().getVersion(), e.getMessage(), e);
                    }
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while editing trades. ", e);
            throw new BlotterRunTimeException("Error occured while editing trades. "+e.getMessage(), e);
        }
    }

    public List<ActionUpdateResult> updateExceptionStatus(List<UpdateExceptionStatusRequest> requests, ExceptionStatus requestedExceptionStatus, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try {


            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validatePermittedExceptionStatus(tradeReportDocuments, writeResults, requestedExceptionStatus);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithExceptionStatus(tradeReportDocuments, requestedExceptionStatus, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

			if (ExceptionStatus.Edit_Rejected.equals(requestedExceptionStatus)) {
				writeResults = rollBackRejectedRecords(tradeRequestMap);
			}

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            writeResults.addAll(getTradeUpdateResultOnError(requests, e.getMessage()));
            return writeResults;
        }
    }
    
    public List<ActionUpdateResult> performResetAction(List<UpdateExceptionStatusRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        List<ActionUpdateResult> writeResults = Lists.newArrayList();
        try {

            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = resetActionOnTrade(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            writeResults.addAll(getTradeUpdateResultOnError(requests, e.getMessage()));
            return writeResults;
        }
    }

	private List<ActionUpdateResult> rollBackRejectedRecords(Map<DocumentId, UpdateRequest> tradeRequestMap) {
		logger.info("Rolling back records to previous version due to rejection");
		List<ActionUpdateResult> writeResults = Lists.newArrayList();
		List<DocumentId> documentIds = Lists.newArrayList();
		tradeRequestMap.keySet().forEach(documentId -> {
			documentIds.add(DocumentId.from(documentId.getKey(), (documentId.getVersion() - 2)));
		});
		List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(documentIds);
		List<TradeReport> tradeReports = tradeReportDocuments.stream()
				.map(tradeDocument -> tradeDocument.getTradeReport()).collect(Collectors.toList());
		writeResults = upsertAllRecords(tradeReportDocuments, tradeReports);
		return writeResults;
	}

    private List<ActionUpdateResult> getTradeUpdateResultOnError(List<UpdateExceptionStatusRequest> requests, String errormessage) {
        return requests
                .stream()
                .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + errormessage))
                .collect(Collectors.toList());
    }

    protected List<Pair<TradeReport, Long>> getTradeWithExceptionStatus(List<TradeReportDocument> tradeReportDocuments,
                                                            ExceptionStatus requestedExceptionStatus,
                                                            Map<DocumentId, UpdateRequest> requests,
                                                            List<ActionUpdateResult> failedTrades,
                                                            String userName) throws BlotterRunTimeException {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
				} else if (requestValidator.validateAckedCancleTrade(requestedExceptionStatus,
						tradeReport.getTransactionReportingStatus().getTransactionStateValue())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), CANCEL_TRADE_ACKED_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), CANCEL_TRADE_ACKED_ERROR);
                }else if (!requestValidator.validateExceptionStatus(requestedExceptionStatus, tradeReport.getExceptionManagement().getApprovalStatus())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if (requestValidator.validateApprover(requestedExceptionStatus, tradeReport.getTradeReportId().getTradeSourceSystemTransactionId(), TRANSACTION,userName)) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
            }else {
                    UpdateExceptionStatusRequest updateExceptionStatusRequest = (UpdateExceptionStatusRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.addExceptionStatus(requestedExceptionStatus, updateExceptionStatusRequest,
                            tradeReport.getExceptionManagement(), userName);

                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating exception status in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating exception status in ExceptionManagement. ", e);
        }
    }

	protected List<Pair<TradeReport, Long>> resetActionOnTrade(List<TradeReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName)
			throws BlotterRunTimeException {
		try {
			List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
			for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
				TradeReport tradeReport = tradeReportDocument.getTradeReport();
				
                if (!requestValidator.validateResetActionApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus(),
                        requests.get(tradeReportDocument.getDocumentId()).getFlow())) {
					logger.warn("Reset Action is not allowed because Current Approval Status of trade is : {}",
							tradeReport.getExceptionManagement().getApprovalStatus());
					failedTrades.add(
							ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()),
									ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
					logFailuerReason(tradeReportDocument.getDocumentId(),
							ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
				} else {
					UpdateExceptionStatusRequest updateExceptionStatusRequest = (UpdateExceptionStatusRequest) requests
							.get(tradeReportDocument.getDocumentId());
					ExceptionManagement exceptionManagement = dataUpdater.resetAction(updateExceptionStatusRequest,
							tradeReport.getExceptionManagement(), userName);

					TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
					reportsWithExpectedBaseVersions
							.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
				}
			}
			return reportsWithExpectedBaseVersions;
		} catch (Exception e) {
			logger.error("Error occured while updating exception status in ExceptionManagement. ", e);
			throw new BlotterRunTimeException("Error occured while updating exception status in ExceptionManagement. ",
					e);
		}
	}

    public List<ActionUpdateResult> assignExceptionToUser(List<AssignTradeRequest> requests, String userName) {
        try {
            if(requests.isEmpty()){
                return Lists.newArrayList();
            }

            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithAssignment(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> getTradeWithAssignment(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {
            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AssignTradeRequest assignTradeRequest = (AssignTradeRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.assignException(assignTradeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while updating assign user in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while updating assign user in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> addJiraId(List<AddTradeJiraReferenceRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {

            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithJiraReference(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> getTradeWithJiraReference(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                AddTradeJiraReferenceRequest addTradeJiraReferenceRequest = (AddTradeJiraReferenceRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(requestValidator.isJiraIdPresent(tradeReport.getExceptionManagement().getIssueIds(), addTradeJiraReferenceRequest.getJiraReference().getJiraId())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_ID_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_ID_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.addJiraIdToException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while adding jira id in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while adding jira id in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeJiraId(List<AddTradeJiraReferenceRequest> requests, String userName) {
        if(requests.isEmpty()){
            return Lists.newArrayList();
        }
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = removeJiraReference(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> removeJiraReference(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                AddTradeJiraReferenceRequest addTradeJiraReferenceRequest = (AddTradeJiraReferenceRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(!requestValidator.isJiraIdPresent(tradeReport.getExceptionManagement().getIssueIds(), addTradeJiraReferenceRequest.getJiraReference().getJiraId())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_ID_NOT_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_ID_NOT_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.removeJiraIdFromException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while removing jira id from ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while removing jira id from ExceptionManagement. ", e);
        }
    }


    public List<ActionUpdateResult> addJiraType(List<AddTradeJiraTypeRequest> requests, String userName) {
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = getTradeWithJiraType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> getTradeWithJiraType(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();


                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else {
                    AddTradeJiraTypeRequest addTradeJiraTypeRequest = (AddTradeJiraTypeRequest) requests.get(tradeReportDocument.getDocumentId());
                    ExceptionManagement exceptionManagement = dataUpdater.addJiraTypeToException(addTradeJiraTypeRequest,
                            tradeReport.getExceptionManagement(), userName);

                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while adding jira type in ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while adding jira type in ExceptionManagement. ", e);
        }
    }

    public List<ActionUpdateResult> removeJiraType(List<AddTradeJiraTypeRequest> requests, String userName) {
        try {
            List<ActionUpdateResult> writeResults = Lists.newArrayList();
            Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
            requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
            List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

            if (!tradeReportDocuments.isEmpty()) {
                List<Pair<TradeReport, Long>> tradeReports = removeJiraType(tradeReportDocuments, tradeRequestMap, writeResults, userName);
                if (!tradeReports.isEmpty()) {
                    writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
                }
            }

            return writeResults;
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return requests
                    .stream()
                    .map(request -> ActionUpdateResult.createWithError(request.getDocumentId(), UPDATE_ERROR + e.getMessage()))
                    .collect(Collectors.toList());
        }
    }

    protected List<Pair<TradeReport, Long>> removeJiraType(List<TradeReportDocument> tradeReportDocuments, Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName) throws BlotterRunTimeException {
        try {

            List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
            for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
                TradeReport tradeReport = tradeReportDocument.getTradeReport();
                AddTradeJiraTypeRequest addTradeJiraReferenceRequest = (AddTradeJiraTypeRequest) requests.get(tradeReportDocument.getDocumentId());

                if (!requestValidator.validateUser(userName, tradeReport.getExceptionManagement())) {
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.USER_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.USER_VALIDATION_ERROR);
                }else if(requestValidator.validateApprovalStatus(tradeReport.getExceptionManagement().getApprovalStatus())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.APPROVAL_STATUS_VALIDATION_ERROR);
                }else if(!tradeReport.getExceptionManagement().getIssueType().value().equals(addTradeJiraReferenceRequest.getJiraType().getIssueType())){
                    failedTrades.add(ActionUpdateResult.createWithError(getTradePrimaryKey(tradeReportDocument.getDocumentId()), ActionRequestValidator.JIRA_TYPE_NOT_PRESENT));
                    logFailuerReason(tradeReportDocument.getDocumentId(), ActionRequestValidator.JIRA_TYPE_NOT_PRESENT);
                }else {
                    ExceptionManagement exceptionManagement = dataUpdater.removeJiraTypeFromException(addTradeJiraReferenceRequest,
                            tradeReport.getExceptionManagement(), userName);

                    TradeReport tradeRepo = getTradeReport(tradeReport, exceptionManagement);
                    reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
                }
            }
            return reportsWithExpectedBaseVersions;
        } catch (Exception e) {
            logger.error("Error occured while removing jira type from ExceptionManagement. ", e);
            throw new BlotterRunTimeException("Error occured while removing jira type from ExceptionManagement. ", e);
        }
    }

    private void logFailuerReason(DocumentId documentId, String reason){
        logger.warn("Trade validation failed for key : [{}], version : [{}] Reason : [{}]", documentId.getKey(), documentId.getVersion(), reason);
    }

	public List<ActionUpdateResult> updateUserActionType(List<UpdateUserActionTypeRequest> requests, String userName) {
		if (requests.isEmpty()) {
			return Lists.newArrayList();
		}
		try {
			List<ActionUpdateResult> writeResults = Lists.newArrayList();

			Map<DocumentId, UpdateRequest> tradeRequestMap = new HashMap<>();
			requests.forEach(request -> populateTradeRequestMap(request, tradeRequestMap));
			List<TradeReportDocument> tradeReportDocuments = getTradeReportDocuments(
					Lists.newArrayList(tradeRequestMap.keySet()));
            requestValidator.validateMAS755Trades(tradeReportDocuments, writeResults);

			if (!tradeReportDocuments.isEmpty()) {
				List<Pair<TradeReport, Long>> tradeReports = getUserActionTypeTrades(tradeReportDocuments,
						tradeRequestMap, writeResults, userName);
				if (!tradeReports.isEmpty()) {
					writeResults.addAll(saveAllRecords(tradeReportDocuments, tradeReports));
				}
			}

			return writeResults;
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			return requests.stream().map(request -> ActionUpdateResult.createWithError(request.getDocumentId(),
					UPDATE_ERROR + e.getMessage())).collect(Collectors.toList());
		}
	}

	protected List<Pair<TradeReport, Long>> getUserActionTypeTrades(List<TradeReportDocument> tradeReportDocuments,
			Map<DocumentId, UpdateRequest> requests, List<ActionUpdateResult> failedTrades, String userName)
			throws BlotterRunTimeException {
		try {
			List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();

			for (TradeReportDocument tradeReportDocument : tradeReportDocuments) {
				TradeReport tradeReport = tradeReportDocument.getTradeReport();
				UpdateUserActionTypeRequest updateUserActionTypeRequest = (UpdateUserActionTypeRequest) requests
						.get(tradeReportDocument.getDocumentId());
				ExceptionManagement exceptionManagement = dataUpdater.addComments(tradeReport.getExceptionManagement(),
						userName, updateUserActionTypeRequest.getComment().getComment(),
						updateUserActionTypeRequest.getAction());
				TradeReport tradeRepo = getTradeReportWithUserActionType(tradeReport, exceptionManagement,
						UserActionType.fromValue(updateUserActionTypeRequest.getUserActionType()));
				reportsWithExpectedBaseVersions.add(getReportsWithExpectedBaseVersion(tradeReportDocument, tradeRepo));
			}
			return reportsWithExpectedBaseVersions;
		} catch (Exception e) {
			logger.error("Error occured while updating comments in ExceptionManagement. ", e);
			throw new BlotterRunTimeException("Error occured while updating comments in ExceptionManagement. ", e);
		}
	}

	private TradeReport getTradeReportWithUserActionType(TradeReport tradeReport,
			ExceptionManagement exceptionManagement, UserActionType userActionType) {
		return TradeReport.newBuilder(tradeReport).withExceptionManagement(exceptionManagement)
				.withNonReportableData(NonReportableData.newBuilder(tradeReport.getNonReportableData())
						.withUserActionType(userActionType).withUpdatedByApplication(TNTRApplication.BLOTTER_SERVICE)
						.build())
				.build();
	}
}

Existing test class:

package com.rbs.tntr.business.blotter.services.actions;

import com.rbs.tntr.business.blotter.df.manager.DfTradePersistManager;
import com.rbs.tntr.business.blotter.web.request.regreportingTrade.*;
import com.rbs.tntr.domain.blotter.tntrBlotterView.ActionDocumentId;
import org.assertj.core.util.Lists;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import java.util.ArrayList;
import java.util.List;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class TradeActionServiceTest {

    @Mock
    private DfTradePersistManager dfTradePersistManager;

    @InjectMocks
    private TradeActionService tradeActionService;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testAddComment_EmptyRequests() {
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.addComment(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveComment_EmptyRequests() {
        List<AddTradeCommentRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.removeComment(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddCommentType_EmptyRequests() {
        List<AddTradeCommentTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.addCommentType(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveJiraType_EmptyRequests() {
        List<AddTradeJiraTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.removeJiraType(requests, "username");
        assertTrue(results.isEmpty());
    }

    // Tests for performResetAction
    @Test
    public void testPerformResetAction_EmptyRequests() {
        List<UpdateExceptionStatusRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.performResetAction(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddComment_WithException() {
        // Setup
        AddTradeCommentRequest request = mock(AddTradeCommentRequest.class);
        ActionDocumentId actionDocumentId = new ActionDocumentId("key1", 1L);
        when(request.getDocumentId()).thenReturn(actionDocumentId);

        List<AddTradeCommentRequest> requests = Lists.newArrayList(request);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenThrow(new RuntimeException("Test exception"));

        // Execute
        List<ActionUpdateResult> results = tradeActionService.addComment(requests, "username");

        // Verify
        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains("Error updating trade record"));
    }

    @Test
    public void testRemoveCommentType_EmptyRequests() {
        List<AddTradeCommentTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.removeCommentType(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveCommentType_WithException() {
        // Setup
        AddTradeCommentTypeRequest request = mock(AddTradeCommentTypeRequest.class);
        ActionDocumentId actionDocumentId = new ActionDocumentId("key1", 1L);
        when(request.getDocumentId()).thenReturn(actionDocumentId);

        List<AddTradeCommentTypeRequest> requests = Lists.newArrayList(request);

        when(dfTradePersistManager.getAllRecordsById(anyList())).thenThrow(new RuntimeException("Test exception"));

        // Execute
        List<ActionUpdateResult> results = tradeActionService.removeCommentType(requests, "username");

        // Verify
        assertEquals(1, results.size());
        assertTrue(results.get(0).getError().contains("Error updating trade record"));
    }

    @Test
    public void testAssignExceptionToUser_EmptyRequests() {
        List<AssignTradeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.assignExceptionToUser(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddJiraId_EmptyRequests() {
        List<AddTradeJiraReferenceRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.addJiraId(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testRemoveJiraId_EmptyRequests() {
        List<AddTradeJiraReferenceRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.removeJiraId(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testAddJiraType_EmptyRequests() {
        List<AddTradeJiraTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.addJiraType(requests, "username");
        assertTrue(results.isEmpty());
    }

    @Test
    public void testUpdateUserActionType_EmptyRequests() {
        List<UpdateUserActionTypeRequest> requests = new ArrayList<>();
        List<ActionUpdateResult> results = tradeActionService.updateUserActionType(requests, "username");
        assertTrue(results.isEmpty());
    }

}
