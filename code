package com.rbs.tntr.business.taggingService.df;

import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.constant.*;
import com.nwm.tntr.commons.domain.persistence.entity.*;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReport;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportDocument;
import com.nwm.tntr.commons.domain.persistence.entity.trade.TradeReportId;
import com.nwm.tntr.commons.domain.persistence.request.QueryParams;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.nwm.tntr.commons.repository.regreporting.trade.TradeReportDocumentRepository;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import junit.framework.TestCase;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.apache.commons.lang3.tuple.Pair;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;

public class DfTradePersistManagerTest {

    TradeReportDocumentRepository tradeReportDocumentRepository;
    DfTradePersistManager dfTradePersistManager;
    int dfPersistBatchSize = 500;

    @Before
    public void setUp() {
        tradeReportDocumentRepository = Mockito.mock(TradeReportDocumentRepository.class);
        dfTradePersistManager = new DfTradePersistManager(tradeReportDocumentRepository, dfPersistBatchSize);
    }

    @Test
    public void testGetAllRecords() {
        QueryParams queryParams = QueryParams.newBuilder()
                .withQueryWhere("documentLifetime.validFrom >= '2023-01-01T00:00:00.000Z'")
                .withOrderBy("documentLifetime.validFrom")
                .build();
        List<TradeReportDocument> expectedDocuments = Lists.newArrayList(getTradeReportDocument());
        Mockito.when(tradeReportDocumentRepository.findAllByQuery(queryParams)).thenReturn(expectedDocuments);

        List<TradeReportDocument> actualDocuments = dfTradePersistManager.getAllRecords(queryParams);

        TestCase.assertNotNull(actualDocuments);
        TestCase.assertEquals(expectedDocuments.size(), actualDocuments.size());
        TestCase.assertEquals(expectedDocuments.get(0).getDocumentId(), actualDocuments.get(0).getDocumentId());
    }

    @Test
    public void testGetAllRecordsException() {
        QueryParams queryParams = QueryParams.newBuilder()
                .withQueryWhere("documentLifetime.validFrom >= '2023-01-01T00:00:00.000Z'")
                .withOrderBy("documentLifetime.validFrom")
                .build();
        Mockito.when(tradeReportDocumentRepository.findAllByQuery(queryParams))
                .thenThrow(new RuntimeException("Test exception"));

        try {
            dfTradePersistManager.getAllRecords(queryParams);
            TestCase.fail("Expected TaggingServiceRunTimeException was not thrown");
        } catch (TaggingServiceRunTimeException e) {
            TestCase.assertTrue(e.getMessage().contains("Error occured while reading records from df"));
            TestCase.assertNotNull(e.getCause());
        }
    }

    @Test
    public void testSaveAllRecords() throws TaggingServiceRunTimeException {
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = Lists.newArrayList(
                Pair.of(getTradeReportDocument().getTradeReport(), 1L)
        );
        List<WriteResult<TradeReport>> expectedResults = getWriteResults();
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.anyList())).thenReturn(expectedResults);

        List<WriteResult<TradeReport>> actualResults = dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);

        TestCase.assertNotNull(actualResults);
        TestCase.assertEquals(expectedResults.size(), actualResults.size());
        TestCase.assertEquals(expectedResults.get(0).getDocumentId(), actualResults.get(0).getDocumentId());
        Mockito.verify(tradeReportDocumentRepository).compareAndUpdateAll(reportsWithExpectedBaseVersions);
    }

    @Test
    public void testSaveAllRecordsWithBatching() throws TaggingServiceRunTimeException {
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = new ArrayList<>();
        for (int i = 0; i < dfPersistBatchSize + 50; i++) {
            reportsWithExpectedBaseVersions.add(Pair.of(getTradeReportDocument().getTradeReport(), 1L));
        }
        List<WriteResult<TradeReport>> batch1Results = getWriteResults(dfPersistBatchSize);
        List<WriteResult<TradeReport>> batch2Results = getWriteResults(50);
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.anyList()))
                .thenReturn(batch1Results)
                .thenReturn(batch2Results);

        List<WriteResult<TradeReport>> actualResults = dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);

        TestCase.assertNotNull(actualResults);
        TestCase.assertEquals(dfPersistBatchSize + 50, actualResults.size());
        Mockito.verify(tradeReportDocumentRepository, Mockito.times(2)).compareAndUpdateAll(Mockito.anyList());
    }

    @Test
    public void testSaveAllRecordsException() {
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = Lists.newArrayList(
                Pair.of(getTradeReportDocument().getTradeReport(), 1L)
        );
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.anyList()))
                .thenThrow(new RuntimeException("Test exception"));

        try {
            dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);
            TestCase.fail("Expected TaggingServiceRunTimeException was not thrown");
        } catch (TaggingServiceRunTimeException e) {
            TestCase.assertTrue(e.getMessage().contains("Error occured while reading records to df"));
            TestCase.assertNotNull(e.getCause());
        }
    }

    @Test
    public void testSaveAllRecords_EmptyList() throws TaggingServiceRunTimeException {
        List<Pair<TradeReport, Long>> emptyList = new ArrayList<>();
        List<WriteResult<TradeReport>> results = dfTradePersistManager.saveAllRecords(emptyList);

        TestCase.assertNotNull(results);
        TestCase.assertTrue(results.isEmpty());
        Mockito.verify(tradeReportDocumentRepository, Mockito.never()).compareAndUpdateAll(Mockito.anyList());
    }

    @Test
    public void testSaveAllRecords_FailedWrites() throws TaggingServiceRunTimeException {
        List<Pair<TradeReport, Long>> reportsWithExpectedBaseVersions = Lists.newArrayList(
                Pair.of(getTradeReportDocument().getTradeReport(), 1L),
                Pair.of(getTradeReportDocument().getTradeReport(), 1L),
                Pair.of(getTradeReportDocument().getTradeReport(), 1L)
        );
        List<WriteResult<TradeReport>> mockedResults = Lists.newArrayList(
                createSuccessWriteResult(),
                createFailureWriteResultWithCause(),
                createFailureWriteResultWithoutCause()
        );
        Mockito.when(tradeReportDocumentRepository.compareAndUpdateAll(Mockito.anyList())).thenReturn(mockedResults);

        List<WriteResult<TradeReport>> actualResults = dfTradePersistManager.saveAllRecords(reportsWithExpectedBaseVersions);

        TestCase.assertNotNull(actualResults);
        TestCase.assertEquals(3, actualResults.size());
        TestCase.assertTrue(actualResults.get(0).isSuccess());
        TestCase.assertFalse(actualResults.get(1).isSuccess());
        TestCase.assertFalse(actualResults.get(2).isSuccess());
        Mockito.verify(tradeReportDocumentRepository).compareAndUpdateAll(Mockito.anyList());
    }

    // Helper methods
    private TradeReportDocument getTradeReportDocument() {
        DocumentId documentId = DocumentId.from("TradeReportId_123", 1L);
        DocumentLifetime documentLifetime = DocumentLifetime.from(ZonedDateTime.now(ZoneOffset.UTC),
                ZonedDateTime.now(ZoneOffset.UTC));
        TradeReport tradeReport = TradeReport.newBuilder()
                .withTradeReportId(TradeReportId.newBuilder().withTradeSourceSystemTransactionId("TradeReportId_123")
                        .withTradeSourceSystemId(SourceSystemId.ANVIL_GBLO_LDN).withTradeDocumentVersion(1)
                        .withReportingRegime(ReportingRegime.SECURITIES_FINANCING_TRANSACTION_REGULATION_SELF_REPORTING)
                        .withReportingRegulatoryAuthority(
                                ReportingRegulatoryAuthority.EUROPEAN_SECURITIES_AND_MARKETS_AUTHORITY_EUROPEAN_UNION)
                        .withRegimeImpactType(RegimeImpactType.TRANSACTION_REPORTING)
                        .withReportTriggerType(ReportTriggerType.TRANSACTION_LIFECYCLE)
                        .withReportSubmissionType(ReportSubmissionType.SNAPSHOT).build())
                .withTransactionReportingStatus(TransactionReportingStatus.newBuilder()
                        .withSourceSystemId(SourceSystemId.TN_TR)
                        .withStateTransitionDateTime(ZonedDateTime.now(ZoneOffset.UTC))
                        .withStateTransitionEffectiveDateTime(ZonedDateTime.now(ZoneOffset.UTC))
                        .withTransactionStateValue(TransactionStateValue.SUBMITTED)
                        .withReportSubmissionRepository(SourceSystemId.DTCC).withCommentary("Test TradeReport").build())
                .withExceptionManagement(ExceptionManagement.newBuilder().withApprovedBy("PERSON_1")
                        .withAssignedTo("matbina")
                        .withExceptionStatus(com.nwm.tntr.commons.domain.persistence.constant.ExceptionStatus.OPEN)
                        .withApprovalStatus(ApprovalStatus.OPEN_REQUESTED)
                        .withIssueIds(Lists.newArrayList("TNTR-1234", "TNTR-9875"))
                        .withIssueType(IssueType.MIS_REPORTING).withLastAction("Replay Edit")
                        .withLastActionDateTime(ZonedDateTime.now(ZoneOffset.UTC)).withLastActionUser("USER_1")
                        .withLatestVersion(false).withReportingDeadline(ZonedDateTime.now(ZoneOffset.UTC).plusDays(2))
                        .withUserComment("COMMENT 1").build())
                .withNonReportableData(NonReportableData.newBuilder().withLatestVersion(true).build()).build();
        return TradeReportDocument.from(documentId, documentLifetime, tradeReport);
    }

    private List<WriteResult<TradeReport>> getWriteResults() {
        return Lists.newArrayList(WriteResult.forSuccess(DocumentId.from("TradeReportId_123", 1L),
                getTradeReportDocument().getTradeReport()));
    }

    private List<WriteResult<TradeReport>> getWriteResults(int count) {
        List<WriteResult<TradeReport>> results = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            results.add(WriteResult.forSuccess(DocumentId.from("TradeReportId_" + i, 1L),
                    getTradeReportDocument().getTradeReport()));
        }
        return results;
    }

    private WriteResult<TradeReport> createSuccessWriteResult() {
        return WriteResult.forSuccess(DocumentId.from("TradeReportId_success", 1L),
                getTradeReportDocument().getTradeReport());
    }

    private WriteResult<TradeReport> createFailureWriteResultWithCause() {
        Throwable cause = new RuntimeException("Test cause");
        WriteResult.ErrorDetail errorDetail = new WriteResult.ErrorDetail("Error with cause", cause);
        return WriteResult.forFailure(errorDetail);
    }

    private WriteResult<TradeReport> createFailureWriteResultWithoutCause() {
        WriteResult.ErrorDetail errorDetail = new WriteResult.ErrorDetail("Error without cause", null);
        return WriteResult.forFailure(errorDetail);
    }
}
