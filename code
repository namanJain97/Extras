package com.rbs.tntr.business.taggingService.df;

import com.google.common.base.Stopwatch;
import com.google.common.collect.Lists;
import com.nwm.tntr.commons.domain.persistence.entity.recon.ReconReport;
import com.nwm.tntr.commons.domain.persistence.entity.recon.ReconReportDocument;
import com.nwm.tntr.commons.domain.persistence.request.QueryParams;
import com.nwm.tntr.commons.repository.regreporting.WriteResult;
import com.nwm.tntr.commons.repository.regreporting.recon.ReconReportDocumentRepository;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class DfReconciliationPersistManager {
    ReconReportDocumentRepository reconReportDocumentRepository;
    int dfPersistBatchSize;
    private static final Logger logger = LoggerFactory.getLogger(DfReconciliationPersistManager.class);

    /**
     * Constructor for DfPersistManager
     * @param reconReportDocumentRepository - new DF api trade data
     */
    public DfReconciliationPersistManager(ReconReportDocumentRepository reconReportDocumentRepository, int dfPersistBatchSize){
        this.reconReportDocumentRepository = reconReportDocumentRepository;
        this.dfPersistBatchSize = dfPersistBatchSize;
    }


    public List<ReconReportDocument> getAllRecords(QueryParams queryParams) throws TaggingServiceRunTimeException {
        try {
            return reconReportDocumentRepository.findAllByQuery(queryParams);
        } catch (Exception e) {
            logger.error("Error occured while reading records from df. ", e);
            throw new TaggingServiceRunTimeException("Error occured while reading records from df. ", e);
        }
    }

    public List<WriteResult<ReconReport>> saveAllRecords(List<Pair<ReconReport, Long>> reportsWithExpectedBaseVersions) throws TaggingServiceRunTimeException {
        try {
            List<WriteResult<ReconReport>> writeResults = new ArrayList<>();
            List<List<Pair<ReconReport, Long>>> smallerLists = Lists.partition(reportsWithExpectedBaseVersions, dfPersistBatchSize);
            Stopwatch stopwatchPersist = Stopwatch.createStarted();
            for(List<Pair<ReconReport, Long>> reports : smallerLists) {
                writeResults.addAll(reconReportDocumentRepository.compareAndUpdateAll(reports));
            }
            logger.info("Time taken in inserting [{}] records = [{}]ms.",writeResults.size(), stopwatchPersist.elapsed(TimeUnit.MILLISECONDS));
            logger.info("Total Trade record : [{}], Successfully updated : [{}], Failed to update in df : [{}] ", writeResults.size(),
                    writeResults.stream().filter(result -> result.isSuccess()).count(), writeResults.stream().filter(result -> result.isFailure()).count());

            logErrorReasonForInsertion(writeResults);
            return writeResults;
        } catch (Exception e) {
            logger.error("Error occured while writing records to df. ", e);
            throw new TaggingServiceRunTimeException("Error occured while reading records to df. ", e);
        }
    }

    private void logErrorReasonForInsertion(List<WriteResult<ReconReport>> writeResults) {
        writeResults.stream().forEach(result -> {
            if (!result.isSuccess()) {
                String error = result.getErrorDetail().getCause() != null
                        ? result.getErrorDetail().getDescription() + ". " + result.getErrorDetail().getCause().getMessage()
                        : result.getErrorDetail().getDescription();
                logger.error("Error occurred in persisting recon  : [{}]", error);
            }
        });
    }
}
