package com.rbs.tntr.business.blotter.web.controllers;

import com.rbs.datafabric.domain.RecordId;
import com.rbs.tntr.business.blotter.services.blotterEvents.BlotterEventRepository;
import com.rbs.tntr.business.blotter.services.blotterEvents.BlotterSubscriptionDeletionResult;
import com.rbs.tntr.business.blotter.services.blotterEvents.IndexCreationResult;
import com.rbs.tntr.business.blotter.services.blotterEvents.SubscriptionEventManager;
import com.rbs.tntr.business.blotter.services.datetime.DateTimeService;
import com.rbs.tntr.business.blotter.web.request.blotterEvents.BlotterEvent;
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class BlotterEventsControllerTest {

    @Mock
    private BlotterEventRepository eventRepository;

    @Mock
    private DateTimeService dateTimeService;

    @Mock
    private SubscriptionEventManager subscriptionEventManager;

    @InjectMocks
    private BlotterEventsController controller;

    private BlotterEvent blotterEvent;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        blotterEvent = new BlotterEvent();
        blotterEvent.setEventId("testEvent");
    }

    // Existing tests from the provided test class
    @Test
    public void testSave_DataFabricSerializerException() throws Exception {
        when(eventRepository.save(blotterEvent)).thenThrow(new com.rbs.datafabric.common.DataFabricSerializerException("Serialization Error"));
        ResponseEntity<?> response = controller.save(blotterEvent);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter event"));
    }

    @Test
    public void testSave_UpsertException() throws Exception {
        when(eventRepository.save(blotterEvent)).thenThrow(new com.rbs.datafabric.api.exception.UpsertException("Upsert Error"));
        ResponseEntity<?> response = controller.save(blotterEvent);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter event"));
    }

    @Test
    public void testSave_OptimisticLockException() throws Exception {
        when(eventRepository.save(blotterEvent)).thenThrow(new com.rbs.datafabric.api.exception.OptimisticLockException("Optimistic Lock Error"));
        ResponseEntity<?> response = controller.save(blotterEvent);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter event"));
    }

    @Test
    public void testSaveAll_DataFabricSerializerException() throws Exception {
        List<BlotterEvent> events = Collections.singletonList(blotterEvent);
        when(eventRepository.saveAll(events)).thenThrow(new com.rbs.datafabric.common.DataFabricSerializerException("Serialization Error"));
        ResponseEntity<?> response = controller.saveAll(events);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter events"));
    }

    @Test
    public void testSaveAll_UpsertException() throws Exception {
        List<BlotterEvent> events = Collections.singletonList(blotterEvent);
        when(eventRepository.saveAll(events)).thenThrow(new com.rbs.datafabric.api.exception.UpsertException("Upsert Error"));
        ResponseEntity<?> response = controller.saveAll(events);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error saving blotter events"));
    }

    @Test
    public void testCreateIndexesDropExisting_Success() throws Exception {
        HashMap<String, IndexCreationResult> mockResult = new HashMap<>();
        when(eventRepository.dropAndCreateIndexes(true)).thenReturn(mockResult);
        ResponseEntity<?> response = controller.createIndexesDropExisting(true);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockResult, response.getBody());
    }

    // New test cases to achieve 100% coverage

    // Tests for save method
    @Test
    public void testSave_Success() throws Exception {
        RecordId mockRecordId = new RecordId("testId");
        when(eventRepository.save(blotterEvent)).thenReturn(mockRecordId);
        ResponseEntity<?> response = controller.save(blotterEvent);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockRecordId, response.getBody());
    }

    // Tests for saveAll method
    @Test
    public void testSaveAll_Success() throws Exception {
        List<BlotterEvent> events = Collections.singletonList(blotterEvent);
        List<RecordId> mockRecordIds = Collections.singletonList(new RecordId("testId"));
        when(eventRepository.saveAll(events)).thenReturn(mockRecordIds);
        ResponseEntity<?> response = controller.saveAll(events);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockRecordIds, response.getBody());
    }

    @Test
    public void testSaveAll_EmptyList() throws Exception {
        List<BlotterEvent> events = Collections.emptyList();
        List<RecordId> mockRecordIds = Collections.emptyList();
        when(eventRepository.saveAll(events)).thenReturn(mockRecordIds);
        ResponseEntity<?> response = controller.saveAll(events);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockRecordIds, response.getBody());
    }

    // Tests for createIndexesDropExisting method
    @Test
    public void testCreateIndexesDropExisting_Failure() throws Exception {
        when(eventRepository.dropAndCreateIndexes(true)).thenThrow(new RuntimeException("Index creation error"));
        ResponseEntity<?> response = controller.createIndexesDropExisting(true);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error in creating/recreating indexes"));
    }

    // Tests for getActiveSubscriptions method
    @Test
    public void testGetActiveSubscriptions_Success() throws Exception {
        Date asOf = new Date();
        List<BlotterEvent> mockEvents = Collections.singletonList(blotterEvent);
        when(eventRepository.getActiveSubscriptions(asOf)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getActiveSubscriptions(asOf);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    @Test
    public void testGetActiveSubscriptions_Failure() throws Exception {
        Date asOf = new Date();
        when(eventRepository.getActiveSubscriptions(asOf)).thenThrow(new RuntimeException("Fetch error"));
        ResponseEntity<?> response = controller.getActiveSubscriptions(asOf);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching active subscriptions"));
    }

    // Tests for getEventsByDateTime(Date from, Date to) method
    @Test
    public void testGetEventsByDateTime_Range_Success() throws Exception {
        Date from = new Date();
        Date to = new Date();
        List<BlotterEvent> mockEvents = Collections.singletonList(blotterEvent);
        when(eventRepository.eventsByDateRange(from, to)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getEventsByDateTime(from, to);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    @Test
    public void testGetEventsByDateTime_Range_Failure() throws Exception {
        Date from = new Date();
        Date to = new Date();
        when(eventRepository.eventsByDateRange(from, to)).thenThrow(new RuntimeException("Fetch error"));
        ResponseEntity<?> response = controller.getEventsByDateTime(from, to);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching subscriptions for date range"));
    }

    // Tests for getEventsByDateTime(Date date) method
    @Test
    public void testGetEventsByDateTime_Date_Success() throws Exception {
        Date date = new Date();
        Date toDate = new Date(date.getTime() + 86400000); // +1 day in milliseconds
        List<BlotterEvent> mockEvents = Collections.singletonList(blotterEvent);
        when(dateTimeService.addDays(date, 1)).thenReturn(toDate);
        when(eventRepository.eventsByDateRange(date, toDate)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getEventsByDateTime(date);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    @Test
    public void testGetEventsByDateTime_Date_Failure_AddDays() throws Exception {
        Date date = new Date();
        when(dateTimeService.addDays(date, 1)).thenThrow(new RuntimeException("Date error"));
        ResponseEntity<?> response = controller.getEventsByDateTime(date);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching subscriptions for date"));
    }

    @Test
    public void testGetEventsByDateTime_Date_Failure_EventsByDateRange() throws Exception {
        Date date = new Date();
        Date toDate = new Date(date.getTime() + 86400000);
        when(dateTimeService.addDays(date, 1)).thenReturn(toDate);
        when(eventRepository.eventsByDateRange(date, toDate)).thenThrow(new RuntimeException("Fetch error"));
        ResponseEntity<?> response = controller.getEventsByDateTime(date);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching subscriptions for date"));
    }

    // Tests for getSubscriptions(List<String> eventIds) method
    @Test
    public void testGetSubscriptions_ByEventIds_Success() throws Exception {
        List<String> eventIds = Collections.singletonList("testEvent");
        List<BlotterEvent> mockEvents = Collections.singletonList(blotterEvent);
        when(eventRepository.getEvents(eventIds)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getSubscriptions(eventIds);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    @Test
    public void testGetSubscriptions_ByEventIds_Failure() throws Exception {
        List<String> eventIds = Collections.singletonList("testEvent");
        when(eventRepository.getEvents(eventIds)).thenThrow(new RuntimeException("Fetch error"));
        ResponseEntity<?> response = controller.getSubscriptions(eventIds);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching blotter event details"));
    }

    @Test
    public void testGetSubscriptions_ByEventIds_EmptyList() throws Exception {
        List<String> eventIds = Collections.emptyList();
        List<BlotterEvent> mockEvents = Collections.emptyList();
        when(eventRepository.getEvents(eventIds)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getSubscriptions(eventIds);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    // Tests for getSubscriptions(String sessionId) method
    @Test
    public void testGetSubscriptions_BySessionId_Success() throws Exception {
        String sessionId = "testSession";
        List<BlotterEvent> mockEvents = Collections.singletonList(blotterEvent);
        when(eventRepository.getEvents(sessionId)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getSubscriptions(sessionId);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    @Test
    public void testGetSubscriptions_BySessionId_Failure() throws Exception {
        String sessionId = "testSession";
        when(eventRepository.getEvents(sessionId)).thenThrow(new RuntimeException("Fetch error"));
        ResponseEntity<?> response = controller.getSubscriptions(sessionId);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching blotter event details"));
    }

    // Tests for getEventsByUser method
    @Test
    public void testGetEventsByUser_Success() throws Exception {
        Date from = new Date();
        Date to = new Date();
        String userName = "testUser";
        List<BlotterEvent> mockEvents = Collections.singletonList(blotterEvent);
        when(eventRepository.getEventsByUser(from, to, userName)).thenReturn(mockEvents);
        ResponseEntity<?> response = controller.getEventsByUser(from, to, userName);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockEvents, response.getBody());
    }

    @Test
    public void testGetEventsByUser_Failure() throws Exception {
        Date from = new Date();
        Date to = new Date();
        String userName = "testUser";
        when(eventRepository.getEventsByUser(from, to, userName)).thenThrow(new RuntimeException("Fetch error"));
        ResponseEntity<?> response = controller.getEventsByUser(from, to, userName);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error fetching subscriptions for user"));
    }

    // Tests for deleteActiveSubscriptions method
    @Test
    public void testDeleteActiveSubscriptions_Success() throws Exception {
        Date asOf = new Date();
        HashMap<String, BlotterSubscriptionDeletionResult> mockResult = new HashMap<>();
        when(subscriptionEventManager.deleteAllActiveSubscriptions(asOf)).thenReturn(mockResult);
        ResponseEntity<?> response = controller.deleteActiveSubscriptions(asOf);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockResult, response.getBody());
    }

    @Test
    public void testDeleteActiveSubscriptions_Failure() throws Exception {
        Date asOf = new Date();
        when(subscriptionEventManager.deleteAllActiveSubscriptions(asOf)).thenThrow(new RuntimeException("Delete error"));
        ResponseEntity<?> response = controller.deleteActiveSubscriptions(asOf);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error deleting active subscriptions"));
    }

    // Tests for deleteBlotterSubscriptions method
    @Test
    public void testDeleteBlotterSubscriptions_Success() throws Exception {
        List<String> subscriptionIds = Collections.singletonList("testId");
        HashMap<String, BlotterSubscriptionDeletionResult> mockResult = new HashMap<>();
        when(subscriptionEventManager.deleteBlotterSubscriptions(subscriptionIds)).thenReturn(mockResult);
        ResponseEntity<?> response = controller.deleteBlotterSubscriptions(subscriptionIds);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockResult, response.getBody());
    }

    @Test
    public void testDeleteBlotterSubscriptions_Failure() throws Exception {
        List<String> subscriptionIds = Collections.singletonList("testId");
        when(subscriptionEventManager.deleteBlotterSubscriptions(subscriptionIds)).thenThrow(new RuntimeException("Delete error"));
        ResponseEntity<?> response = controller.deleteBlotterSubscriptions(subscriptionIds);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
        assertTrue(response.getBody().toString().contains("Error deleting active subscriptions"));
    }

    @Test
    public void testDeleteBlotterSubscriptions_EmptyList() throws Exception {
        List<String> subscriptionIds = Collections.emptyList();
        HashMap<String, BlotterSubscriptionDeletionResult> mockResult = new HashMap<>();
        when(subscriptionEventManager.deleteBlotterSubscriptions(subscriptionIds)).thenReturn(mockResult);
        ResponseEntity<?> response = controller.deleteBlotterSubscriptions(subscriptionIds);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(mockResult, response.getBody());
    }
}
