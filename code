package com.rbs.tntr.business.blotter.utility;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import org.slf4j.Logger;

import com.rbs.tntr.domain.blotter.exceptions.BlotterRunTimeException;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;

@RunWith(MockitoJUnitRunner.class)
public class ExcelWriterImplTest {

    @InjectMocks
    private ExcelWriterImpl excelWriter;

    @Mock
    private SXSSFWorkbook workBook;

    @Mock
    private Sheet excelSheet;

    @Mock
    private Logger logger;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testGetCellStyle() throws Exception {
        // Set up mock workbook in the instance
        setPrivateField("workBook", workBook);
        
        Method method = ExcelWriterImpl.class.getDeclaredMethod("getCellStyle");
        method.setAccessible(true);

        CellStyle style = mock(CellStyle.class);
        when(workBook.createCellStyle()).thenReturn(style);

        CellStyle result = (CellStyle) method.invoke(excelWriter);

        assertNotNull(result);
        verify(style).setAlignment(HorizontalAlignment.CENTER);
    }

    @Test
    public void testFillHeader() throws Exception {
        Method method = ExcelWriterImpl.class.getDeclaredMethod("fillHeader", String[].class, String.class);
        method.setAccessible(true);

        String[] columns = {"Column1", "Column2", "Column3"};
        String sheetName = "TestSheet";

        // Mock the workbook creation behavior
        SXSSFWorkbook realWorkbook = mock(SXSSFWorkbook.class);
        Sheet realSheet = mock(Sheet.class);
        Row headerRow = mock(Row.class);
        CellStyle headerStyle = mock(CellStyle.class);
        
        // Create mock cells for each column
        Cell cell1 = mock(Cell.class);
        Cell cell2 = mock(Cell.class);
        Cell cell3 = mock(Cell.class);
        
        when(realWorkbook.createSheet(sheetName)).thenReturn(realSheet);
        when(realWorkbook.createCellStyle()).thenReturn(headerStyle);
        when(realSheet.createRow(0)).thenReturn(headerRow);
        when(headerRow.createCell(0)).thenReturn(cell1);
        when(headerRow.createCell(1)).thenReturn(cell2);
        when(headerRow.createCell(2)).thenReturn(cell3);

        // Use PowerMockito alternative - create a new instance for testing
        ExcelWriterImpl testWriter = new ExcelWriterImpl();
        method.invoke(testWriter, columns, sheetName);

        // Verify that workBook and excelSheet fields are set
        Field workBookField = ExcelWriterImpl.class.getDeclaredField("workBook");
        workBookField.setAccessible(true);
        SXSSFWorkbook workBookValue = (SXSSFWorkbook) workBookField.get(testWriter);
        assertNotNull(workBookValue);

        Field excelSheetField = ExcelWriterImpl.class.getDeclaredField("excelSheet");
        excelSheetField.setAccessible(true);
        Sheet excelSheetValue = (Sheet) excelSheetField.get(testWriter);
        assertNotNull(excelSheetValue);
    }

    @Test
    public void testFillData() throws Exception {
        // Set up mock objects in the instance
        setPrivateField("workBook", workBook);
        setPrivateField("excelSheet", excelSheet);
        
        Method method = ExcelWriterImpl.class.getDeclaredMethod("fillData", List.class);
        method.setAccessible(true);

        String[] header = {"Column1", "Column2"};
        String[] row1 = {"Data1", "Data2"};
        String[] row2 = {"Data3", "Data4"};
        List<String[]> rows = Arrays.asList(header, row1, row2);

        CellStyle normalStyle = mock(CellStyle.class);
        when(workBook.createCellStyle()).thenReturn(normalStyle);

        // Mock rows
        Row mockRow1 = mock(Row.class);
        Row mockRow2 = mock(Row.class);
        when(excelSheet.createRow(1)).thenReturn(mockRow1);
        when(excelSheet.createRow(2)).thenReturn(mockRow2);

        // Mock cells for row 1
        Cell cell1_1 = mock(Cell.class);
        Cell cell1_2 = mock(Cell.class);
        when(mockRow1.createCell(0, CellType.STRING)).thenReturn(cell1_1);
        when(mockRow1.createCell(1, CellType.STRING)).thenReturn(cell1_2);

        // Mock cells for row 2
        Cell cell2_1 = mock(Cell.class);
        Cell cell2_2 = mock(Cell.class);
        when(mockRow2.createCell(0, CellType.STRING)).thenReturn(cell2_1);
        when(mockRow2.createCell(1, CellType.STRING)).thenReturn(cell2_2);

        method.invoke(excelWriter, rows);

        // Verify row 1
        verify(cell1_1).setCellValue("Data1");
        verify(cell1_1).setCellStyle(normalStyle);
        verify(cell1_2).setCellValue("Data2");
        verify(cell1_2).setCellStyle(normalStyle);

        // Verify row 2
        verify(cell2_1).setCellValue("Data3");
        verify(cell2_1).setCellStyle(normalStyle);
        verify(cell2_2).setCellValue("Data4");
        verify(cell2_2).setCellStyle(normalStyle);
    }

    @Test
    public void testWriteExcelFile_Success() throws Exception {
        // Set up mock objects
        setPrivateField("workBook", workBook);
        setPrivateField("logger", logger);
        
        Method method = ExcelWriterImpl.class.getDeclaredMethod("writeExcelFile", String.class);
        method.setAccessible(true);

        String fileName = "test.xlsx";

        // Mock file operations - we can't really mock File and FileOutputStream easily
        // So we'll test the exception path instead
        method.invoke(excelWriter, fileName);

        verify(workBook).dispose();
        verify(workBook).close();
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testWriteExcelFile_IOException() throws Exception {
        // Set up mock objects
        setPrivateField("workBook", workBook);
        setPrivateField("logger", logger);
        
        Method method = ExcelWriterImpl.class.getDeclaredMethod("writeExcelFile", String.class);
        method.setAccessible(true);

        String fileName = "/invalid/path/test.xlsx"; // Invalid path to trigger IOException

        doThrow(new IOException("Test exception")).when(workBook).write(any(FileOutputStream.class));

        method.invoke(excelWriter, fileName);
    }

    @Test
    public void testExportExcel_Success() {
        String[] header = {"Column1", "Column2"};
        String[] row1 = {"Data1", "Data2"};
        List<String[]> rows = Arrays.asList(header, row1);
        String fileName = "test.xlsx";
        String sheetName = "TestSheet";

        boolean result = excelWriter.exportExcel(rows, fileName, sheetName);

        assertTrue(result);
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testExportExcel_Exception() {
        // Test with null rows to trigger exception
        List<String[]> rows = null;
        String fileName = "test.xlsx";
        String sheetName = "TestSheet";

        excelWriter.exportExcel(rows, fileName, sheetName);
    }

    @Test(expected = BlotterRunTimeException.class)
    public void testExportExcel_EmptyRows() {
        // Test with empty rows list
        List<String[]> rows = Arrays.asList();
        String fileName = "test.xlsx";
        String sheetName = "TestSheet";

        excelWriter.exportExcel(rows, fileName, sheetName);
    }

    @Test
    public void testExportExcel_SingleRow() {
        String[] header = {"Column1", "Column2"};
        List<String[]> rows = Arrays.asList(header);
        String fileName = "test.xlsx";
        String sheetName = "TestSheet";

        boolean result = excelWriter.exportExcel(rows, fileName, sheetName);

        assertTrue(result);
    }

    @Test
    public void testFillData_EmptyDataCells() throws Exception {
        // Set up mock objects in the instance
        setPrivateField("workBook", workBook);
        setPrivateField("excelSheet", excelSheet);
        
        Method method = ExcelWriterImpl.class.getDeclaredMethod("fillData", List.class);
        method.setAccessible(true);

        String[] header = {"Column1", "Column2"};
        String[] row1 = {"", null}; // Test empty and null values
        List<String[]> rows = Arrays.asList(header, row1);

        CellStyle normalStyle = mock(CellStyle.class);
        when(workBook.createCellStyle()).thenReturn(normalStyle);

        Row mockRow1 = mock(Row.class);
        when(excelSheet.createRow(1)).thenReturn(mockRow1);

        Cell cell1 = mock(Cell.class);
        Cell cell2 = mock(Cell.class);
        when(mockRow1.createCell(0, CellType.STRING)).thenReturn(cell1);
        when(mockRow1.createCell(1, CellType.STRING)).thenReturn(cell2);

        method.invoke(excelWriter, rows);

        verify(cell1).setCellValue("");
        verify(cell2).setCellValue((String) null);
    }

    @Test
    public void testFillData_SingleColumnData() throws Exception {
        // Set up mock objects in the instance
        setPrivateField("workBook", workBook);
        setPrivateField("excelSheet", excelSheet);
        
        Method method = ExcelWriterImpl.class.getDeclaredMethod("fillData", List.class);
        method.setAccessible(true);

        String[] header = {"Column1"};
        String[] row1 = {"Data1"};
        List<String[]> rows = Arrays.asList(header, row1);

        CellStyle normalStyle = mock(CellStyle.class);
        when(workBook.createCellStyle()).thenReturn(normalStyle);

        Row mockRow1 = mock(Row.class);
        when(excelSheet.createRow(1)).thenReturn(mockRow1);

        Cell cell1 = mock(Cell.class);
        when(mockRow1.createCell(0, CellType.STRING)).thenReturn(cell1);

        method.invoke(excelWriter, rows);

        verify(cell1).setCellValue("Data1");
        verify(cell1).setCellStyle(normalStyle);
    }

    @Test
    public void testFillHeader_SingleColumn() throws Exception {
        Method method = ExcelWriterImpl.class.getDeclaredMethod("fillHeader", String[].class, String.class);
        method.setAccessible(true);

        String[] columns = {"SingleColumn"};
        String sheetName = "SingleColumnSheet";

        ExcelWriterImpl testWriter = new ExcelWriterImpl();
        method.invoke(testWriter, columns, sheetName);

        // Verify that workBook and excelSheet fields are set
        Field workBookField = ExcelWriterImpl.class.getDeclaredField("workBook");
        workBookField.setAccessible(true);
        SXSSFWorkbook workBookValue = (SXSSFWorkbook) workBookField.get(testWriter);
        assertNotNull(workBookValue);
    }

    @Test
    public void testFillHeader_EmptyColumns() throws Exception {
        Method method = ExcelWriterImpl.class.getDeclaredMethod("fillHeader", String[].class, String.class);
        method.setAccessible(true);

        String[] columns = {};
        String sheetName = "EmptySheet";

        ExcelWriterImpl testWriter = new ExcelWriterImpl();
        method.invoke(testWriter, columns, sheetName);

        // Verify that workBook and excelSheet fields are set even with empty columns
        Field workBookField = ExcelWriterImpl.class.getDeclaredField("workBook");
        workBookField.setAccessible(true);
        SXSSFWorkbook workBookValue = (SXSSFWorkbook) workBookField.get(testWriter);
        assertNotNull(workBookValue);
    }

    @Test
    public void testExportExcel_WithSpecialCharacters() {
        String[] header = {"Column with spaces", "Column@#$%"};
        String[] row1 = {"Data with spaces", "Special@#$%Data"};
        List<String[]> rows = Arrays.asList(header, row1);
        String fileName = "special_chars_test.xlsx";
        String sheetName = "Special Characters Sheet";

        boolean result = excelWriter.exportExcel(rows, fileName, sheetName);

        assertTrue(result);
    }

    // Helper method to set private fields using reflection
    private void setPrivateField(String fieldName, Object value) throws Exception {
        Field field = ExcelWriterImpl.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(excelWriter, value);
    }
}
