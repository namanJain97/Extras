package com.rbs.tntr.business.taggingService.repository;

import static com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIConstants.*;
import static org.junit.Assert.*;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.function.Consumer;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nwm.tntr.commons.domain.persistence.constant.AssetClass;
import com.nwm.tntr.commons.repository.df.DfConnectionManager;
import com.nwm.tntr.configuration.ItrConfiguration;
import com.nwm.tntr.itr.IQuery;
import com.nwm.tntr.itr.Itr2ParameterisedQuery;
import com.rbs.datafabric.agile.commons.lang.StartableException;
import com.rbs.datafabric.api.ScanResult;
import com.rbs.datafabric.api.exception.OptimisticLockException;
import com.rbs.datafabric.api.exception.ScanException;
import com.rbs.datafabric.api.exception.UpsertException;
import com.rbs.datafabric.client.DataFabricClient;
import com.rbs.datafabric.domain.Document;
import com.rbs.datafabric.domain.JsonDocument;
import com.rbs.datafabric.domain.Record;
import com.rbs.datafabric.domain.RecordId;
import com.rbs.datafabric.domain.client.builder.ScanRequestBuilder;
import com.rbs.datafabric.domain.client.builder.UpsertRequestBuilder;
import com.rbs.datafabric.shaded.com.google.common.collect.Lists;
import com.rbs.tntr.business.taggingService.service.common.ItrClient;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.common.Itr2Query;
import com.rbs.tntr.domain.taggingService.jiraTaggingDomain.exceptions.TaggingServiceRunTimeException;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.DFQueryMetaData;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeMIAalyticsState;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeMIDashboardAnalytics;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.FrontOfficeSubjectIdentifier;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.MIDashboardAnalytics;
import com.rbs.tntr.domain.taggingService.miAnalytics.dashboard.common.SubjectIdentifier;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class MIAnalyticsDashboardRepositoryImplTest {

    @Mock
    private DfConnectionManager dfConnectionManager;

    @Mock
    private ItrConfiguration itrConfiguration;

    @Mock
    private ItrClient itrClient;

    @Mock
    private DataFabricClient dfClient;

    @Mock
    private ScanRequestBuilder scanRequestBuilder;

    @Mock
    private UpsertRequestBuilder upsertRequestBuilder;

    @Mock
    private ScanResult scanResult;
    
    @Mock
    private Iterator<Record> recordIterator;
    
    @Mock
    private Record dfRecord;
    
    @Mock
    private JsonDocument jsonDocument;

    @Spy
    @InjectMocks
    private MIAnalyticsDashboardRepositoryImpl repository;

    private ObjectMapper objectMapper = new ObjectMapper();

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);
        setPrivateField(repository, "databaseName", "testDatabase");
        setPrivateField(repository, "miCollection", "miCollection");
        setPrivateField(repository, "foMiCollection", "foMiCollection");
        setPrivateField(repository, "readTimeOut", 30);
        setPrivateField(repository, "foEmirUrl", "fo-emir-url");
        setPrivateField(repository, "foEmirParameterisedUrl", "fo-emir-parameterised-url");
        setPrivateField(repository, "foMasUrl", "fo-mas-url");
        setPrivateField(repository, "foMasParameterisedUrl", "fo-mas-parameterised-url");
        setPrivateField(repository, "foBoiUrl", "fo-boi-url");
        setPrivateField(repository, "foMifidUrl", "fo-mifid-url");
        setPrivateField(repository, "foSftrUrl", "fo-sftr-url");
        setPrivateField(repository, "foSftrAldopUrl", "fo-sftr-aldop-url");
        setPrivateField(repository, "foCftcUrl", "fo-cftc-url");
        setPrivateField(repository, "dfClient", dfClient);
    }

    @Test
    public void testCreateDfClientConnection() throws StartableException {
        doReturn(dfClient).when(dfConnectionManager).getClient();
        repository.createDfClientConnection();
        verify(dfConnectionManager).getClient();
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testCreateDfClientConnectionWithException() throws StartableException {
        doThrow(new StartableException("Test exception")).when(dfConnectionManager).getClient();
        repository.createDfClientConnection();
    }

    @Test
    public void testSerialize() throws Exception {
        MIDashboardAnalytics analytics = createMIDashboardAnalytics();
        Document document = repository.serialize(analytics);
        assertTrue(document instanceof JsonDocument);
        assertNotNull(((JsonDocument) document).getContents());
    }

    @Test
    public void testDeserialize() throws Exception {
        MIDashboardAnalytics analytics = createMIDashboardAnalytics();
        Document document = repository.serialize(analytics);
        MIDashboardAnalytics result = invokePrivateMethod(repository, "deserailze", new Class[]{Document.class}, document);
        assertEquals(analytics.getSubjectIdentifier().getLei(), result.getSubjectIdentifier().getLei());
    }

    @Test
    public void testUpsertMiSnapshot() throws UpsertException, OptimisticLockException {
        MIDashboardAnalytics analytics = createMIDashboardAnalytics();
        RecordId expectedRecordId = new RecordId("testId");
        
        when(UpsertRequestBuilder.create(anyString(), anyString())).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withDocument(any(Document.class))).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withKey(anyString())).thenReturn(upsertRequestBuilder);
        when(dfClient.upsert(upsertRequestBuilder)).thenReturn(expectedRecordId);
        
        RecordId result = repository.upsertMiSnapshot(analytics);
        
        assertEquals(expectedRecordId, result);
        verify(dfClient).upsert(upsertRequestBuilder);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertMiSnapshotWithException() throws UpsertException, OptimisticLockException {
        MIDashboardAnalytics analytics = createMIDashboardAnalytics();
        
        when(UpsertRequestBuilder.create(anyString(), anyString())).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withDocument(any(Document.class))).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withKey(anyString())).thenReturn(upsertRequestBuilder);
        when(dfClient.upsert(upsertRequestBuilder)).thenThrow(new UpsertException("Test exception"));
        
        repository.upsertMiSnapshot(analytics);
    }

    @Test
    public void testUpsertFoMiSnapshot() throws UpsertException, OptimisticLockException {
        FrontOfficeMIDashboardAnalytics analytics = createFrontOfficeMIDashboardAnalytics();
        RecordId expectedRecordId = new RecordId("testId");
        
        when(UpsertRequestBuilder.create(anyString(), anyString())).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withDocument(any(Document.class))).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withKey(anyString())).thenReturn(upsertRequestBuilder);
        when(dfClient.upsert(upsertRequestBuilder)).thenReturn(expectedRecordId);
        
        RecordId result = repository.upsertFoMiSnapshot(analytics);
        
        assertEquals(expectedRecordId, result);
        verify(dfClient).upsert(upsertRequestBuilder);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testUpsertFoMiSnapshotWithException() throws UpsertException, OptimisticLockException {
        FrontOfficeMIDashboardAnalytics analytics = createFrontOfficeMIDashboardAnalytics();
        
        when(UpsertRequestBuilder.create(anyString(), anyString())).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withDocument(any(Document.class))).thenReturn(upsertRequestBuilder);
        when(upsertRequestBuilder.withKey(anyString())).thenReturn(upsertRequestBuilder);
        when(dfClient.upsert(upsertRequestBuilder)).thenThrow(new UpsertException("Test exception"));
        
        repository.upsertFoMiSnapshot(analytics);
    }

    @Test
    public void testFetchStatistics() throws ScanException, IOException {
        DFQueryMetaData queryMetaData = createDFQueryMetaData();
        String selectField = "count";
        
        doReturn(scanRequestBuilder).when(repository).getScanRequestBuilder(eq(queryMetaData), anyString(), anyString());
        when(scanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(scanRequestBuilder);
        when(dfClient.scan(scanRequestBuilder)).thenReturn(scanResult);
        when(scanResult.iterator()).thenReturn(recordIterator);
        when(recordIterator.hasNext()).thenReturn(true, false);
        when(recordIterator.next()).thenReturn(dfRecord);
        when(dfRecord.getDocument()).thenReturn(jsonDocument);
        when(jsonDocument.getContents()).thenReturn("{\"count\": 42}");
        
        int result = repository.fetchStatistics(queryMetaData, selectField);
        
        assertEquals(42, result);
        verify(dfClient).scan(scanRequestBuilder);
    }

    @Test
    public void testFetchStatisticsWithNoResults() throws ScanException {
        DFQueryMetaData queryMetaData = createDFQueryMetaData();
        String selectField = "count";
        
        doReturn(scanRequestBuilder).when(repository).getScanRequestBuilder(eq(queryMetaData), anyString(), anyString());
        when(scanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(scanRequestBuilder);
        when(dfClient.scan(scanRequestBuilder)).thenReturn(null);
        
        int result = repository.fetchStatistics(queryMetaData, selectField);
        
        assertEquals(0, result);
        verify(dfClient).scan(scanRequestBuilder);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testFetchStatisticsWithException() throws ScanException, IOException {
        DFQueryMetaData queryMetaData = createDFQueryMetaData();
        String selectField = "count";
        
        doReturn(scanRequestBuilder).when(repository).getScanRequestBuilder(eq(queryMetaData), anyString(), anyString());
        when(scanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(scanRequestBuilder);
        when(dfClient.scan(scanRequestBuilder)).thenReturn(scanResult);
        when(scanResult.iterator()).thenReturn(recordIterator);
        when(recordIterator.hasNext()).thenReturn(true);
        when(recordIterator.next()).thenReturn(dfRecord);
        when(dfRecord.getDocument()).thenReturn(jsonDocument);
        when(jsonDocument.getContents()).thenReturn("invalid json");
        
        repository.fetchStatistics(queryMetaData, selectField);
    }

    @Test
    public void testFetchRecordsFromDf() {
        DFQueryMetaData queryMetaData = createDFQueryMetaData();
        List<Record> expectedRecords = Lists.newArrayList(dfRecord);
        
        doReturn(scanRequestBuilder).when(repository).getScanRequestBuilder(eq(queryMetaData), anyString(), anyString());
        when(scanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(scanRequestBuilder);
        when(dfClient.scan(scanRequestBuilder)).thenReturn(scanResult);
        when(scanResult.iterator()).thenReturn(recordIterator);
        when(recordIterator.hasNext()).thenReturn(true, false);
        when(recordIterator.next()).thenReturn(dfRecord);
        when(dfRecord.getDocument()).thenReturn(jsonDocument);
        
        List<Record> result = repository.fetchRecordsFromDf(queryMetaData);
        
        assertEquals(expectedRecords.size(), result.size());
        verify(dfClient).scan(scanRequestBuilder);
    }

    @Test(expected = TaggingServiceRunTimeException.class)
    public void testFetchRecordsFromDfWithException() {
        DFQueryMetaData queryMetaData = createDFQueryMetaData();
        
        doReturn(scanRequestBuilder).when(repository).getScanRequestBuilder(eq(queryMetaData), anyString(), anyString());
        when(scanRequestBuilder.withReadTimeoutSeconds(anyInt())).thenReturn(scanRequestBuilder);
        when(dfClient.scan(scanRequestBuilder)).thenThrow(new RuntimeException("Test exception"));
        
        repository.fetchRecordsFromDf(queryMetaData);
    }

    @Test
    public void testCalculateMiSnapshotKey() throws Exception {
        SubjectIdentifier subjectIdentifier = new SubjectIdentifier("lei", "assetClass", "entity", 
                "flow", "regulation", "messageType", new Date());
        
        String result = invokePrivateMethod(repository, "calculateMiSnapshotKey", 
                new Class[]{SubjectIdentifier.class}, subjectIdentifier);
        
        assertNotNull(result);
        assertTrue(result.length() > 0);
    }

    @Test
    public void testCalculateFoMiSnapshotKey() throws Exception {
        FrontOfficeSubjectIdentifier subjectIdentifier = new FrontOfficeSubjectIdentifier("entity", 
                "lei", "assetClass", "regulation", new Date());
        
        String result = invokePrivateMethod(repository, "calculateFoMiSnapshotKey", 
                new Class[]{FrontOfficeSubjectIdentifier.class}, subjectIdentifier);
        
        assertNotNull(result);
        assertTrue(result.length() > 0);
    }

    @Test
    public void testGetURL() {
        when(itrConfiguration.getItr2ProtocolScheme()).thenReturn("https");
        when(itrConfiguration.getItr2ServiceName()).thenReturn("test-service");
        
        String result = repository.getURL("test-endpoint");
        
        assertEquals("https://test-service/test-endpoint", result);
    }

    @Test
    public void testItrQueryForFO() {
        DFQueryMetaData queryMetaData = createDFQueryMetaData();
        queryMetaData.setSelect("select clause");
        queryMetaData.setWhere("where clause");
        
        Itr2Query result = repository.itrQueryForFO(queryMetaData);
        
        assertNotNull(result);
    }

    @Test
    public void testParseItrRecordForCftcCsaFx() throws Exception {
        String jsonContent = "{\"canada\":\"{VERSION_REPORTABLE=true, TRANSACTION_REPORTABLE=true}\", " +
                "\"cftc\":\"{VERSION_REPORTABLE=false, TRANSACTION_REPORTABLE=true}\", " +
                "\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\"}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.FOREIGN_EXCHANGE.value(), CFTC_CSA);
        
        assertTrue(result.containsKey(CSA));
        assertTrue(result.containsKey(DF));
        assertEquals(LEI_NWM_PLC, result.get(CSA).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(CSA).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(CSA).get(TRANSACTION_REPORTABLE));
        assertEquals(LEI_NWM_PLC, result.get(DF).get(TRADING_PARTY_LEI));
        assertEquals(false, result.get(DF).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(DF).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForCftcCsaIr() throws Exception {
        String jsonContent = "{\"canada\":\"{VERSION_REPORTABLE=true, TRANSACTION_REPORTABLE=true}\", " +
                "\"cftc\":\"{VERSION_REPORTABLE=false, TRANSACTION_REPORTABLE=true}\", " +
                "\"PARTY_LEI_CODE\":\"" + LEI_NWM_PLC + "\"}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.INTEREST_RATE.value(), CFTC_CSA);
        
        assertTrue(result.containsKey(CSA));
        assertTrue(result.containsKey(DF));
        assertEquals(LEI_NWM_PLC, result.get(CSA).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(CSA).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(CSA).get(TRANSACTION_REPORTABLE));
        assertEquals(LEI_NWM_PLC, result.get(DF).get(TRADING_PARTY_LEI));
        assertEquals(false, result.get(DF).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(DF).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForBoi() throws Exception {
        String jsonContent = "{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\", " +
                "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.FOREIGN_EXCHANGE.value(), BOI);
        
        assertTrue(result.containsKey(BOI));
        assertEquals(LEI_NWM_PLC, result.get(BOI).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(BOI).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(BOI).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForMifidEtd() throws Exception {
        String jsonContent = "{\"tradingCapacity\":\"Dealing On Own Account\", " +
                "\"reportingPartyBookId\":\"RANL01\", " +
                "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.ETD.value(), MIFID);
        
        assertTrue(result.containsKey(MIFID));
        assertEquals(LEI_NWM_PLC, result.get(MIFID).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(MIFID).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(MIFID).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForMifidOtherAsset() throws Exception {
        String jsonContent = "{\"" + MIFID_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_PLC + "\", " +
                "\"" + MIFID_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(VERSION_REPORTABLE) + "\":true, " +
                "\"" + MIFID_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(TRANSACTION_REPORTABLE) + "\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.FOREIGN_EXCHANGE.value(), MIFID);
        
        assertTrue(result.containsKey(MIFID));
        assertEquals(LEI_NWM_PLC, result.get(MIFID).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(MIFID).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(MIFID).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForEmirEtd() throws Exception {
        String jsonContent = "{\"" + EMIR_ASSETWISE_PARSE_DATA.get(AssetClass.ETD.value()).get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_PLC + "\", " +
                "\"" + EMIR_ASSETWISE_PARSE_DATA.get(AssetClass.ETD.value()).get(VERSION_REPORTABLE) + "\":true, " +
                "\"" + EMIR_ASSETWISE_PARSE_DATA.get(AssetClass.ETD.value()).get(TRANSACTION_REPORTABLE) + "\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.ETD.value(), EMIR);
        
        assertTrue(result.containsKey(EMIR));
        assertEquals(LEI_NWM_PLC, result.get(EMIR).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(EMIR).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(EMIR).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForMasIr() throws Exception {
        String jsonContent = "{\"" + MAS_ASSETWISE_PARSE_DATA.get(AssetClass.INTEREST_RATE.value()).get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_PLC + "\", " +
                "\"" + MAS_ASSETWISE_PARSE_DATA.get(AssetClass.INTEREST_RATE.value()).get(VERSION_REPORTABLE) + "\":true, " +
                "\"" + MAS_ASSETWISE_PARSE_DATA.get(AssetClass.INTEREST_RATE.value()).get(TRANSACTION_REPORTABLE) + "\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.INTEREST_RATE.value(), MAS);
        
        assertTrue(result.containsKey(MAS));
        assertEquals(LEI_NWM_PLC, result.get(MAS).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(MAS).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(MAS).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForSftr() throws Exception {
        String jsonContent = "{\"" + SFTR_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(TRADING_PARTY_LEI) + "\":\"" + LEI_NWM_PLC + "\", " +
                "\"" + SFTR_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(VERSION_REPORTABLE) + "\":true, " +
                "\"" + SFTR_ASSETWISE_PARSE_DATA.get(AssetClass.FOREIGN_EXCHANGE.value()).get(TRANSACTION_REPORTABLE) + "\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.FOREIGN_EXCHANGE.value(), SFTR);
        
        assertTrue(result.containsKey(SFTR));
        assertEquals(LEI_NWM_PLC, result.get(SFTR).get(TRADING_PARTY_LEI));
        assertEquals(true, result.get(SFTR).get(VERSION_REPORTABLE));
        assertEquals(true, result.get(SFTR).get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForForeignExchange() throws Exception {
        String jsonContent = "{\"TRADING_PARTY_LEI\":\"" + LEI_NWM_PLC + "\", " +
                "\"VERSION_REPORTABLE\":true, \"TRANSACTION_REPORTABLE\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.FOREIGN_EXCHANGE.value(), "OTHER");
        
        assertTrue(result.containsKey("OTHER"));
        assertEquals(LEI_NWM_PLC, result.get("OTHER").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("OTHER").get(VERSION_REPORTABLE));
        assertEquals(true, result.get("OTHER").get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForCredit() throws Exception {
        String jsonContent = "{\"PARTY_LEI_CODE\":\"" + LEI_NWM_PLC + "\", " +
                "\"emir.isVersionReportable\":true, \"emir.isEligible\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.CREDIT.value(), "OTHER");
        
        assertTrue(result.containsKey("OTHER"));
        assertEquals(LEI_NWM_PLC, result.get("OTHER").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("OTHER").get(VERSION_REPORTABLE));
        assertEquals(true, result.get("OTHER").get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseItrRecordForInterestRate() throws Exception {
        String jsonContent = "{\"PARTY_LEI_CODE\":\"" + LEI_NWM_PLC + "\", " +
                "\"VERSION_REPORTABLE\":true, \"isEligible\":true}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map<String, Map<String, Object>> result = repository.parseItrRecord(jsonParser, 
                AssetClass.INTEREST_RATE.value(), "OTHER");
        
        assertTrue(result.containsKey("OTHER"));
        assertEquals(LEI_NWM_PLC, result.get("OTHER").get(TRADING_PARTY_LEI));
        assertEquals(true, result.get("OTHER").get(VERSION_REPORTABLE));
        assertEquals(true, result.get("OTHER").get(TRANSACTION_REPORTABLE));
    }

    @Test
    public void testParseRecord() throws Exception {
        String jsonContent = "{\"key1\":\"value1\", \"key2\":{\"nestedKey\":\"nestedValue\"}}";
        JsonParser jsonParser = objectMapper.getFactory().createParser(jsonContent);
        jsonParser.nextToken(); // Move to the start object token
        
        Map
