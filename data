@Test
public void testCalculateThresholdCount_Success() throws Exception {
    DfScanParameters param = createParam("Transaction");
    List<DfScanParameters> scanParamList = Lists.newArrayList(param);
    String recon_select_result = "{ \"totalCount\": 100 }";
    PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(recon_select_result)), false, "scanId", 1);
    Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
        .thenReturn(pagedScan);
    
    int count = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateThresholdCount", scanParamList, userName);
    assertEquals(100, count);
}

@Test(expected = ScanException.class)
public void testCalculateThresholdCount_ScanException() throws Exception {
    DfScanParameters param = createParam("Transaction");
    List<DfScanParameters> scanParamList = Lists.newArrayList(param);
    Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
        .thenThrow(new ScanException("DF error"));
    
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "calculateThresholdCount", scanParamList, userName);
}

@Test
public void testModifyFileName_Success() throws Exception {
    DfScanParameters param = createParam("Reconciliation");
    List<DfScanParameters> scanParamList = Lists.newArrayList(param);
    String recon_select_result = "{ \"reconciliationBusinessDateTime\": \"2025-03-26T00:00:00.000Z\", \"identifier\": \"EmirDelegationFx\" }";
    PagedScanResult pagedScan = new PagedScanResult(getMockRecords(Lists.newArrayList(recon_select_result)), false, "scanId", 1);
    Mockito.when(client.pagedScan(Mockito.any(ScanRequestBuilder.class)))
        .thenReturn(pagedScan);
    
    String fileName = "testFile";
    String newFileName = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "modifyFileName", scanParamList, fileName);
    assertEquals("EmirDelegationFx_2025-03-26_testFile", newFileName);
}

@Test
public void testPopulateNextRunDate_BeforeCurrentTime() throws Exception {
    String nextRun = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateNextRunDate", "8:30 AM");
    assertNotNull(nextRun);
}

@Test
public void testPopulateNextRunDate_AfterCurrentTime() throws Exception {
    // Test with time after current system time
    DateTime futureTime = dateTimeService.getCurrentUTCDateTime().plusHours(2);
    String timeStr = new SimpleDateFormat("hh:mm a").format(futureTime.toDate());
    String nextRun = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateNextRunDate", timeStr);
    assertNotNull(nextRun);
}

@Test(expected = BlotterRunTimeException.class)
public void testPopulateNextRunDate_ParseException() throws Exception {
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateNextRunDate", "invalid_time");
}

@Test
public void testPopulateDynamicDate_WithDynamicDate() {
    String clause = "(date >= {T-3})";
    String updatedClause = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateDynamicDate", clause);
    assertTrue(updatedClause.contains("202"));
}

@Test
public void testPopulateDynamicDate_NoDynamicDate() {
    String clause = "(date >= '2023-01-01')";
    String updatedClause = ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "populateDynamicDate", clause);
    assertEquals(clause, updatedClause);
}

@Test
public void testResumeInQueueScans_WithQueue() {
    DfExportScan scan = createScan("scan1", "Transaction", "user");
    scan.setExecutionStatus(STATUS_IN_QUEUE);
    Mockito.when(exportRepo.fetchScansWithStatus(STATUS_IN_QUEUE))
        .thenReturn(Lists.newArrayList(scan));
    
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "resumeInQueueScans");
    Mockito.verify(exportRepo, Mockito.times(1)).fetchScansWithStatus(STATUS_IN_QUEUE);
}

@Test
public void testSubmitTask_InterruptedException() throws InterruptedException {
    BlockingQueue<DfExportJob> queue = Mockito.mock(BlockingQueue.class);
    ReflectionTestUtils.setField(dataFabricExportServiceImpl, "queue", queue);
    Mockito.doThrow(new InterruptedException()).when(queue).put(Mockito.any());
    
    boolean result = dataFabricExportServiceImpl.submitTask(new DfExportJob());
    assertFalse(result);
    assertTrue(Thread.interrupted()); // Clear interrupt status
}

@Test
public void testGenerateMiSnapShotReport_MultipleAssets() throws Exception {
    String trade_snapshot = "{ \"_id\": { \"subjectIdentifier.assetClass\": \"ForeignExchange\" }, ... }"; // Include other fields
    Map<String, String> assetMap = fetchRecordList_For_Snapshot(trade_snapshot).get(0);
    assetMap.put("assetClass", "FOREIGN_EXCHANGE");
    
    List<Map<String, String>> records = Lists.newArrayList(assetMap);
    Mockito.when(dataFabricExportUtil.convertScannedRecords(Mockito.any(), Mockito.any(), Mockito.any()))
        .thenReturn(records);
    
    service.generateMiSnapShotReport(Lists.newArrayList(createParam("Transaction")),
        createScan("scanId", "Transaction", "MIEXTRACT"), "snapshotFileName");
    Mockito.verify(csvWriter, Mockito.atLeastOnce()).generateCsvFile(Mockito.any(), Mockito.any(), Mockito.any());
}

@Test
public void testBifurcateKnownRecords_WithJiraIds() {
    Map<String, String> record = new HashMap<>();
    record.put("Jira", "JIRA-1,JIRA-2");
    record.put("Asset Class Final", "FX");
    // Add other required fields...
    
    List<Map<String, String>> bifurcated = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "bifurcateKnownRecords", 
        Lists.newArrayList(record)
    );
    assertEquals(2, bifurcated.size());
}

@Test
public void testBifurcateKnownRecords_NoJiraId() {
    Map<String, String> record = new HashMap<>();
    record.put("Asset Class Final", "FX");
    // Add other required fields...
    
    List<Map<String, String>> bifurcated = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "bifurcateKnownRecords", 
        Lists.newArrayList(record)
    );
    assertEquals(1, bifurcated.size());
}

@Test
public void testGetAssetClassCsvName() {
    assertEquals("FX", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "FOREIGN_EXCHANGE"));
    assertEquals("Rates", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "INTEREST_RATE"));
    assertEquals("NONE", ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "getAssetClassCsvName", "UNKNOWN"));
}

@Test
public void testZipExportFile_Success() throws IOException {
    String fileName = "testFile";
    File testFile = new File("c://Export/20250611/testFile.csv");
    testFile.createNewFile();
    
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "zipExportFile", fileName);
    assertFalse(testFile.exists()); // Original file deleted
    File zipFile = new File("c://Export/20250611/MI/testFile.zip");
    assertTrue(zipFile.exists());
    zipFile.delete();
}

@Test
public void testZipExportFile_IOException() throws IOException {
    String fileName = "nonExistentFile";
    ReflectionTestUtils.invokeMethod(dataFabricExportServiceImpl, "zipExportFile", fileName);
    // Verify error is logged
}

@Test
public void testPopulateEmailNotification() {
    DfExportScan scan = createScan("scanId", "Transaction", "user@example.com");
    scan.setBlotterName("TestBlotter");
    scan.setExportRecordCount(100);
    scan.setExecutionTime("10");
    scan.setLastExecutionDateTime("11-06-2025 12:00:00");
    
    EmailContent email = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "populateEmailNotification", 
        scan
    );
    assertTrue(email.getEmailBody().contains("TestBlotter"));
    assertTrue(email.getEmailBody().contains("100"));
}

@Test
public void testUpdateFailedScan() {
    DfExportScan scan = createScan("scanId", "Collection", "user");
    Mockito.when(exportRepo.fetchDfScanById("scanId")).thenReturn(scan);
    
    ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "updateFailedScan", 
        "scanId", "STATUS_FAILED", "Error message"
    );
    assertEquals("STATUS_FAILED", scan.getExecutionStatus());
    Mockito.verify(exportRepo, Mockito.times(1)).upsertDfScan(scan);
}

@Test
public void testExportDataToFile_MIUnknown() throws Exception {
    DfExportScan scan = new DfExportScan();
    scan.setBlotterName("AgeBucketTest");
    Set<String> headers = Sets.newHashSet("header1");
    String fileName = "testFile";
    List<Record> records = getMockRecords(getJsonRecords());
    
    int count = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl,
        "exportDataToFile",
        scan, headers, fileName, "MI_UNKNOWN", records
    );
    assertEquals(1, count);
    // Verify "Age Bucket in Days" is added to records
}

@Test
public void testGenerateScanRequestId() {
    String scanId = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl, 
        "generateScanRequestId", 
        "user"
    );
    assertTrue(scanId.startsWith("user"));
    assertTrue(scanId.contains("SCAN_REQ_ID"));
}

@Test
public void testGetTotalFromMap() {
    Map<String, Map<String, String>> assetMap = new HashMap<>();
    assetMap.put("FX", Collections.singletonMap("count", "10"));
    assetMap.put("Rates", Collections.singletonMap("count", "20"));
    
    int total = ReflectionTestUtils.invokeMethod(
        dataFabricExportServiceImpl,
        "getTotalFromMap",
        assetMap, "count", Lists.newArrayList("FX", "Rates")
    );
    assertEquals(30, total);
}
